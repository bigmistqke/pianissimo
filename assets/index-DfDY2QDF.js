true&&(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
}());

const sharedConfig = {
  context: undefined,
  registry: undefined,
  effects: undefined,
  done: false,
  getContextId() {
    return getContextId(this.context.count);
  },
  getNextContextId() {
    return getContextId(this.context.count++);
  }
};
function getContextId(count) {
  const num = String(count),
    len = num.length - 1;
  return sharedConfig.context.id + (len ? String.fromCharCode(96 + len) : "") + num;
}
function setHydrateContext(context) {
  sharedConfig.context = context;
}

const equalFn = (a, b) => a === b;
const $PROXY = Symbol("solid-proxy");
const SUPPORTS_PROXY = typeof Proxy === "function";
const $TRACK = Symbol("solid-track");
const signalOptions = {
  equals: equalFn
};
let runEffects = runQueue;
const STALE = 1;
const PENDING = 2;
const UNOWNED = {
  owned: null,
  cleanups: null,
  context: null,
  owner: null
};
const NO_INIT = {};
var Owner = null;
let Transition = null;
let ExternalSourceConfig = null;
let Listener$1 = null;
let Updates = null;
let Effects = null;
let ExecCount = 0;
function createRoot(fn, detachedOwner) {
  const listener = Listener$1,
    owner = Owner,
    unowned = fn.length === 0,
    current = detachedOwner === undefined ? owner : detachedOwner,
    root = unowned
      ? UNOWNED
      : {
          owned: null,
          cleanups: null,
          context: current ? current.context : null,
          owner: current
        },
    updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root)));
  Owner = root;
  Listener$1 = null;
  try {
    return runUpdates(updateFn, true);
  } finally {
    Listener$1 = listener;
    Owner = owner;
  }
}
function createSignal(value, options) {
  options = options ? Object.assign({}, signalOptions, options) : signalOptions;
  const s = {
    value,
    observers: null,
    observerSlots: null,
    comparator: options.equals || undefined
  };
  const setter = value => {
    if (typeof value === "function") {
      value = value(s.value);
    }
    return writeSignal(s, value);
  };
  return [readSignal.bind(s), setter];
}
function createComputed(fn, value, options) {
  const c = createComputation(fn, value, true, STALE);
  updateComputation(c);
}
function createRenderEffect(fn, value, options) {
  const c = createComputation(fn, value, false, STALE);
  updateComputation(c);
}
function createEffect(fn, value, options) {
  runEffects = runUserEffects;
  const c = createComputation(fn, value, false, STALE);
  if (!options || !options.render) c.user = true;
  Effects ? Effects.push(c) : updateComputation(c);
}
function createMemo(fn, value, options) {
  options = options ? Object.assign({}, signalOptions, options) : signalOptions;
  const c = createComputation(fn, value, true, 0);
  c.observers = null;
  c.observerSlots = null;
  c.comparator = options.equals || undefined;
  updateComputation(c);
  return readSignal.bind(c);
}
function isPromise(v) {
  return v && typeof v === "object" && "then" in v;
}
function createResource(pSource, pFetcher, pOptions) {
  let source;
  let fetcher;
  let options;
  if ((arguments.length === 2 && typeof pFetcher === "object") || arguments.length === 1) {
    source = true;
    fetcher = pSource;
    options = pFetcher || {};
  } else {
    source = pSource;
    fetcher = pFetcher;
    options = pOptions || {};
  }
  let pr = null,
    initP = NO_INIT,
    id = null,
    scheduled = false,
    resolved = "initialValue" in options,
    dynamic = typeof source === "function" && createMemo(source);
  const contexts = new Set(),
    [value, setValue] = (options.storage || createSignal)(options.initialValue),
    [error, setError] = createSignal(undefined),
    [track, trigger] = createSignal(undefined, {
      equals: false
    }),
    [state, setState] = createSignal(resolved ? "ready" : "unresolved");
  if (sharedConfig.context) {
    id = sharedConfig.getNextContextId();
    if (options.ssrLoadFrom === "initial") initP = options.initialValue;
    else if (sharedConfig.load && sharedConfig.has(id)) initP = sharedConfig.load(id);
  }
  function loadEnd(p, v, error, key) {
    if (pr === p) {
      pr = null;
      key !== undefined && (resolved = true);
      if ((p === initP || v === initP) && options.onHydrated)
        queueMicrotask(() =>
          options.onHydrated(key, {
            value: v
          })
        );
      initP = NO_INIT;
      completeLoad(v, error);
    }
    return v;
  }
  function completeLoad(v, err) {
    runUpdates(() => {
      if (err === undefined) setValue(() => v);
      setState(err !== undefined ? "errored" : resolved ? "ready" : "unresolved");
      setError(err);
      for (const c of contexts.keys()) c.decrement();
      contexts.clear();
    }, false);
  }
  function read() {
    const c = SuspenseContext,
      v = value(),
      err = error();
    if (err !== undefined && !pr) throw err;
    if (Listener$1 && !Listener$1.user && c) ;
    return v;
  }
  function load(refetching = true) {
    if (refetching !== false && scheduled) return;
    scheduled = false;
    const lookup = dynamic ? dynamic() : source;
    if (lookup == null || lookup === false) {
      loadEnd(pr, untrack(value));
      return;
    }
    const p =
      initP !== NO_INIT
        ? initP
        : untrack(() =>
            fetcher(lookup, {
              value: value(),
              refetching
            })
          );
    if (!isPromise(p)) {
      loadEnd(pr, p, undefined, lookup);
      return p;
    }
    pr = p;
    if ("value" in p) {
      if (p.status === "success") loadEnd(pr, p.value, undefined, lookup);
      else loadEnd(pr, undefined, castError(p.value), lookup);
      return p;
    }
    scheduled = true;
    queueMicrotask(() => (scheduled = false));
    runUpdates(() => {
      setState(resolved ? "refreshing" : "pending");
      trigger();
    }, false);
    return p.then(
      v => loadEnd(p, v, undefined, lookup),
      e => loadEnd(p, undefined, castError(e), lookup)
    );
  }
  Object.defineProperties(read, {
    state: {
      get: () => state()
    },
    error: {
      get: () => error()
    },
    loading: {
      get() {
        const s = state();
        return s === "pending" || s === "refreshing";
      }
    },
    latest: {
      get() {
        if (!resolved) return read();
        const err = error();
        if (err && !pr) throw err;
        return value();
      }
    }
  });
  if (dynamic) createComputed(() => load(false));
  else load(false);
  return [
    read,
    {
      refetch: load,
      mutate: setValue
    }
  ];
}
function createSelector(source, fn = equalFn, options) {
  const subs = new Map();
  const node = createComputation(
    p => {
      const v = source();
      for (const [key, val] of subs.entries())
        if (fn(key, v) !== fn(key, p)) {
          for (const c of val.values()) {
            c.state = STALE;
            if (c.pure) Updates.push(c);
            else Effects.push(c);
          }
        }
      return v;
    },
    undefined,
    true,
    STALE
  );
  updateComputation(node);
  return key => {
    const listener = Listener$1;
    if (listener) {
      let l;
      if ((l = subs.get(key))) l.add(listener);
      else subs.set(key, (l = new Set([listener])));
      onCleanup(() => {
        l.delete(listener);
        !l.size && subs.delete(key);
      });
    }
    return fn(
      key,
      node.value
    );
  };
}
function batch(fn) {
  return runUpdates(fn, false);
}
function untrack(fn) {
  if (Listener$1 === null) return fn();
  const listener = Listener$1;
  Listener$1 = null;
  try {
    if (ExternalSourceConfig) ;
    return fn();
  } finally {
    Listener$1 = listener;
  }
}
function on(deps, fn, options) {
  const isArray = Array.isArray(deps);
  let prevInput;
  let defer = options && options.defer;
  return prevValue => {
    let input;
    if (isArray) {
      input = Array(deps.length);
      for (let i = 0; i < deps.length; i++) input[i] = deps[i]();
    } else input = deps();
    if (defer) {
      defer = false;
      return prevValue;
    }
    const result = untrack(() => fn(input, prevInput, prevValue));
    prevInput = input;
    return result;
  };
}
function onMount(fn) {
  createEffect(() => untrack(fn));
}
function onCleanup(fn) {
  if (Owner === null);
  else if (Owner.cleanups === null) Owner.cleanups = [fn];
  else Owner.cleanups.push(fn);
  return fn;
}
function getListener() {
  return Listener$1;
}
function getOwner() {
  return Owner;
}
function runWithOwner(o, fn) {
  const prev = Owner;
  const prevListener = Listener$1;
  Owner = o;
  Listener$1 = null;
  try {
    return runUpdates(fn, true);
  } catch (err) {
    handleError$1(err);
  } finally {
    Owner = prev;
    Listener$1 = prevListener;
  }
}
function createContext(defaultValue, options) {
  const id = Symbol("context");
  return {
    id,
    Provider: createProvider(id),
    defaultValue
  };
}
function useContext(context) {
  let value;
  return Owner && Owner.context && (value = Owner.context[context.id]) !== undefined
    ? value
    : context.defaultValue;
}
function children(fn) {
  const children = createMemo(fn);
  const memo = createMemo(() => resolveChildren(children()));
  memo.toArray = () => {
    const c = memo();
    return Array.isArray(c) ? c : c != null ? [c] : [];
  };
  return memo;
}
let SuspenseContext;
function readSignal() {
  if (this.sources && (this.state)) {
    if ((this.state) === STALE) updateComputation(this);
    else {
      const updates = Updates;
      Updates = null;
      runUpdates(() => lookUpstream(this), false);
      Updates = updates;
    }
  }
  if (Listener$1) {
    const sSlot = this.observers ? this.observers.length : 0;
    if (!Listener$1.sources) {
      Listener$1.sources = [this];
      Listener$1.sourceSlots = [sSlot];
    } else {
      Listener$1.sources.push(this);
      Listener$1.sourceSlots.push(sSlot);
    }
    if (!this.observers) {
      this.observers = [Listener$1];
      this.observerSlots = [Listener$1.sources.length - 1];
    } else {
      this.observers.push(Listener$1);
      this.observerSlots.push(Listener$1.sources.length - 1);
    }
  }
  return this.value;
}
function writeSignal(node, value, isComp) {
  let current =
    node.value;
  if (!node.comparator || !node.comparator(current, value)) {
    node.value = value;
    if (node.observers && node.observers.length) {
      runUpdates(() => {
        for (let i = 0; i < node.observers.length; i += 1) {
          const o = node.observers[i];
          const TransitionRunning = Transition && Transition.running;
          if (TransitionRunning && Transition.disposed.has(o)) ;
          if (TransitionRunning ? !o.tState : !o.state) {
            if (o.pure) Updates.push(o);
            else Effects.push(o);
            if (o.observers) markDownstream(o);
          }
          if (!TransitionRunning) o.state = STALE;
        }
        if (Updates.length > 10e5) {
          Updates = [];
          if (false);
          throw new Error();
        }
      }, false);
    }
  }
  return value;
}
function updateComputation(node) {
  if (!node.fn) return;
  cleanNode(node);
  const time = ExecCount;
  runComputation(
    node,
    node.value,
    time
  );
}
function runComputation(node, value, time) {
  let nextValue;
  const owner = Owner,
    listener = Listener$1;
  Listener$1 = Owner = node;
  try {
    nextValue = node.fn(value);
  } catch (err) {
    if (node.pure) {
      {
        node.state = STALE;
        node.owned && node.owned.forEach(cleanNode);
        node.owned = null;
      }
    }
    node.updatedAt = time + 1;
    return handleError$1(err);
  } finally {
    Listener$1 = listener;
    Owner = owner;
  }
  if (!node.updatedAt || node.updatedAt <= time) {
    if (node.updatedAt != null && "observers" in node) {
      writeSignal(node, nextValue);
    } else node.value = nextValue;
    node.updatedAt = time;
  }
}
function createComputation(fn, init, pure, state = STALE, options) {
  const c = {
    fn,
    state: state,
    updatedAt: null,
    owned: null,
    sources: null,
    sourceSlots: null,
    cleanups: null,
    value: init,
    owner: Owner,
    context: Owner ? Owner.context : null,
    pure
  };
  if (Owner === null);
  else if (Owner !== UNOWNED) {
    {
      if (!Owner.owned) Owner.owned = [c];
      else Owner.owned.push(c);
    }
  }
  return c;
}
function runTop(node) {
  if ((node.state) === 0) return;
  if ((node.state) === PENDING) return lookUpstream(node);
  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);
  const ancestors = [node];
  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {
    if (node.state) ancestors.push(node);
  }
  for (let i = ancestors.length - 1; i >= 0; i--) {
    node = ancestors[i];
    if ((node.state) === STALE) {
      updateComputation(node);
    } else if ((node.state) === PENDING) {
      const updates = Updates;
      Updates = null;
      runUpdates(() => lookUpstream(node, ancestors[0]), false);
      Updates = updates;
    }
  }
}
function runUpdates(fn, init) {
  if (Updates) return fn();
  let wait = false;
  if (!init) Updates = [];
  if (Effects) wait = true;
  else Effects = [];
  ExecCount++;
  try {
    const res = fn();
    completeUpdates(wait);
    return res;
  } catch (err) {
    if (!wait) Effects = null;
    Updates = null;
    handleError$1(err);
  }
}
function completeUpdates(wait) {
  if (Updates) {
    runQueue(Updates);
    Updates = null;
  }
  if (wait) return;
  const e = Effects;
  Effects = null;
  if (e.length) runUpdates(() => runEffects(e), false);
}
function runQueue(queue) {
  for (let i = 0; i < queue.length; i++) runTop(queue[i]);
}
function runUserEffects(queue) {
  let i,
    userLength = 0;
  for (i = 0; i < queue.length; i++) {
    const e = queue[i];
    if (!e.user) runTop(e);
    else queue[userLength++] = e;
  }
  if (sharedConfig.context) {
    if (sharedConfig.count) {
      sharedConfig.effects || (sharedConfig.effects = []);
      sharedConfig.effects.push(...queue.slice(0, userLength));
      return;
    }
    setHydrateContext();
  }
  if (sharedConfig.effects && (sharedConfig.done || !sharedConfig.count)) {
    queue = [...sharedConfig.effects, ...queue];
    userLength += sharedConfig.effects.length;
    delete sharedConfig.effects;
  }
  for (i = 0; i < userLength; i++) runTop(queue[i]);
}
function lookUpstream(node, ignore) {
  node.state = 0;
  for (let i = 0; i < node.sources.length; i += 1) {
    const source = node.sources[i];
    if (source.sources) {
      const state = source.state;
      if (state === STALE) {
        if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount))
          runTop(source);
      } else if (state === PENDING) lookUpstream(source, ignore);
    }
  }
}
function markDownstream(node) {
  for (let i = 0; i < node.observers.length; i += 1) {
    const o = node.observers[i];
    if (!o.state) {
      o.state = PENDING;
      if (o.pure) Updates.push(o);
      else Effects.push(o);
      o.observers && markDownstream(o);
    }
  }
}
function cleanNode(node) {
  let i;
  if (node.sources) {
    while (node.sources.length) {
      const source = node.sources.pop(),
        index = node.sourceSlots.pop(),
        obs = source.observers;
      if (obs && obs.length) {
        const n = obs.pop(),
          s = source.observerSlots.pop();
        if (index < obs.length) {
          n.sourceSlots[s] = index;
          obs[index] = n;
          source.observerSlots[index] = s;
        }
      }
    }
  }
  if (node.tOwned) {
    for (i = node.tOwned.length - 1; i >= 0; i--) cleanNode(node.tOwned[i]);
    delete node.tOwned;
  }
  if (node.owned) {
    for (i = node.owned.length - 1; i >= 0; i--) cleanNode(node.owned[i]);
    node.owned = null;
  }
  if (node.cleanups) {
    for (i = node.cleanups.length - 1; i >= 0; i--) node.cleanups[i]();
    node.cleanups = null;
  }
  node.state = 0;
}
function castError(err) {
  if (err instanceof Error) return err;
  return new Error(typeof err === "string" ? err : "Unknown error", {
    cause: err
  });
}
function handleError$1(err, owner = Owner) {
  const error = castError(err);
  throw error;
}
function resolveChildren(children) {
  if (typeof children === "function" && !children.length) return resolveChildren(children());
  if (Array.isArray(children)) {
    const results = [];
    for (let i = 0; i < children.length; i++) {
      const result = resolveChildren(children[i]);
      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);
    }
    return results;
  }
  return children;
}
function createProvider(id, options) {
  return function provider(props) {
    let res;
    createRenderEffect(
      () =>
        (res = untrack(() => {
          Owner.context = {
            ...Owner.context,
            [id]: props.value
          };
          return children(() => props.children);
        })),
      undefined
    );
    return res;
  };
}

const FALLBACK = Symbol("fallback");
function dispose(d) {
  for (let i = 0; i < d.length; i++) d[i]();
}
function mapArray(list, mapFn, options = {}) {
  let items = [],
    mapped = [],
    disposers = [],
    len = 0,
    indexes = mapFn.length > 1 ? [] : null;
  onCleanup(() => dispose(disposers));
  return () => {
    let newItems = list() || [],
      newLen = newItems.length,
      i,
      j;
    newItems[$TRACK];
    return untrack(() => {
      let newIndices, newIndicesNext, temp, tempdisposers, tempIndexes, start, end, newEnd, item;
      if (newLen === 0) {
        if (len !== 0) {
          dispose(disposers);
          disposers = [];
          items = [];
          mapped = [];
          len = 0;
          indexes && (indexes = []);
        }
        if (options.fallback) {
          items = [FALLBACK];
          mapped[0] = createRoot(disposer => {
            disposers[0] = disposer;
            return options.fallback();
          });
          len = 1;
        }
      } else if (len === 0) {
        mapped = new Array(newLen);
        for (j = 0; j < newLen; j++) {
          items[j] = newItems[j];
          mapped[j] = createRoot(mapper);
        }
        len = newLen;
      } else {
        temp = new Array(newLen);
        tempdisposers = new Array(newLen);
        indexes && (tempIndexes = new Array(newLen));
        for (
          start = 0, end = Math.min(len, newLen);
          start < end && items[start] === newItems[start];
          start++
        );
        for (
          end = len - 1, newEnd = newLen - 1;
          end >= start && newEnd >= start && items[end] === newItems[newEnd];
          end--, newEnd--
        ) {
          temp[newEnd] = mapped[end];
          tempdisposers[newEnd] = disposers[end];
          indexes && (tempIndexes[newEnd] = indexes[end]);
        }
        newIndices = new Map();
        newIndicesNext = new Array(newEnd + 1);
        for (j = newEnd; j >= start; j--) {
          item = newItems[j];
          i = newIndices.get(item);
          newIndicesNext[j] = i === undefined ? -1 : i;
          newIndices.set(item, j);
        }
        for (i = start; i <= end; i++) {
          item = items[i];
          j = newIndices.get(item);
          if (j !== undefined && j !== -1) {
            temp[j] = mapped[i];
            tempdisposers[j] = disposers[i];
            indexes && (tempIndexes[j] = indexes[i]);
            j = newIndicesNext[j];
            newIndices.set(item, j);
          } else disposers[i]();
        }
        for (j = start; j < newLen; j++) {
          if (j in temp) {
            mapped[j] = temp[j];
            disposers[j] = tempdisposers[j];
            if (indexes) {
              indexes[j] = tempIndexes[j];
              indexes[j](j);
            }
          } else mapped[j] = createRoot(mapper);
        }
        mapped = mapped.slice(0, (len = newLen));
        items = newItems.slice(0);
      }
      return mapped;
    });
    function mapper(disposer) {
      disposers[j] = disposer;
      if (indexes) {
        const [s, set] = createSignal(j);
        indexes[j] = set;
        return mapFn(newItems[j], s);
      }
      return mapFn(newItems[j]);
    }
  };
}
function indexArray(list, mapFn, options = {}) {
  let items = [],
    mapped = [],
    disposers = [],
    signals = [],
    len = 0,
    i;
  onCleanup(() => dispose(disposers));
  return () => {
    const newItems = list() || [],
      newLen = newItems.length;
    newItems[$TRACK];
    return untrack(() => {
      if (newLen === 0) {
        if (len !== 0) {
          dispose(disposers);
          disposers = [];
          items = [];
          mapped = [];
          len = 0;
          signals = [];
        }
        if (options.fallback) {
          items = [FALLBACK];
          mapped[0] = createRoot(disposer => {
            disposers[0] = disposer;
            return options.fallback();
          });
          len = 1;
        }
        return mapped;
      }
      if (items[0] === FALLBACK) {
        disposers[0]();
        disposers = [];
        items = [];
        mapped = [];
        len = 0;
      }
      for (i = 0; i < newLen; i++) {
        if (i < items.length && items[i] !== newItems[i]) {
          signals[i](() => newItems[i]);
        } else if (i >= items.length) {
          mapped[i] = createRoot(mapper);
        }
      }
      for (; i < items.length; i++) {
        disposers[i]();
      }
      len = signals.length = disposers.length = newLen;
      items = newItems.slice(0);
      return (mapped = mapped.slice(0, len));
    });
    function mapper(disposer) {
      disposers[i] = disposer;
      const [s, set] = createSignal(newItems[i]);
      signals[i] = set;
      return mapFn(s, i);
    }
  };
}
function createComponent(Comp, props) {
  return untrack(() => Comp(props || {}));
}
function trueFn() {
  return true;
}
const propTraps = {
  get(_, property, receiver) {
    if (property === $PROXY) return receiver;
    return _.get(property);
  },
  has(_, property) {
    if (property === $PROXY) return true;
    return _.has(property);
  },
  set: trueFn,
  deleteProperty: trueFn,
  getOwnPropertyDescriptor(_, property) {
    return {
      configurable: true,
      enumerable: true,
      get() {
        return _.get(property);
      },
      set: trueFn,
      deleteProperty: trueFn
    };
  },
  ownKeys(_) {
    return _.keys();
  }
};
function resolveSource(s) {
  return !(s = typeof s === "function" ? s() : s) ? {} : s;
}
function resolveSources() {
  for (let i = 0, length = this.length; i < length; ++i) {
    const v = this[i]();
    if (v !== undefined) return v;
  }
}
function mergeProps(...sources) {
  let proxy = false;
  for (let i = 0; i < sources.length; i++) {
    const s = sources[i];
    proxy = proxy || (!!s && $PROXY in s);
    sources[i] = typeof s === "function" ? ((proxy = true), createMemo(s)) : s;
  }
  if (SUPPORTS_PROXY && proxy) {
    return new Proxy(
      {
        get(property) {
          for (let i = sources.length - 1; i >= 0; i--) {
            const v = resolveSource(sources[i])[property];
            if (v !== undefined) return v;
          }
        },
        has(property) {
          for (let i = sources.length - 1; i >= 0; i--) {
            if (property in resolveSource(sources[i])) return true;
          }
          return false;
        },
        keys() {
          const keys = [];
          for (let i = 0; i < sources.length; i++)
            keys.push(...Object.keys(resolveSource(sources[i])));
          return [...new Set(keys)];
        }
      },
      propTraps
    );
  }
  const sourcesMap = {};
  const defined = Object.create(null);
  for (let i = sources.length - 1; i >= 0; i--) {
    const source = sources[i];
    if (!source) continue;
    const sourceKeys = Object.getOwnPropertyNames(source);
    for (let i = sourceKeys.length - 1; i >= 0; i--) {
      const key = sourceKeys[i];
      if (key === "__proto__" || key === "constructor") continue;
      const desc = Object.getOwnPropertyDescriptor(source, key);
      if (!defined[key]) {
        defined[key] = desc.get
          ? {
              enumerable: true,
              configurable: true,
              get: resolveSources.bind((sourcesMap[key] = [desc.get.bind(source)]))
            }
          : desc.value !== undefined
          ? desc
          : undefined;
      } else {
        const sources = sourcesMap[key];
        if (sources) {
          if (desc.get) sources.push(desc.get.bind(source));
          else if (desc.value !== undefined) sources.push(() => desc.value);
        }
      }
    }
  }
  const target = {};
  const definedKeys = Object.keys(defined);
  for (let i = definedKeys.length - 1; i >= 0; i--) {
    const key = definedKeys[i],
      desc = defined[key];
    if (desc && desc.get) Object.defineProperty(target, key, desc);
    else target[key] = desc ? desc.value : undefined;
  }
  return target;
}
function splitProps(props, ...keys) {
  if (SUPPORTS_PROXY && $PROXY in props) {
    const blocked = new Set(keys.length > 1 ? keys.flat() : keys[0]);
    const res = keys.map(k => {
      return new Proxy(
        {
          get(property) {
            return k.includes(property) ? props[property] : undefined;
          },
          has(property) {
            return k.includes(property) && property in props;
          },
          keys() {
            return k.filter(property => property in props);
          }
        },
        propTraps
      );
    });
    res.push(
      new Proxy(
        {
          get(property) {
            return blocked.has(property) ? undefined : props[property];
          },
          has(property) {
            return blocked.has(property) ? false : property in props;
          },
          keys() {
            return Object.keys(props).filter(k => !blocked.has(k));
          }
        },
        propTraps
      )
    );
    return res;
  }
  const otherObject = {};
  const objects = keys.map(() => ({}));
  for (const propName of Object.getOwnPropertyNames(props)) {
    const desc = Object.getOwnPropertyDescriptor(props, propName);
    const isDefaultDesc =
      !desc.get && !desc.set && desc.enumerable && desc.writable && desc.configurable;
    let blocked = false;
    let objectIndex = 0;
    for (const k of keys) {
      if (k.includes(propName)) {
        blocked = true;
        isDefaultDesc
          ? (objects[objectIndex][propName] = desc.value)
          : Object.defineProperty(objects[objectIndex], propName, desc);
      }
      ++objectIndex;
    }
    if (!blocked) {
      isDefaultDesc
        ? (otherObject[propName] = desc.value)
        : Object.defineProperty(otherObject, propName, desc);
    }
  }
  return [...objects, otherObject];
}
let counter = 0;
function createUniqueId() {
  const ctx = sharedConfig.context;
  return ctx ? sharedConfig.getNextContextId() : `cl-${counter++}`;
}

const narrowedError = name => `Stale read from <${name}>.`;
function For(props) {
  const fallback = "fallback" in props && {
    fallback: () => props.fallback
  };
  return createMemo(mapArray(() => props.each, props.children, fallback || undefined));
}
function Index(props) {
  const fallback = "fallback" in props && {
    fallback: () => props.fallback
  };
  return createMemo(indexArray(() => props.each, props.children, fallback || undefined));
}
function Show(props) {
  const keyed = props.keyed;
  const condition = createMemo(() => props.when, undefined, {
    equals: (a, b) => (keyed ? a === b : !a === !b)
  });
  return createMemo(
    () => {
      const c = condition();
      if (c) {
        const child = props.children;
        const fn = typeof child === "function" && child.length > 0;
        return fn
          ? untrack(() =>
              child(
                keyed
                  ? c
                  : () => {
                      if (!untrack(condition)) throw narrowedError("Show");
                      return props.when;
                    }
              )
            )
          : child;
      }
      return props.fallback;
    },
    undefined,
    undefined
  );
}

const booleans = [
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "disabled",
  "formnovalidate",
  "hidden",
  "indeterminate",
  "inert",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "seamless",
  "selected"
];
const Properties = /*#__PURE__*/ new Set([
  "className",
  "value",
  "readOnly",
  "formNoValidate",
  "isMap",
  "noModule",
  "playsInline",
  ...booleans
]);
const ChildProperties = /*#__PURE__*/ new Set([
  "innerHTML",
  "textContent",
  "innerText",
  "children"
]);
const Aliases = /*#__PURE__*/ Object.assign(Object.create(null), {
  className: "class",
  htmlFor: "for"
});
const PropAliases = /*#__PURE__*/ Object.assign(Object.create(null), {
  class: "className",
  formnovalidate: {
    $: "formNoValidate",
    BUTTON: 1,
    INPUT: 1
  },
  ismap: {
    $: "isMap",
    IMG: 1
  },
  nomodule: {
    $: "noModule",
    SCRIPT: 1
  },
  playsinline: {
    $: "playsInline",
    VIDEO: 1
  },
  readonly: {
    $: "readOnly",
    INPUT: 1,
    TEXTAREA: 1
  }
});
function getPropAlias(prop, tagName) {
  const a = PropAliases[prop];
  return typeof a === "object" ? (a[tagName] ? a["$"] : undefined) : a;
}
const DelegatedEvents = /*#__PURE__*/ new Set([
  "beforeinput",
  "click",
  "dblclick",
  "contextmenu",
  "focusin",
  "focusout",
  "input",
  "keydown",
  "keyup",
  "mousedown",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup",
  "pointerdown",
  "pointermove",
  "pointerout",
  "pointerover",
  "pointerup",
  "touchend",
  "touchmove",
  "touchstart"
]);
const SVGElements = /*#__PURE__*/ new Set([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animate",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "circle",
  "clipPath",
  "color-profile",
  "cursor",
  "defs",
  "desc",
  "ellipse",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "filter",
  "font",
  "font-face",
  "font-face-format",
  "font-face-name",
  "font-face-src",
  "font-face-uri",
  "foreignObject",
  "g",
  "glyph",
  "glyphRef",
  "hkern",
  "image",
  "line",
  "linearGradient",
  "marker",
  "mask",
  "metadata",
  "missing-glyph",
  "mpath",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "set",
  "stop",
  "svg",
  "switch",
  "symbol",
  "text",
  "textPath",
  "tref",
  "tspan",
  "use",
  "view",
  "vkern"
]);
const SVGNamespace = {
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace"
};

function reconcileArrays(parentNode, a, b) {
  let bLength = b.length,
    aEnd = a.length,
    bEnd = bLength,
    aStart = 0,
    bStart = 0,
    after = a[aEnd - 1].nextSibling,
    map = null;
  while (aStart < aEnd || bStart < bEnd) {
    if (a[aStart] === b[bStart]) {
      aStart++;
      bStart++;
      continue;
    }
    while (a[aEnd - 1] === b[bEnd - 1]) {
      aEnd--;
      bEnd--;
    }
    if (aEnd === aStart) {
      const node = bEnd < bLength ? (bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart]) : after;
      while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);
    } else if (bEnd === bStart) {
      while (aStart < aEnd) {
        if (!map || !map.has(a[aStart])) a[aStart].remove();
        aStart++;
      }
    } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
      const node = a[--aEnd].nextSibling;
      parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);
      parentNode.insertBefore(b[--bEnd], node);
      a[aEnd] = b[bEnd];
    } else {
      if (!map) {
        map = new Map();
        let i = bStart;
        while (i < bEnd) map.set(b[i], i++);
      }
      const index = map.get(a[aStart]);
      if (index != null) {
        if (bStart < index && index < bEnd) {
          let i = aStart,
            sequence = 1,
            t;
          while (++i < aEnd && i < bEnd) {
            if ((t = map.get(a[i])) == null || t !== index + sequence) break;
            sequence++;
          }
          if (sequence > index - bStart) {
            const node = a[aStart];
            while (bStart < index) parentNode.insertBefore(b[bStart++], node);
          } else parentNode.replaceChild(b[bStart++], a[aStart++]);
        } else aStart++;
      } else a[aStart++].remove();
    }
  }
}

const $$EVENTS = "_$DX_DELEGATE";
function render(code, element, init, options = {}) {
  let disposer;
  createRoot(dispose => {
    disposer = dispose;
    element === document
      ? code()
      : insert(element, code(), element.firstChild ? null : undefined, init);
  }, options.owner);
  return () => {
    disposer();
    element.textContent = "";
  };
}
function template(html, isImportNode, isSVG) {
  let node;
  const create = () => {
    const t = document.createElement("template");
    t.innerHTML = html;
    return isSVG ? t.content.firstChild.firstChild : t.content.firstChild;
  };
  const fn = isImportNode
    ? () => untrack(() => document.importNode(node || (node = create()), true))
    : () => (node || (node = create())).cloneNode(true);
  fn.cloneNode = fn;
  return fn;
}
function delegateEvents(eventNames, document = window.document) {
  const e = document[$$EVENTS] || (document[$$EVENTS] = new Set());
  for (let i = 0, l = eventNames.length; i < l; i++) {
    const name = eventNames[i];
    if (!e.has(name)) {
      e.add(name);
      document.addEventListener(name, eventHandler);
    }
  }
}
function setAttribute(node, name, value) {
  if (isHydrating(node)) return;
  if (value == null) node.removeAttribute(name);
  else node.setAttribute(name, value);
}
function setAttributeNS(node, namespace, name, value) {
  if (isHydrating(node)) return;
  if (value == null) node.removeAttributeNS(namespace, name);
  else node.setAttributeNS(namespace, name, value);
}
function setBoolAttribute(node, name, value) {
  if (isHydrating(node)) return;
  value ? node.setAttribute(name, "") : node.removeAttribute(name);
}
function className(node, value) {
  if (isHydrating(node)) return;
  if (value == null) node.removeAttribute("class");
  else node.className = value;
}
function addEventListener(node, name, handler, delegate) {
  if (delegate) {
    if (Array.isArray(handler)) {
      node[`$$${name}`] = handler[0];
      node[`$$${name}Data`] = handler[1];
    } else node[`$$${name}`] = handler;
  } else if (Array.isArray(handler)) {
    const handlerFn = handler[0];
    node.addEventListener(name, (handler[0] = e => handlerFn.call(node, handler[1], e)));
  } else node.addEventListener(name, handler, typeof handler !== "function" && handler);
}
function classList(node, value, prev = {}) {
  const classKeys = Object.keys(value || {}),
    prevKeys = Object.keys(prev);
  let i, len;
  for (i = 0, len = prevKeys.length; i < len; i++) {
    const key = prevKeys[i];
    if (!key || key === "undefined" || value[key]) continue;
    toggleClassKey(node, key, false);
    delete prev[key];
  }
  for (i = 0, len = classKeys.length; i < len; i++) {
    const key = classKeys[i],
      classValue = !!value[key];
    if (!key || key === "undefined" || prev[key] === classValue || !classValue) continue;
    toggleClassKey(node, key, true);
    prev[key] = classValue;
  }
  return prev;
}
function style(node, value, prev) {
  if (!value) return prev ? setAttribute(node, "style") : value;
  const nodeStyle = node.style;
  if (typeof value === "string") return (nodeStyle.cssText = value);
  typeof prev === "string" && (nodeStyle.cssText = prev = undefined);
  prev || (prev = {});
  value || (value = {});
  let v, s;
  for (s in prev) {
    value[s] == null && nodeStyle.removeProperty(s);
    delete prev[s];
  }
  for (s in value) {
    v = value[s];
    if (v !== prev[s]) {
      nodeStyle.setProperty(s, v);
      prev[s] = v;
    }
  }
  return prev;
}
function spread(node, props = {}, isSVG, skipChildren) {
  const prevProps = {};
  if (!skipChildren) {
    createRenderEffect(
      () => (prevProps.children = insertExpression(node, props.children, prevProps.children))
    );
  }
  createRenderEffect(() => typeof props.ref === "function" && use(props.ref, node));
  createRenderEffect(() => assign$1(node, props, isSVG, true, prevProps, true));
  return prevProps;
}
function use(fn, element, arg) {
  return untrack(() => fn(element, arg));
}
function insert(parent, accessor, marker, initial) {
  if (marker !== undefined && !initial) initial = [];
  if (typeof accessor !== "function") return insertExpression(parent, accessor, initial, marker);
  createRenderEffect(current => insertExpression(parent, accessor(), current, marker), initial);
}
function assign$1(node, props, isSVG, skipChildren, prevProps = {}, skipRef = false) {
  props || (props = {});
  for (const prop in prevProps) {
    if (!(prop in props)) {
      if (prop === "children") continue;
      prevProps[prop] = assignProp(node, prop, null, prevProps[prop], isSVG, skipRef, props);
    }
  }
  for (const prop in props) {
    if (prop === "children") {
      continue;
    }
    const value = props[prop];
    prevProps[prop] = assignProp(node, prop, value, prevProps[prop], isSVG, skipRef, props);
  }
}
function getNextElement(template) {
  let node,
    key,
    hydrating = isHydrating();
  if (!hydrating || !(node = sharedConfig.registry.get((key = getHydrationKey())))) {
    return template();
  }
  if (sharedConfig.completed) sharedConfig.completed.add(node);
  sharedConfig.registry.delete(key);
  return node;
}
function isHydrating(node) {
  return !!sharedConfig.context && !sharedConfig.done && (!node || node.isConnected);
}
function toPropertyName(name) {
  return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());
}
function toggleClassKey(node, key, value) {
  const classNames = key.trim().split(/\s+/);
  for (let i = 0, nameLen = classNames.length; i < nameLen; i++)
    node.classList.toggle(classNames[i], value);
}
function assignProp(node, prop, value, prev, isSVG, skipRef, props) {
  let isCE, isProp, isChildProp, propAlias, forceProp;
  if (prop === "style") return style(node, value, prev);
  if (prop === "classList") return classList(node, value, prev);
  if (value === prev) return prev;
  if (prop === "ref") {
    if (!skipRef) value(node);
  } else if (prop.slice(0, 3) === "on:") {
    const e = prop.slice(3);
    prev && node.removeEventListener(e, prev, typeof prev !== "function" && prev);
    value && node.addEventListener(e, value, typeof value !== "function" && value);
  } else if (prop.slice(0, 10) === "oncapture:") {
    const e = prop.slice(10);
    prev && node.removeEventListener(e, prev, true);
    value && node.addEventListener(e, value, true);
  } else if (prop.slice(0, 2) === "on") {
    const name = prop.slice(2).toLowerCase();
    const delegate = DelegatedEvents.has(name);
    if (!delegate && prev) {
      const h = Array.isArray(prev) ? prev[0] : prev;
      node.removeEventListener(name, h);
    }
    if (delegate || value) {
      addEventListener(node, name, value, delegate);
      delegate && delegateEvents([name]);
    }
  } else if (prop.slice(0, 5) === "attr:") {
    setAttribute(node, prop.slice(5), value);
  } else if (prop.slice(0, 5) === "bool:") {
    setBoolAttribute(node, prop.slice(5), value);
  } else if (
    (forceProp = prop.slice(0, 5) === "prop:") ||
    (isChildProp = ChildProperties.has(prop)) ||
    (!isSVG &&
      ((propAlias = getPropAlias(prop, node.tagName)) || (isProp = Properties.has(prop)))) ||
    (isCE = node.nodeName.includes("-") || "is" in props)
  ) {
    if (forceProp) {
      prop = prop.slice(5);
      isProp = true;
    } else if (isHydrating(node)) return value;
    if (prop === "class" || prop === "className") className(node, value);
    else if (isCE && !isProp && !isChildProp) node[toPropertyName(prop)] = value;
    else node[propAlias || prop] = value;
  } else {
    const ns = isSVG && prop.indexOf(":") > -1 && SVGNamespace[prop.split(":")[0]];
    if (ns) setAttributeNS(node, ns, prop, value);
    else setAttribute(node, Aliases[prop] || prop, value);
  }
  return value;
}
function eventHandler(e) {
  if (sharedConfig.registry && sharedConfig.events) {
    if (sharedConfig.events.find(([el, ev]) => ev === e)) return;
  }
  let node = e.target;
  const key = `$$${e.type}`;
  const oriTarget = e.target;
  const oriCurrentTarget = e.currentTarget;
  const retarget = value =>
    Object.defineProperty(e, "target", {
      configurable: true,
      value
    });
  const handleNode = () => {
    const handler = node[key];
    if (handler && !node.disabled) {
      const data = node[`${key}Data`];
      data !== undefined ? handler.call(node, data, e) : handler.call(node, e);
      if (e.cancelBubble) return;
    }
    node.host &&
      typeof node.host !== "string" &&
      !node.host._$host &&
      node.contains(e.target) &&
      retarget(node.host);
    return true;
  };
  const walkUpTree = () => {
    while (handleNode() && (node = node._$host || node.parentNode || node.host));
  };
  Object.defineProperty(e, "currentTarget", {
    configurable: true,
    get() {
      return node || document;
    }
  });
  if (sharedConfig.registry && !sharedConfig.done) sharedConfig.done = _$HY.done = true;
  if (e.composedPath) {
    const path = e.composedPath();
    retarget(path[0]);
    for (let i = 0; i < path.length - 2; i++) {
      node = path[i];
      if (!handleNode()) break;
      if (node._$host) {
        node = node._$host;
        walkUpTree();
        break;
      }
      if (node.parentNode === oriCurrentTarget) {
        break;
      }
    }
  } else walkUpTree();
  retarget(oriTarget);
}
function insertExpression(parent, value, current, marker, unwrapArray) {
  const hydrating = isHydrating(parent);
  if (hydrating) {
    !current && (current = [...parent.childNodes]);
    let cleaned = [];
    for (let i = 0; i < current.length; i++) {
      const node = current[i];
      if (node.nodeType === 8 && node.data.slice(0, 2) === "!$") node.remove();
      else cleaned.push(node);
    }
    current = cleaned;
  }
  while (typeof current === "function") current = current();
  if (value === current) return current;
  const t = typeof value,
    multi = marker !== undefined;
  parent = (multi && current[0] && current[0].parentNode) || parent;
  if (t === "string" || t === "number") {
    if (hydrating) return current;
    if (t === "number") {
      value = value.toString();
      if (value === current) return current;
    }
    if (multi) {
      let node = current[0];
      if (node && node.nodeType === 3) {
        node.data !== value && (node.data = value);
      } else node = document.createTextNode(value);
      current = cleanChildren(parent, current, marker, node);
    } else {
      if (current !== "" && typeof current === "string") {
        current = parent.firstChild.data = value;
      } else current = parent.textContent = value;
    }
  } else if (value == null || t === "boolean") {
    if (hydrating) return current;
    current = cleanChildren(parent, current, marker);
  } else if (t === "function") {
    createRenderEffect(() => {
      let v = value();
      while (typeof v === "function") v = v();
      current = insertExpression(parent, v, current, marker);
    });
    return () => current;
  } else if (Array.isArray(value)) {
    const array = [];
    const currentArray = current && Array.isArray(current);
    if (normalizeIncomingArray(array, value, current, unwrapArray)) {
      createRenderEffect(() => (current = insertExpression(parent, array, current, marker, true)));
      return () => current;
    }
    if (hydrating) {
      if (!array.length) return current;
      if (marker === undefined) return (current = [...parent.childNodes]);
      let node = array[0];
      if (node.parentNode !== parent) return current;
      const nodes = [node];
      while ((node = node.nextSibling) !== marker) nodes.push(node);
      return (current = nodes);
    }
    if (array.length === 0) {
      current = cleanChildren(parent, current, marker);
      if (multi) return current;
    } else if (currentArray) {
      if (current.length === 0) {
        appendNodes(parent, array, marker);
      } else reconcileArrays(parent, current, array);
    } else {
      current && cleanChildren(parent);
      appendNodes(parent, array);
    }
    current = array;
  } else if (value.nodeType) {
    if (hydrating && value.parentNode) return (current = multi ? [value] : value);
    if (Array.isArray(current)) {
      if (multi) return (current = cleanChildren(parent, current, marker, value));
      cleanChildren(parent, current, null, value);
    } else if (current == null || current === "" || !parent.firstChild) {
      parent.appendChild(value);
    } else parent.replaceChild(value, parent.firstChild);
    current = value;
  } else;
  return current;
}
function normalizeIncomingArray(normalized, array, current, unwrap) {
  let dynamic = false;
  for (let i = 0, len = array.length; i < len; i++) {
    let item = array[i],
      prev = current && current[normalized.length],
      t;
    if (item == null || item === true || item === false);
    else if ((t = typeof item) === "object" && item.nodeType) {
      normalized.push(item);
    } else if (Array.isArray(item)) {
      dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;
    } else if (t === "function") {
      if (unwrap) {
        while (typeof item === "function") item = item();
        dynamic =
          normalizeIncomingArray(
            normalized,
            Array.isArray(item) ? item : [item],
            Array.isArray(prev) ? prev : [prev]
          ) || dynamic;
      } else {
        normalized.push(item);
        dynamic = true;
      }
    } else {
      const value = String(item);
      if (prev && prev.nodeType === 3 && prev.data === value) normalized.push(prev);
      else normalized.push(document.createTextNode(value));
    }
  }
  return dynamic;
}
function appendNodes(parent, array, marker = null) {
  for (let i = 0, len = array.length; i < len; i++) parent.insertBefore(array[i], marker);
}
function cleanChildren(parent, current, marker, replacement) {
  if (marker === undefined) return (parent.textContent = "");
  const node = replacement || document.createTextNode("");
  if (current.length) {
    let inserted = false;
    for (let i = current.length - 1; i >= 0; i--) {
      const el = current[i];
      if (node !== el) {
        const isParent = el.parentNode === parent;
        if (!inserted && !i)
          isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);
        else isParent && el.remove();
      } else inserted = true;
    }
  } else parent.insertBefore(node, marker);
  return [node];
}
function getHydrationKey() {
  return sharedConfig.getNextContextId();
}
const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
function createElement(tagName, isSVG = false) {
  return isSVG ? document.createElementNS(SVG_NAMESPACE, tagName) : document.createElement(tagName);
}
function Portal(props) {
  const { useShadow } = props,
    marker = document.createTextNode(""),
    mount = () => props.mount || document.body,
    owner = getOwner();
  let content;
  let hydrating = !!sharedConfig.context;
  createEffect(
    () => {
      if (hydrating) getOwner().user = hydrating = false;
      content || (content = runWithOwner(owner, () => createMemo(() => props.children)));
      const el = mount();
      if (el instanceof HTMLHeadElement) {
        const [clean, setClean] = createSignal(false);
        const cleanup = () => setClean(true);
        createRoot(dispose => insert(el, () => (!clean() ? content() : dispose()), null));
        onCleanup(cleanup);
      } else {
        const container = createElement(props.isSVG ? "g" : "div", props.isSVG),
          renderRoot =
            useShadow && container.attachShadow
              ? container.attachShadow({
                  mode: "open"
                })
              : container;
        Object.defineProperty(container, "_$host", {
          get() {
            return marker.parentNode;
          },
          configurable: true
        });
        insert(renderRoot, content);
        el.appendChild(container);
        props.ref && props.ref(container);
        onCleanup(() => el.removeChild(container));
      }
    },
    undefined,
    {
      render: !hydrating
    }
  );
  return marker;
}
function Dynamic(props) {
  const [p, others] = splitProps(props, ["component"]);
  const cached = createMemo(() => p.component);
  return createMemo(() => {
    const component = cached();
    switch (typeof component) {
      case "function":
        return untrack(() => component(others));
      case "string":
        const isSvg = SVGElements.has(component);
        const el = sharedConfig.context ? getNextElement() : createElement(component, isSvg);
        spread(el, others, isSvg);
        return el;
    }
  });
}

function chain(callbacks) {
  return (...args) => {
    for (const callback of callbacks)
      callback && callback(...args);
  };
}
var access$1 = (v) => typeof v === "function" && !v.length ? v() : v;
var asArray = (value) => Array.isArray(value) ? value : value ? [value] : [];
function accessWith(valueOrFn, ...args) {
  return typeof valueOrFn === "function" ? valueOrFn(...args) : valueOrFn;
}
var tryOnCleanup = onCleanup;

// src/eventListener.ts
function makeEventListener(target, type, handler, options) {
  target.addEventListener(type, handler, options);
  return tryOnCleanup(target.removeEventListener.bind(target, type, handler, options));
}
function createEventListener(targets, type, handler, options) {
  const attachListeners = () => {
    asArray(access$1(targets)).forEach((el) => {
      if (el)
        asArray(access$1(type)).forEach((type2) => makeEventListener(el, type2, handler, options));
    });
  };
  if (typeof targets === "function")
    createEffect(attachListeners);
  else
    createRenderEffect(attachListeners);
}

var extractCSSregex = /((?:--)?(?:\w+-?)+)\s*:\s*([^;]*)/g;
function stringStyleToObject(style) {
  const object = {};
  let match;
  while (match = extractCSSregex.exec(style)) {
    object[match[1]] = match[2];
  }
  return object;
}
function combineStyle(a, b) {
  if (typeof a === "string") {
    if (typeof b === "string")
      return `${a};${b}`;
    a = stringStyleToObject(a);
  } else if (typeof b === "string") {
    b = stringStyleToObject(b);
  }
  return { ...a, ...b };
}

// src/index.ts
function mergeRefs(...refs) {
  return chain(refs);
}

// src/array.ts
function addItemToArray(array, item, index = -1) {
  if (!(index in array)) {
    return [...array, item];
  }
  return [...array.slice(0, index), item, ...array.slice(index)];
}
function removeItemFromArray(array, item) {
  const updatedArray = [...array];
  const index = updatedArray.indexOf(item);
  if (index !== -1) {
    updatedArray.splice(index, 1);
  }
  return updatedArray;
}

// src/assertion.ts
function isNumber(value) {
  return typeof value === "number";
}
function isString(value) {
  return Object.prototype.toString.call(value) === "[object String]";
}
function isFunction(value) {
  return typeof value === "function";
}

// src/create-generate-id.ts
function createGenerateId(baseId) {
  return (suffix) => `${baseId()}-${suffix}`;
}

// src/dom.ts
function contains$1(parent, child) {
  if (!parent) {
    return false;
  }
  return parent === child || parent.contains(child);
}
function getActiveElement(node, activeDescendant = false) {
  const { activeElement } = getDocument(node);
  if (!activeElement?.nodeName) {
    return null;
  }
  if (isFrame(activeElement) && activeElement.contentDocument) {
    return getActiveElement(
      activeElement.contentDocument.body,
      activeDescendant
    );
  }
  if (activeDescendant) {
    const id = activeElement.getAttribute("aria-activedescendant");
    if (id) {
      const element = getDocument(activeElement).getElementById(id);
      if (element) {
        return element;
      }
    }
  }
  return activeElement;
}
function getWindow$1(node) {
  return getDocument(node).defaultView || window;
}
function getDocument(node) {
  return node ? node.ownerDocument || node : document;
}
function isFrame(element) {
  return element.tagName === "IFRAME";
}

// src/enums.ts
var EventKey = /* @__PURE__ */ ((EventKey2) => {
  EventKey2["Escape"] = "Escape";
  EventKey2["Enter"] = "Enter";
  EventKey2["Tab"] = "Tab";
  EventKey2["Space"] = " ";
  EventKey2["ArrowDown"] = "ArrowDown";
  EventKey2["ArrowLeft"] = "ArrowLeft";
  EventKey2["ArrowRight"] = "ArrowRight";
  EventKey2["ArrowUp"] = "ArrowUp";
  EventKey2["End"] = "End";
  EventKey2["Home"] = "Home";
  EventKey2["PageDown"] = "PageDown";
  EventKey2["PageUp"] = "PageUp";
  return EventKey2;
})(EventKey || {});
function testPlatform(re) {
  return typeof window !== "undefined" && window.navigator != null ? re.test(
    // @ts-ignore
    window.navigator.userAgentData?.platform || window.navigator.platform
  ) : false;
}
function isMac() {
  return testPlatform(/^Mac/i);
}
function isIPhone() {
  return testPlatform(/^iPhone/i);
}
function isIPad() {
  return testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  isMac() && navigator.maxTouchPoints > 1;
}
function isIOS() {
  return isIPhone() || isIPad();
}
function isAppleDevice() {
  return isMac() || isIOS();
}

// src/events.ts
function callHandler(event, handler) {
  if (handler) {
    if (isFunction(handler)) {
      handler(event);
    } else {
      handler[0](handler[1], event);
    }
  }
  return event?.defaultPrevented;
}
function composeEventHandlers(handlers) {
  return (event) => {
    for (const handler of handlers) {
      callHandler(event, handler);
    }
  };
}
function isCtrlKey(e) {
  if (isMac()) {
    return e.metaKey && !e.ctrlKey;
  }
  return e.ctrlKey && !e.metaKey;
}

// src/focus-without-scrolling.ts
function focusWithoutScrolling(element) {
  if (!element) {
    return;
  }
  if (supportsPreventScroll()) {
    element.focus({ preventScroll: true });
  } else {
    const scrollableElements = getScrollableElements(element);
    element.focus();
    restoreScrollPosition(scrollableElements);
  }
}
var supportsPreventScrollCached = null;
function supportsPreventScroll() {
  if (supportsPreventScrollCached == null) {
    supportsPreventScrollCached = false;
    try {
      const focusElem = document.createElement("div");
      focusElem.focus({
        get preventScroll() {
          supportsPreventScrollCached = true;
          return true;
        }
      });
    } catch (e) {
    }
  }
  return supportsPreventScrollCached;
}
function getScrollableElements(element) {
  let parent = element.parentNode;
  const scrollableElements = [];
  const rootScrollingElement = document.scrollingElement || document.documentElement;
  while (parent instanceof HTMLElement && parent !== rootScrollingElement) {
    if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) {
      scrollableElements.push({
        element: parent,
        scrollTop: parent.scrollTop,
        scrollLeft: parent.scrollLeft
      });
    }
    parent = parent.parentNode;
  }
  if (rootScrollingElement instanceof HTMLElement) {
    scrollableElements.push({
      element: rootScrollingElement,
      scrollTop: rootScrollingElement.scrollTop,
      scrollLeft: rootScrollingElement.scrollLeft
    });
  }
  return scrollableElements;
}
function restoreScrollPosition(scrollableElements) {
  for (const { element, scrollTop, scrollLeft } of scrollableElements) {
    element.scrollTop = scrollTop;
    element.scrollLeft = scrollLeft;
  }
}

// src/tabbable.ts
var focusableElements = [
  "input:not([type='hidden']):not([disabled])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  "button:not([disabled])",
  "a[href]",
  "area[href]",
  "[tabindex]",
  "iframe",
  "object",
  "embed",
  "audio[controls]",
  "video[controls]",
  "[contenteditable]:not([contenteditable='false'])"
];
var tabbableElements = [
  ...focusableElements,
  '[tabindex]:not([tabindex="-1"]):not([disabled])'
];
var FOCUSABLE_ELEMENT_SELECTOR = `${focusableElements.join(
  ":not([hidden]),"
)},[tabindex]:not([disabled]):not([hidden])`;
var TABBABLE_ELEMENT_SELECTOR = tabbableElements.join(
  ':not([hidden]):not([tabindex="-1"]),'
);
function getAllTabbableIn(container, includeContainer) {
  const elements = Array.from(
    container.querySelectorAll(FOCUSABLE_ELEMENT_SELECTOR)
  );
  const tabbableElements2 = elements.filter(isTabbable);
  if (includeContainer && isTabbable(container)) {
    tabbableElements2.unshift(container);
  }
  tabbableElements2.forEach((element, i) => {
    if (isFrame(element) && element.contentDocument) {
      const frameBody = element.contentDocument.body;
      const allFrameTabbable = getAllTabbableIn(frameBody, false);
      tabbableElements2.splice(i, 1, ...allFrameTabbable);
    }
  });
  return tabbableElements2;
}
function isTabbable(element) {
  return isFocusable(element) && !hasNegativeTabIndex(element);
}
function isFocusable(element) {
  return element.matches(FOCUSABLE_ELEMENT_SELECTOR) && isElementVisible(element);
}
function hasNegativeTabIndex(element) {
  const tabIndex = Number.parseInt(element.getAttribute("tabindex") || "0", 10);
  return tabIndex < 0;
}
function isElementVisible(element, childElement) {
  return element.nodeName !== "#comment" && isStyleVisible(element) && isAttributeVisible(element, childElement) && (!element.parentElement || isElementVisible(element.parentElement, element));
}
function isStyleVisible(element) {
  if (!(element instanceof HTMLElement) && !(element instanceof SVGElement)) {
    return false;
  }
  const { display, visibility } = element.style;
  let isVisible = display !== "none" && visibility !== "hidden" && visibility !== "collapse";
  if (isVisible) {
    if (!element.ownerDocument.defaultView) {
      return isVisible;
    }
    const { getComputedStyle } = element.ownerDocument.defaultView;
    const { display: computedDisplay, visibility: computedVisibility } = getComputedStyle(element);
    isVisible = computedDisplay !== "none" && computedVisibility !== "hidden" && computedVisibility !== "collapse";
  }
  return isVisible;
}
function isAttributeVisible(element, childElement) {
  return !element.hasAttribute("hidden") && (element.nodeName === "DETAILS" && childElement && childElement.nodeName !== "SUMMARY" ? element.hasAttribute("open") : true);
}
function getFocusableTreeWalker(root, opts, scope) {
  const selector = opts?.tabbable ? TABBABLE_ELEMENT_SELECTOR : FOCUSABLE_ELEMENT_SELECTOR;
  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
    acceptNode(node) {
      if (opts?.from?.contains(node)) {
        return NodeFilter.FILTER_REJECT;
      }
      if (node.matches(selector) && isElementVisible(node) && (!scope) && (!opts?.accept || opts.accept(node))) {
        return NodeFilter.FILTER_ACCEPT;
      }
      return NodeFilter.FILTER_SKIP;
    }
  });
  if (opts?.from) {
    walker.currentNode = opts.from;
  }
  return walker;
}

// src/get-scroll-parent.ts
function getScrollParent(node) {
  let parentNode = node;
  while (parentNode && !isScrollable(parentNode)) {
    parentNode = parentNode.parentElement;
  }
  return parentNode || document.scrollingElement || document.documentElement;
}
function isScrollable(node) {
  const style = window.getComputedStyle(node);
  return /(auto|scroll)/.test(
    style.overflow + style.overflowX + style.overflowY
  );
}

// src/noop.ts
function noop() {
  return;
}
function isPointInPolygon(point, polygon) {
  const [x, y] = point;
  let inside = false;
  const length = polygon.length;
  for (let l = length, i = 0, j = l - 1; i < l; j = i++) {
    const [xi, yi] = polygon[i];
    const [xj, yj] = polygon[j];
    const [, vy] = polygon[j === 0 ? l - 1 : j - 1] || [0, 0];
    const where = (yi - yj) * (x - xi) - (xi - xj) * (y - yi);
    if (yj < yi) {
      if (y >= yj && y < yi) {
        if (where === 0)
          return true;
        if (where > 0) {
          if (y === yj) {
            if (y > vy) {
              inside = !inside;
            }
          } else {
            inside = !inside;
          }
        }
      }
    } else if (yi < yj) {
      if (y > yi && y <= yj) {
        if (where === 0)
          return true;
        if (where < 0) {
          if (y === yj) {
            if (y < vy) {
              inside = !inside;
            }
          } else {
            inside = !inside;
          }
        }
      }
    } else if (y === yi && (x >= xj && x <= xi || x >= xi && x <= xj)) {
      return true;
    }
  }
  return inside;
}
function mergeDefaultProps(defaultProps, props) {
  return mergeProps(defaultProps, props);
}

// src/run-after-transition.ts
var transitionsByElement = /* @__PURE__ */ new Map();
var transitionCallbacks = /* @__PURE__ */ new Set();
function setupGlobalEvents() {
  if (typeof window === "undefined") {
    return;
  }
  const onTransitionStart = (e) => {
    if (!e.target) {
      return;
    }
    let transitions = transitionsByElement.get(e.target);
    if (!transitions) {
      transitions = /* @__PURE__ */ new Set();
      transitionsByElement.set(e.target, transitions);
      e.target.addEventListener(
        "transitioncancel",
        onTransitionEnd
      );
    }
    transitions.add(e.propertyName);
  };
  const onTransitionEnd = (e) => {
    if (!e.target) {
      return;
    }
    const properties = transitionsByElement.get(e.target);
    if (!properties) {
      return;
    }
    properties.delete(e.propertyName);
    if (properties.size === 0) {
      e.target.removeEventListener(
        "transitioncancel",
        onTransitionEnd
      );
      transitionsByElement.delete(e.target);
    }
    if (transitionsByElement.size === 0) {
      for (const cb of transitionCallbacks) {
        cb();
      }
      transitionCallbacks.clear();
    }
  };
  document.body.addEventListener("transitionrun", onTransitionStart);
  document.body.addEventListener("transitionend", onTransitionEnd);
}
if (typeof document !== "undefined") {
  if (document.readyState !== "loading") {
    setupGlobalEvents();
  } else {
    document.addEventListener("DOMContentLoaded", setupGlobalEvents);
  }
}

// src/scroll-into-view.ts
function scrollIntoView(scrollView, element) {
  const offsetX = relativeOffset(scrollView, element, "left");
  const offsetY = relativeOffset(scrollView, element, "top");
  const width = element.offsetWidth;
  const height = element.offsetHeight;
  let x = scrollView.scrollLeft;
  let y = scrollView.scrollTop;
  const maxX = x + scrollView.offsetWidth;
  const maxY = y + scrollView.offsetHeight;
  if (offsetX <= x) {
    x = offsetX;
  } else if (offsetX + width > maxX) {
    x += offsetX + width - maxX;
  }
  if (offsetY <= y) {
    y = offsetY;
  } else if (offsetY + height > maxY) {
    y += offsetY + height - maxY;
  }
  scrollView.scrollLeft = x;
  scrollView.scrollTop = y;
}
function relativeOffset(ancestor, child, axis) {
  const prop = axis === "left" ? "offsetLeft" : "offsetTop";
  let sum = 0;
  while (child.offsetParent) {
    sum += child[prop];
    if (child.offsetParent === ancestor) {
      break;
    }
    if (child.offsetParent.contains(ancestor)) {
      sum -= ancestor[prop];
      break;
    }
    child = child.offsetParent;
  }
  return sum;
}
function scrollIntoViewport(targetElement, opts) {
  if (document.contains(targetElement)) {
    const root = document.scrollingElement || document.documentElement;
    const isScrollPrevented = window.getComputedStyle(root).overflow === "hidden";
    if (!isScrollPrevented) {
      const { left: originalLeft, top: originalTop } = targetElement.getBoundingClientRect();
      targetElement?.scrollIntoView?.({ block: "nearest" });
      const { left: newLeft, top: newTop } = targetElement.getBoundingClientRect();
      if (Math.abs(originalLeft - newLeft) > 1 || Math.abs(originalTop - newTop) > 1) {
        targetElement.scrollIntoView?.({ block: "nearest" });
      }
    } else {
      let scrollParent = getScrollParent(targetElement);
      while (targetElement && scrollParent && targetElement !== root && scrollParent !== root) {
        scrollIntoView(
          scrollParent,
          targetElement
        );
        targetElement = scrollParent;
        scrollParent = getScrollParent(targetElement);
      }
    }
  }
}

// src/styles.ts
var visuallyHiddenStyles = {
  border: "0",
  clip: "rect(0 0 0 0)",
  "clip-path": "inset(50%)",
  height: "1px",
  margin: "0 -1px -1px 0",
  overflow: "hidden",
  padding: "0",
  position: "absolute",
  width: "1px",
  "white-space": "nowrap"
};

var RTL_SCRIPTS = /* @__PURE__ */ new Set(["Avst", "Arab", "Armi", "Syrc", "Samr", "Mand", "Thaa", "Mend", "Nkoo", "Adlm", "Rohg", "Hebr"]);
var RTL_LANGS = /* @__PURE__ */ new Set(["ae", "ar", "arc", "bcc", "bqi", "ckb", "dv", "fa", "glk", "he", "ku", "mzn", "nqo", "pnb", "ps", "sd", "ug", "ur", "yi"]);
function isRTL$1(locale) {
  if (Intl.Locale) {
    const script = new Intl.Locale(locale).maximize().script ?? "";
    return RTL_SCRIPTS.has(script);
  }
  const lang = locale.split("-")[0];
  return RTL_LANGS.has(lang);
}
function getReadingDirection(locale) {
  return isRTL$1(locale) ? "rtl" : "ltr";
}
function getDefaultLocale() {
  let locale = typeof navigator !== "undefined" && // @ts-ignore
  (navigator.language || navigator.userLanguage) || "en-US";
  try {
    Intl.DateTimeFormat.supportedLocalesOf([locale]);
  } catch (_err) {
    locale = "en-US";
  }
  return {
    locale,
    direction: getReadingDirection(locale)
  };
}
var currentLocale = getDefaultLocale();
var listeners = /* @__PURE__ */ new Set();
function updateLocale() {
  currentLocale = getDefaultLocale();
  for (const listener of listeners) {
    listener(currentLocale);
  }
}
function createDefaultLocale() {
  const [defaultClientLocale, setDefaultClientLocale] = createSignal(currentLocale);
  const defaultLocale = createMemo(() => defaultClientLocale());
  onMount(() => {
    if (listeners.size === 0) {
      window.addEventListener("languagechange", updateLocale);
    }
    listeners.add(setDefaultClientLocale);
    onCleanup(() => {
      listeners.delete(setDefaultClientLocale);
      if (listeners.size === 0) {
        window.removeEventListener("languagechange", updateLocale);
      }
    });
  });
  return {
    locale: () => defaultLocale().locale,
    direction: () => defaultLocale().direction
  };
}
var I18nContext = createContext();
function useLocale() {
  const defaultLocale = createDefaultLocale();
  const context = useContext(I18nContext);
  return context || defaultLocale;
}
var cache$1 = /* @__PURE__ */ new Map();
function createCollator(options) {
  const {
    locale
  } = useLocale();
  const cacheKey = createMemo(() => {
    return locale() + (Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() );
  });
  return createMemo(() => {
    const key = cacheKey();
    let collator;
    if (cache$1.has(key)) {
      collator = cache$1.get(key);
    }
    if (!collator) {
      collator = new Intl.Collator(locale(), options);
      cache$1.set(key, collator);
    }
    return collator;
  });
}

function Polymorphic(props) {
  const [local, others] = splitProps(props, ["as"]);
  if (!local.as) {
    throw new Error("[kobalte]: Polymorphic is missing the required `as` prop.");
  }
  return (
    // @ts-ignore: Props are valid but not worth calculating
    createComponent(Dynamic, mergeProps(others, {
      get component() {
        return local.as;
      }
    }))
  );
}

/**
 * Custom positioning reference element.
 * @see https://floating-ui.com/docs/virtual-elements
 */

const sides = ['top', 'right', 'bottom', 'left'];
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = v => ({
  x: v,
  y: v
});
const oppositeSideMap = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
const oppositeAlignmentMap = {
  start: 'end',
  end: 'start'
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === 'function' ? value(param) : value;
}
function getSide(placement) {
  return placement.split('-')[0];
}
function getAlignment(placement) {
  return placement.split('-')[1];
}
function getOppositeAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}
function getAxisLength(axis) {
  return axis === 'y' ? 'height' : 'width';
}
function getSideAxis(placement) {
  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ['left', 'right'];
  const rl = ['right', 'left'];
  const tb = ['top', 'bottom'];
  const bt = ['bottom', 'top'];
  switch (side) {
    case 'top':
    case 'bottom':
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case 'left':
    case 'right':
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === 'start', rtl);
  if (alignment) {
    list = list.map(side => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== 'number' ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === 'y';
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case 'top':
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case 'bottom':
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case 'right':
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case 'left':
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case 'start':
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case 'end':
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a given reference element.
 *
 * This export does not have any `platform` interface logic. You will need to
 * write one for the platform you are using Floating UI with.
 */
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = 'bottom',
    strategy = 'absolute',
    middleware = [],
    platform
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
  let rects = await platform.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === 'object') {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};

/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary on each side.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = 'clippingAncestors',
    rootBoundary = 'viewport',
    elementContext = 'floating',
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === 'floating' ? 'reference' : 'floating';
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform.getClippingRect({
    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === 'floating' ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));
  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}

/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */
const arrow$1 = options => ({
  name: 'arrow',
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform,
      elements,
      middlewareData
    } = state;
    // Since `element` is required, we don't Partial<> the type.
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform.getDimensions(element);
    const isYAxis = axis === 'y';
    const minProp = isYAxis ? 'top' : 'left';
    const maxProp = isYAxis ? 'bottom' : 'right';
    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;

    // DOM platform can return `window` as the `offsetParent`.
    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;

    // If the padding is large enough that it causes the arrow to no longer be
    // centered, modify the padding so that it is centered.
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);

    // Make sure the arrow doesn't overflow the floating element if the center
    // point is outside the floating element's bounds.
    const min$1 = minPadding;
    const max = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset = clamp(min$1, center, max);

    // If the reference is small enough that the arrow's padding causes it to
    // to point to nothing for an aligned placement, adjust the offset of the
    // floating element itself. To ensure `shift()` continues to take action,
    // a single reset is performed when this is true.
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset,
        centerOffset: center - offset - alignmentOffset,
        ...(shouldAddOffset && {
          alignmentOffset
        })
      },
      reset: shouldAddOffset
    };
  }
});

/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */
const flip$1 = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'flip',
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = 'bestFit',
        fallbackAxisSideDirection = 'none',
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);

      // If a reset by the arrow was caused due to an alignment offset being
      // added, we should skip any logic now since `flip()` has already done its
      // work.
      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides[0]], overflow[sides[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];

      // One or more sides is overflowing.
      if (!overflows.every(side => side <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          // Try next placement and re-run the lifecycle.
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }

        // First, find the candidates that fit on the mainAxis side of overflow,
        // then find the placement that fits the best on the main crossAxis side.
        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;

        // Otherwise fallback.
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case 'bestFit':
              {
                var _overflowsData$filter2;
                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {
                  if (hasFallbackAxisSideDirection) {
                    const currentSideAxis = getSideAxis(d.placement);
                    return currentSideAxis === initialSideAxis ||
                    // Create a bias to the `y` side axis due to horizontal
                    // reading directions favoring greater width.
                    currentSideAxis === 'y';
                  }
                  return true;
                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                if (placement) {
                  resetPlacement = placement;
                }
                break;
              }
            case 'initialPlacement':
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};

function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some(side => overflow[side] >= 0);
}
/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */
const hide$1 = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'hide',
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = 'referenceHidden',
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case 'referenceHidden':
          {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              elementContext: 'reference'
            });
            const offsets = getSideOffsets(overflow, rects.reference);
            return {
              data: {
                referenceHiddenOffsets: offsets,
                referenceHidden: isAnySideFullyClipped(offsets)
              }
            };
          }
        case 'escaped':
          {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              altBoundary: true
            });
            const offsets = getSideOffsets(overflow, rects.floating);
            return {
              data: {
                escapedOffsets: offsets,
                escaped: isAnySideFullyClipped(offsets)
              }
            };
          }
        default:
          {
            return {};
          }
      }
    }
  };
};

// For type backwards-compatibility, the `OffsetOptions` type was also
// Derivable.

async function convertValueToCoords(state, options) {
  const {
    placement,
    platform,
    elements
  } = state;
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === 'y';
  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);

  // eslint-disable-next-line prefer-const
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === 'number' ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === 'number') {
    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}

/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */
const offset$1 = function (options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: 'offset',
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);

      // If the placement is the same and the arrow caused an alignment offset
      // then we don't need to change the positioning coordinates.
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};

/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */
const shift$1 = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'shift',
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: _ref => {
            let {
              x,
              y
            } = _ref;
            return {
              x,
              y
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === 'y' ? 'top' : 'left';
        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';
        const min = mainAxisCoord + overflow[minSide];
        const max = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min, mainAxisCoord, max);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === 'y' ? 'top' : 'left';
        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';
        const min = crossAxisCoord + overflow[minSide];
        const max = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min, crossAxisCoord, max);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};

/**
 * Provides data that allows you to change the size of the floating element 
 * for instance, prevent it from overflowing the clipping boundary or match the
 * width of the reference element.
 * @see https://floating-ui.com/docs/size
 */
const size$1 = function (options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: 'size',
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform,
        elements
      } = state;
      const {
        apply = () => {},
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === 'y';
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === 'top' || side === 'bottom') {
        heightSide = side;
        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';
      } else {
        widthSide = side;
        heightSide = alignment === 'end' ? 'top' : 'bottom';
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

function hasWindow() {
  return typeof window !== 'undefined';
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || '').toLowerCase();
  }
  // Mocked nodes in testing environments may not be instances of Node. By
  // returning `#document` an infinite loop won't occur.
  // https://github.com/floating-ui/floating-ui/issues/2317
  return '#document';
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === 'undefined') {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);
}
function isTableElement(element) {
  return ['table', 'td', 'th'].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [':popover-open', ':modal'].some(selector => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;

  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === 'undefined' || !CSS.supports) return false;
  return CSS.supports('-webkit-backdrop-filter', 'none');
}
function isLastTraversableNode(node) {
  return ['html', 'body', '#document'].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === 'html') {
    return node;
  }
  const result =
  // Step into the shadow DOM of the parent of a slotted node.
  node.assignedSlot ||
  // DOM Element detected.
  node.parentNode ||
  // ShadowRoot detected.
  isShadowRoot(node) && node.host ||
  // Fallback.
  getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  // In testing environments, the `width` and `height` properties are empty
  // strings for SVG elements, returning NaN. Fallback to `0` in this case.
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}

function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}

function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;

  // 0, NaN, or Infinity should always fallback to 1.

  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}

const noOffsets = /*#__PURE__*/createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}

function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}

// If <html> has a CSS width greater than the viewport, then this will be
// incorrect for RTL.
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}

function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 :
  // RTL <body> scrollbar.
  getWindowScrollBarX(documentElement, htmlRect));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}

function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === 'fixed';
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}

function getClientRects(element) {
  return Array.from(element.getClientRects());
}

// Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable.
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === 'rtl') {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}

// Returns the inner client rect, subtracting scrollbars if present.
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === 'viewport') {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === 'document') {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);
}

// A "clipping ancestor" is an `overflow` element with the characteristic of
// clipping (or hiding) child elements. This returns all clipping ancestors
// of the given element up the tree.
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === 'fixed';
  let currentNode = elementIsFixed ? getParentNode(element) : element;

  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      // Drop non-containing blocks.
      result = result.filter(ancestor => ancestor !== currentNode);
    } else {
      // Record last containing block for next iteration.
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}

// Gets the maximum area that the element is visible in due to any number of
// clipping ancestors.
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}

function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}

function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === 'fixed';
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      // If the <body> scrollbar appears on the left (e.g. RTL systems). Use
      // Firefox with layout.scrollbar.side = 3 in about:config to test this.
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}

function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === 'static';
}

function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;

  // Firefox returns the <html> element as the offsetParent if it's non-static,
  // while Chrome and Safari return the <body> element. The <body> element must
  // be used to perform the correct calculations even if the <html> element is
  // non-static.
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}

// Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}

const getElementRects = async function (data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};

function isRTL(element) {
  return getComputedStyle$1(element).direction === 'rtl';
}

const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};

// https://samthor.au/2021/observing-dom/
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          // If the reference is clipped, the ratio is 0. Throttle the refresh
          // to prevent an infinite loop of updates.
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1000);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }

    // Older browsers don't support a `document` as the root and will throw an
    // error.
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}

/**
 * Automatically updates the position of the floating element when necessary.
 * Should only be called when the floating element is mounted on the DOM or
 * visible on the screen.
 * @returns cleanup function that should be invoked when the floating element is
 * removed from the DOM or hidden from the screen.
 * @see https://floating-ui.com/docs/autoUpdate
 */
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === 'function',
    layoutShift = typeof IntersectionObserver === 'function',
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];
  ancestors.forEach(ancestor => {
    ancestorScroll && ancestor.addEventListener('scroll', update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener('resize', update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver(_ref => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        // Prevent update loops when using the `size` middleware.
        // https://github.com/floating-ui/floating-ui/issues/1740
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach(ancestor => {
      ancestorScroll && ancestor.removeEventListener('scroll', update);
      ancestorResize && ancestor.removeEventListener('resize', update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}

/**
 * Modifies the placement by translating the floating element along the
 * specified axes.
 * A number (shorthand for `mainAxis` or distance), or an axes configuration
 * object may be passed.
 * @see https://floating-ui.com/docs/offset
 */
const offset = offset$1;

/**
 * Optimizes the visibility of the floating element by shifting it in order to
 * keep it in view when it will overflow the clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */
const shift = shift$1;

/**
 * Optimizes the visibility of the floating element by flipping the `placement`
 * in order to keep it in view when the preferred placement(s) will overflow the
 * clipping boundary. Alternative to `autoPlacement`.
 * @see https://floating-ui.com/docs/flip
 */
const flip = flip$1;

/**
 * Provides data that allows you to change the size of the floating element 
 * for instance, prevent it from overflowing the clipping boundary or match the
 * width of the reference element.
 * @see https://floating-ui.com/docs/size
 */
const size = size$1;

/**
 * Provides data to hide the floating element in applicable situations, such as
 * when it is not in the same clipping context as the reference element.
 * @see https://floating-ui.com/docs/hide
 */
const hide = hide$1;

/**
 * Provides data to position an inner element of the floating element so that it
 * appears centered to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */
const arrow = arrow$1;

/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a given reference element.
 */
const computePosition = (reference, floating, options) => {
  // This caches the expensive `getClippingElementAncestors` function so that
  // multiple lifecycle resets re-use the same result. It only lives for a
  // single call. If other functions become expensive, we can add them as well.
  const cache = new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

var _tmpl$$j = /* @__PURE__ */ template(`<svg display=block viewBox="0 0 30 30"style=transform:scale(1.02)><g><path fill=none d=M23,27.8c1.1,1.2,3.4,2.2,5,2.2h2H0h2c1.7,0,3.9-1,5-2.2l6.6-7.2c0.7-0.8,2-0.8,2.7,0L23,27.8L23,27.8z></path><path stroke=none d=M23,27.8c1.1,1.2,3.4,2.2,5,2.2h2H0h2c1.7,0,3.9-1,5-2.2l6.6-7.2c0.7-0.8,2-0.8,2.7,0L23,27.8L23,27.8z>`);
var PopperContext = createContext();
function usePopperContext() {
  const context = useContext(PopperContext);
  if (context === void 0) {
    throw new Error("[kobalte]: `usePopperContext` must be used within a `Popper` component");
  }
  return context;
}
var DEFAULT_SIZE = 30;
var HALF_DEFAULT_SIZE = DEFAULT_SIZE / 2;
var ROTATION_DEG = {
  top: 180,
  right: -90,
  bottom: 0,
  left: 90
};
function PopperArrow(props) {
  const context = usePopperContext();
  const mergedProps = mergeDefaultProps({
    size: DEFAULT_SIZE
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "style", "size"]);
  const dir = () => context.currentPlacement().split("-")[0];
  const contentStyle = createComputedStyle(context.contentRef);
  const fill = () => contentStyle()?.getPropertyValue("background-color") || "none";
  const stroke = () => contentStyle()?.getPropertyValue(`border-${dir()}-color`) || "none";
  const borderWidth = () => contentStyle()?.getPropertyValue(`border-${dir()}-width`) || "0px";
  const strokeWidth = () => {
    return Number.parseInt(borderWidth()) * 2 * (DEFAULT_SIZE / local.size);
  };
  const rotate = () => {
    return `rotate(${ROTATION_DEG[dir()]} ${HALF_DEFAULT_SIZE} ${HALF_DEFAULT_SIZE}) translate(0 2)`;
  };
  return createComponent(Polymorphic, mergeProps({
    as: "div",
    ref(r$) {
      var _ref$ = mergeRefs(context.setArrowRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    "aria-hidden": "true",
    get style() {
      return combineStyle({
        // server side rendering
        position: "absolute",
        "font-size": `${local.size}px`,
        width: "1em",
        height: "1em",
        "pointer-events": "none",
        fill: fill(),
        stroke: stroke(),
        "stroke-width": strokeWidth()
      }, local.style);
    }
  }, others, {
    get children() {
      var _el$ = _tmpl$$j(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild; _el$3.nextSibling;
      createRenderEffect(() => setAttribute(_el$2, "transform", rotate()));
      return _el$;
    }
  }));
}
function createComputedStyle(element) {
  const [style, setStyle] = createSignal();
  createEffect(() => {
    const el = element();
    el && setStyle(getWindow$1(el).getComputedStyle(el));
  });
  return style;
}
function PopperPositioner(props) {
  const context = usePopperContext();
  const [local, others] = splitProps(props, ["ref", "style"]);
  return createComponent(Polymorphic, mergeProps({
    as: "div",
    ref(r$) {
      var _ref$2 = mergeRefs(context.setPositionerRef, local.ref);
      typeof _ref$2 === "function" && _ref$2(r$);
    },
    "data-popper-positioner": "",
    get style() {
      return combineStyle({
        position: "absolute",
        top: 0,
        left: 0,
        "min-width": "max-content"
      }, local.style);
    }
  }, others));
}
function createDOMRect(anchorRect) {
  const {
    x = 0,
    y = 0,
    width = 0,
    height = 0
  } = anchorRect ?? {};
  if (typeof DOMRect === "function") {
    return new DOMRect(x, y, width, height);
  }
  const rect = {
    x,
    y,
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x
  };
  return {
    ...rect,
    toJSON: () => rect
  };
}
function getAnchorElement(anchor, getAnchorRect) {
  const contextElement = anchor;
  return {
    contextElement,
    getBoundingClientRect: () => {
      const anchorRect = getAnchorRect(anchor);
      if (anchorRect) {
        return createDOMRect(anchorRect);
      }
      if (anchor) {
        return anchor.getBoundingClientRect();
      }
      return createDOMRect();
    }
  };
}
function isValidPlacement(flip2) {
  return /^(?:top|bottom|left|right)(?:-(?:start|end))?$/.test(flip2);
}
var REVERSE_BASE_PLACEMENT = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
function getTransformOrigin(placement, readingDirection) {
  const [basePlacement, alignment] = placement.split("-");
  const reversePlacement = REVERSE_BASE_PLACEMENT[basePlacement];
  if (!alignment) {
    return `${reversePlacement} center`;
  }
  if (basePlacement === "left" || basePlacement === "right") {
    return `${reversePlacement} ${alignment === "start" ? "top" : "bottom"}`;
  }
  if (alignment === "start") {
    return `${reversePlacement} ${readingDirection === "rtl" ? "right" : "left"}`;
  }
  return `${reversePlacement} ${readingDirection === "rtl" ? "left" : "right"}`;
}
function PopperRoot(props) {
  const mergedProps = mergeDefaultProps({
    getAnchorRect: (anchor) => anchor?.getBoundingClientRect(),
    placement: "bottom",
    gutter: 0,
    shift: 0,
    flip: true,
    slide: true,
    overlap: false,
    sameWidth: false,
    fitViewport: false,
    hideWhenDetached: false,
    detachedPadding: 0,
    arrowPadding: 4,
    overflowPadding: 8
  }, props);
  const [positionerRef, setPositionerRef] = createSignal();
  const [arrowRef, setArrowRef] = createSignal();
  const [currentPlacement, setCurrentPlacement] = createSignal(mergedProps.placement);
  const anchorRef = () => getAnchorElement(mergedProps.anchorRef?.(), mergedProps.getAnchorRect);
  const {
    direction
  } = useLocale();
  async function updatePosition() {
    const referenceEl = anchorRef();
    const floatingEl = positionerRef();
    const arrowEl = arrowRef();
    if (!referenceEl || !floatingEl) {
      return;
    }
    const arrowOffset = (arrowEl?.clientHeight || 0) / 2;
    const finalGutter = typeof mergedProps.gutter === "number" ? mergedProps.gutter + arrowOffset : mergedProps.gutter ?? arrowOffset;
    floatingEl.style.setProperty("--kb-popper-content-overflow-padding", `${mergedProps.overflowPadding}px`);
    referenceEl.getBoundingClientRect();
    const middleware = [
      // https://floating-ui.com/docs/offset
      offset(({
        placement
      }) => {
        const hasAlignment = !!placement.split("-")[1];
        return {
          mainAxis: finalGutter,
          crossAxis: !hasAlignment ? mergedProps.shift : void 0,
          alignmentAxis: mergedProps.shift
        };
      })
    ];
    if (mergedProps.flip !== false) {
      const fallbackPlacements = typeof mergedProps.flip === "string" ? mergedProps.flip.split(" ") : void 0;
      if (fallbackPlacements !== void 0 && !fallbackPlacements.every(isValidPlacement)) {
        throw new Error("`flip` expects a spaced-delimited list of placements");
      }
      middleware.push(flip({
        padding: mergedProps.overflowPadding,
        fallbackPlacements
      }));
    }
    if (mergedProps.slide || mergedProps.overlap) {
      middleware.push(shift({
        mainAxis: mergedProps.slide,
        crossAxis: mergedProps.overlap,
        padding: mergedProps.overflowPadding
      }));
    }
    middleware.push(size({
      padding: mergedProps.overflowPadding,
      apply({
        availableWidth,
        availableHeight,
        rects
      }) {
        const referenceWidth = Math.round(rects.reference.width);
        availableWidth = Math.floor(availableWidth);
        availableHeight = Math.floor(availableHeight);
        floatingEl.style.setProperty("--kb-popper-anchor-width", `${referenceWidth}px`);
        floatingEl.style.setProperty("--kb-popper-content-available-width", `${availableWidth}px`);
        floatingEl.style.setProperty("--kb-popper-content-available-height", `${availableHeight}px`);
        if (mergedProps.sameWidth) {
          floatingEl.style.width = `${referenceWidth}px`;
        }
        if (mergedProps.fitViewport) {
          floatingEl.style.maxWidth = `${availableWidth}px`;
          floatingEl.style.maxHeight = `${availableHeight}px`;
        }
      }
    }));
    if (mergedProps.hideWhenDetached) {
      middleware.push(hide({
        padding: mergedProps.detachedPadding
      }));
    }
    if (arrowEl) {
      middleware.push(arrow({
        element: arrowEl,
        padding: mergedProps.arrowPadding
      }));
    }
    const pos = await computePosition(referenceEl, floatingEl, {
      placement: mergedProps.placement,
      strategy: "absolute",
      middleware,
      platform: {
        ...platform,
        isRTL: () => direction() === "rtl"
      }
    });
    setCurrentPlacement(pos.placement);
    mergedProps.onCurrentPlacementChange?.(pos.placement);
    if (!floatingEl) {
      return;
    }
    floatingEl.style.setProperty("--kb-popper-content-transform-origin", getTransformOrigin(pos.placement, direction()));
    const x = Math.round(pos.x);
    const y = Math.round(pos.y);
    let visibility;
    if (mergedProps.hideWhenDetached) {
      visibility = pos.middlewareData.hide?.referenceHidden ? "hidden" : "visible";
    }
    Object.assign(floatingEl.style, {
      top: "0",
      left: "0",
      transform: `translate3d(${x}px, ${y}px, 0)`,
      visibility
    });
    if (arrowEl && pos.middlewareData.arrow) {
      const {
        x: arrowX,
        y: arrowY
      } = pos.middlewareData.arrow;
      const dir = pos.placement.split("-")[0];
      Object.assign(arrowEl.style, {
        left: arrowX != null ? `${arrowX}px` : "",
        top: arrowY != null ? `${arrowY}px` : "",
        [dir]: "100%"
      });
    }
  }
  createEffect(() => {
    const referenceEl = anchorRef();
    const floatingEl = positionerRef();
    if (!referenceEl || !floatingEl) {
      return;
    }
    const cleanupAutoUpdate = autoUpdate(referenceEl, floatingEl, updatePosition, {
      // JSDOM doesn't support ResizeObserver
      elementResize: typeof ResizeObserver === "function"
    });
    onCleanup(cleanupAutoUpdate);
  });
  createEffect(() => {
    const positioner = positionerRef();
    const content = mergedProps.contentRef?.();
    if (!positioner || !content) {
      return;
    }
    queueMicrotask(() => {
      positioner.style.zIndex = getComputedStyle(content).zIndex;
    });
  });
  const context = {
    currentPlacement,
    contentRef: () => mergedProps.contentRef?.(),
    setPositionerRef,
    setArrowRef
  };
  return createComponent(PopperContext.Provider, {
    value: context,
    get children() {
      return mergedProps.children;
    }
  });
}
var Popper = Object.assign(PopperRoot, {
  Arrow: PopperArrow,
  Context: PopperContext,
  usePopperContext,
  Positioner: PopperPositioner
});

function createControllableSignal(props) {
  const [_value, _setValue] = createSignal(props.defaultValue?.());
  const isControlled = createMemo(() => props.value?.() !== void 0);
  const value = createMemo(() => isControlled() ? props.value?.() : _value());
  const setValue = (next) => {
    untrack(() => {
      const nextValue = accessWith(next, value());
      if (!Object.is(nextValue, value())) {
        if (!isControlled()) {
          _setValue(nextValue);
        }
        props.onChange?.(nextValue);
      }
      return nextValue;
    });
  };
  return [value, setValue];
}
function createControllableBooleanSignal(props) {
  const [_value, setValue] = createControllableSignal(props);
  const value = () => _value() ?? false;
  return [value, setValue];
}
function createControllableArraySignal(props) {
  const [_value, setValue] = createControllableSignal(props);
  const value = () => _value() ?? [];
  return [value, setValue];
}

var DomCollectionContext = createContext();
function useOptionalDomCollectionContext() {
  return useContext(DomCollectionContext);
}
function useDomCollectionContext() {
  const context = useOptionalDomCollectionContext();
  if (context === void 0) {
    throw new Error("[kobalte]: `useDomCollectionContext` must be used within a `DomCollectionProvider` component");
  }
  return context;
}
function isElementPreceding(a, b) {
  return Boolean(b.compareDocumentPosition(a) & Node.DOCUMENT_POSITION_PRECEDING);
}
function findDOMIndex(items, item) {
  const itemEl = item.ref();
  if (!itemEl) {
    return -1;
  }
  let length = items.length;
  if (!length) {
    return -1;
  }
  while (length--) {
    const currentItemEl = items[length]?.ref();
    if (!currentItemEl) {
      continue;
    }
    if (isElementPreceding(currentItemEl, itemEl)) {
      return length + 1;
    }
  }
  return 0;
}
function sortBasedOnDOMPosition(items) {
  const pairs = items.map((item, index) => [index, item]);
  let isOrderDifferent = false;
  pairs.sort(([indexA, a], [indexB, b]) => {
    const elementA = a.ref();
    const elementB = b.ref();
    if (elementA === elementB) {
      return 0;
    }
    if (!elementA || !elementB) {
      return 0;
    }
    if (isElementPreceding(elementA, elementB)) {
      if (indexA > indexB) {
        isOrderDifferent = true;
      }
      return -1;
    }
    if (indexA < indexB) {
      isOrderDifferent = true;
    }
    return 1;
  });
  if (isOrderDifferent) {
    return pairs.map(([_, item]) => item);
  }
  return items;
}
function setItemsBasedOnDOMPosition(items, setItems) {
  const sortedItems = sortBasedOnDOMPosition(items);
  if (items !== sortedItems) {
    setItems(sortedItems);
  }
}
function getCommonParent(items) {
  const firstItem = items[0];
  const lastItemEl = items[items.length - 1]?.ref();
  let parentEl = firstItem?.ref()?.parentElement;
  while (parentEl) {
    if (lastItemEl && parentEl.contains(lastItemEl)) {
      return parentEl;
    }
    parentEl = parentEl.parentElement;
  }
  return getDocument(parentEl).body;
}
function createTimeoutObserver(items, setItems) {
  createEffect(() => {
    const timeout = setTimeout(() => {
      setItemsBasedOnDOMPosition(items(), setItems);
    });
    onCleanup(() => clearTimeout(timeout));
  });
}
function createSortBasedOnDOMPosition(items, setItems) {
  if (typeof IntersectionObserver !== "function") {
    createTimeoutObserver(items, setItems);
    return;
  }
  let previousItems = [];
  createEffect(() => {
    const callback = () => {
      const hasPreviousItems = !!previousItems.length;
      previousItems = items();
      if (!hasPreviousItems) {
        return;
      }
      setItemsBasedOnDOMPosition(items(), setItems);
    };
    const root = getCommonParent(items());
    const observer = new IntersectionObserver(callback, {
      root
    });
    for (const item of items()) {
      const itemEl = item.ref();
      if (itemEl) {
        observer.observe(itemEl);
      }
    }
    onCleanup(() => observer.disconnect());
  });
}
function createDomCollection(props = {}) {
  const [items, setItems] = createControllableArraySignal({
    value: () => access$1(props.items),
    onChange: (value) => props.onItemsChange?.(value)
  });
  createSortBasedOnDOMPosition(items, setItems);
  const registerItem = (item) => {
    setItems((prevItems) => {
      const index = findDOMIndex(prevItems, item);
      return addItemToArray(prevItems, item, index);
    });
    return () => {
      setItems((prevItems) => {
        const nextItems = prevItems.filter((prevItem) => prevItem.ref() !== item.ref());
        if (prevItems.length === nextItems.length) {
          return prevItems;
        }
        return nextItems;
      });
    };
  };
  const DomCollectionProvider = (props2) => {
    return createComponent(DomCollectionContext.Provider, {
      value: {
        registerItem
      },
      get children() {
        return props2.children;
      }
    });
  };
  return {
    DomCollectionProvider
  };
}
function createDomCollectionItem(props) {
  const context = useDomCollectionContext();
  const mergedProps = mergeDefaultProps({
    shouldRegisterItem: true
  }, props);
  createEffect(() => {
    if (!mergedProps.shouldRegisterItem) {
      return;
    }
    const unregister = context.registerItem(mergedProps.getItem());
    onCleanup(unregister);
  });
}

function buildNodes(params) {
  let index = params.startIndex ?? 0;
  const level = params.startLevel ?? 0;
  const nodes = [];
  const getKey = (data) => {
    if (data == null) {
      return "";
    }
    const _getKey = params.getKey ?? "key";
    const dataKey = isString(_getKey) ? data[_getKey] : _getKey(data);
    return dataKey != null ? String(dataKey) : "";
  };
  const getTextValue = (data) => {
    if (data == null) {
      return "";
    }
    const _getTextValue = params.getTextValue ?? "textValue";
    const dataTextValue = isString(_getTextValue) ? data[_getTextValue] : _getTextValue(data);
    return dataTextValue != null ? String(dataTextValue) : "";
  };
  const getDisabled = (data) => {
    if (data == null) {
      return false;
    }
    const _getDisabled = params.getDisabled ?? "disabled";
    return (isString(_getDisabled) ? data[_getDisabled] : _getDisabled(data)) ?? false;
  };
  const getSectionChildren = (data) => {
    if (data == null) {
      return void 0;
    }
    if (isString(params.getSectionChildren)) {
      return data[params.getSectionChildren];
    }
    return params.getSectionChildren?.(data);
  };
  for (const data of params.dataSource) {
    if (isString(data) || isNumber(data)) {
      nodes.push({
        type: "item",
        rawValue: data,
        key: String(data),
        textValue: String(data),
        disabled: getDisabled(data),
        level,
        index
      });
      index++;
      continue;
    }
    if (getSectionChildren(data) != null) {
      nodes.push({
        type: "section",
        rawValue: data,
        key: "",
        // not applicable here
        textValue: "",
        // not applicable here
        disabled: false,
        // not applicable here
        level,
        index
      });
      index++;
      const sectionChildren = getSectionChildren(data) ?? [];
      if (sectionChildren.length > 0) {
        const childNodes = buildNodes({
          dataSource: sectionChildren,
          getKey: params.getKey,
          getTextValue: params.getTextValue,
          getDisabled: params.getDisabled,
          getSectionChildren: params.getSectionChildren,
          startIndex: index,
          startLevel: level + 1
        });
        nodes.push(...childNodes);
        index += childNodes.length;
      }
    } else {
      nodes.push({
        type: "item",
        rawValue: data,
        key: getKey(data),
        textValue: getTextValue(data),
        disabled: getDisabled(data),
        level,
        index
      });
      index++;
    }
  }
  return nodes;
}
function createCollection(props, deps = []) {
  return createMemo(() => {
    const nodes = buildNodes({
      dataSource: access$1(props.dataSource),
      getKey: access$1(props.getKey),
      getTextValue: access$1(props.getTextValue),
      getDisabled: access$1(props.getDisabled),
      getSectionChildren: access$1(props.getSectionChildren)
    });
    for (let i = 0; i < deps.length; i++) deps[i]();
    return props.factory(nodes);
  });
}

var Selection = class _Selection extends Set {
  anchorKey;
  currentKey;
  constructor(keys, anchorKey, currentKey) {
    super(keys);
    if (keys instanceof _Selection) {
      this.anchorKey = anchorKey || keys.anchorKey;
      this.currentKey = currentKey || keys.currentKey;
    } else {
      this.anchorKey = anchorKey;
      this.currentKey = currentKey;
    }
  }
};
function createControllableSelectionSignal(props) {
  const [_value, setValue] = createControllableSignal(props);
  const value = () => _value() ?? new Selection();
  return [value, setValue];
}
function isNonContiguousSelectionModifier(e) {
  return isAppleDevice() ? e.altKey : e.ctrlKey;
}
function isCtrlKeyPressed(e) {
  if (isMac()) {
    return e.metaKey;
  }
  return e.ctrlKey;
}
function convertSelection(selection) {
  return new Selection(selection);
}
function isSameSelection(setA, setB) {
  if (setA.size !== setB.size) {
    return false;
  }
  for (const item of setA) {
    if (!setB.has(item)) {
      return false;
    }
  }
  return true;
}
function createMultipleSelectionState(props) {
  const mergedProps = mergeDefaultProps({
    selectionMode: "none",
    selectionBehavior: "toggle"
  }, props);
  const [isFocused, setFocused] = createSignal(false);
  const [focusedKey, setFocusedKey] = createSignal();
  const selectedKeysProp = createMemo(() => {
    const selection = access$1(mergedProps.selectedKeys);
    if (selection != null) {
      return convertSelection(selection);
    }
    return selection;
  });
  const defaultSelectedKeys = createMemo(() => {
    const defaultSelection = access$1(mergedProps.defaultSelectedKeys);
    if (defaultSelection != null) {
      return convertSelection(defaultSelection);
    }
    return new Selection();
  });
  const [selectedKeys, _setSelectedKeys] = createControllableSelectionSignal({
    value: selectedKeysProp,
    defaultValue: defaultSelectedKeys,
    onChange: (value) => mergedProps.onSelectionChange?.(value)
  });
  const [selectionBehavior, setSelectionBehavior] = createSignal(access$1(mergedProps.selectionBehavior));
  const selectionMode = () => access$1(mergedProps.selectionMode);
  const disallowEmptySelection = () => access$1(mergedProps.disallowEmptySelection) ?? false;
  const setSelectedKeys = (keys) => {
    if (access$1(mergedProps.allowDuplicateSelectionEvents) || !isSameSelection(keys, selectedKeys())) {
      _setSelectedKeys(keys);
    }
  };
  createEffect(() => {
    const selection = selectedKeys();
    if (access$1(mergedProps.selectionBehavior) === "replace" && selectionBehavior() === "toggle" && typeof selection === "object" && selection.size === 0) {
      setSelectionBehavior("replace");
    }
  });
  createEffect(() => {
    setSelectionBehavior(access$1(mergedProps.selectionBehavior) ?? "toggle");
  });
  return {
    selectionMode,
    disallowEmptySelection,
    selectionBehavior,
    setSelectionBehavior,
    isFocused,
    setFocused,
    focusedKey,
    setFocusedKey,
    selectedKeys,
    setSelectedKeys
  };
}
function createTypeSelect(props) {
  const [search, setSearch] = createSignal("");
  const [timeoutId, setTimeoutId] = createSignal(-1);
  const onKeyDown = (e) => {
    if (access$1(props.isDisabled)) {
      return;
    }
    const delegate = access$1(props.keyboardDelegate);
    const manager = access$1(props.selectionManager);
    if (!delegate.getKeyForSearch) {
      return;
    }
    const character = getStringForKey(e.key);
    if (!character || e.ctrlKey || e.metaKey) {
      return;
    }
    if (character === " " && search().trim().length > 0) {
      e.preventDefault();
      e.stopPropagation();
    }
    let newSearch = setSearch((prev) => prev + character);
    let key = delegate.getKeyForSearch(newSearch, manager.focusedKey()) ?? delegate.getKeyForSearch(newSearch);
    if (key == null && isAllSameLetter(newSearch)) {
      newSearch = newSearch[0];
      key = delegate.getKeyForSearch(newSearch, manager.focusedKey()) ?? delegate.getKeyForSearch(newSearch);
    }
    if (key != null) {
      manager.setFocusedKey(key);
      props.onTypeSelect?.(key);
    }
    clearTimeout(timeoutId());
    setTimeoutId(window.setTimeout(() => setSearch(""), 500));
  };
  return {
    typeSelectHandlers: {
      onKeyDown
    }
  };
}
function getStringForKey(key) {
  if (key.length === 1 || !/^[A-Z]/i.test(key)) {
    return key;
  }
  return "";
}
function isAllSameLetter(search) {
  return search.split("").every((letter) => letter === search[0]);
}
function createSelectableCollection(props, ref, scrollRef) {
  const defaultProps = {
    selectOnFocus: () => access$1(props.selectionManager).selectionBehavior() === "replace"
  };
  const mergedProps = mergeProps(defaultProps, props);
  const finalScrollRef = () => ref();
  const {
    direction
  } = useLocale();
  let scrollPos = {
    top: 0,
    left: 0
  };
  createEventListener(() => !access$1(mergedProps.isVirtualized) ? finalScrollRef() : void 0, "scroll", () => {
    const scrollEl = finalScrollRef();
    if (!scrollEl) {
      return;
    }
    scrollPos = {
      top: scrollEl.scrollTop,
      left: scrollEl.scrollLeft
    };
  });
  const {
    typeSelectHandlers
  } = createTypeSelect({
    isDisabled: () => access$1(mergedProps.disallowTypeAhead),
    keyboardDelegate: () => access$1(mergedProps.keyboardDelegate),
    selectionManager: () => access$1(mergedProps.selectionManager)
  });
  const orientation = () => access$1(mergedProps.orientation) ?? "vertical";
  const onKeyDown = (e) => {
    callHandler(e, typeSelectHandlers.onKeyDown);
    if (e.altKey && e.key === "Tab") {
      e.preventDefault();
    }
    const refEl = ref();
    if (!refEl?.contains(e.target)) {
      return;
    }
    const manager = access$1(mergedProps.selectionManager);
    const selectOnFocus = access$1(mergedProps.selectOnFocus);
    const navigateToKey = (key) => {
      if (key != null) {
        manager.setFocusedKey(key);
        if (e.shiftKey && manager.selectionMode() === "multiple") {
          manager.extendSelection(key);
        } else if (selectOnFocus && !isNonContiguousSelectionModifier(e)) {
          manager.replaceSelection(key);
        }
      }
    };
    const delegate = access$1(mergedProps.keyboardDelegate);
    const shouldFocusWrap = access$1(mergedProps.shouldFocusWrap);
    const focusedKey = manager.focusedKey();
    switch (e.key) {
      case (orientation() === "vertical" ? "ArrowDown" : "ArrowRight"): {
        if (delegate.getKeyBelow) {
          e.preventDefault();
          let nextKey;
          if (focusedKey != null) {
            nextKey = delegate.getKeyBelow(focusedKey);
          } else {
            nextKey = delegate.getFirstKey?.();
          }
          if (nextKey == null && shouldFocusWrap) {
            nextKey = delegate.getFirstKey?.(focusedKey);
          }
          navigateToKey(nextKey);
        }
        break;
      }
      case (orientation() === "vertical" ? "ArrowUp" : "ArrowLeft"): {
        if (delegate.getKeyAbove) {
          e.preventDefault();
          let nextKey;
          if (focusedKey != null) {
            nextKey = delegate.getKeyAbove(focusedKey);
          } else {
            nextKey = delegate.getLastKey?.();
          }
          if (nextKey == null && shouldFocusWrap) {
            nextKey = delegate.getLastKey?.(focusedKey);
          }
          navigateToKey(nextKey);
        }
        break;
      }
      case (orientation() === "vertical" ? "ArrowLeft" : "ArrowUp"): {
        if (delegate.getKeyLeftOf) {
          e.preventDefault();
          const isRTL = direction() === "rtl";
          let nextKey;
          if (focusedKey != null) {
            nextKey = delegate.getKeyLeftOf(focusedKey);
          } else {
            nextKey = isRTL ? delegate.getFirstKey?.() : delegate.getLastKey?.();
          }
          navigateToKey(nextKey);
        }
        break;
      }
      case (orientation() === "vertical" ? "ArrowRight" : "ArrowDown"): {
        if (delegate.getKeyRightOf) {
          e.preventDefault();
          const isRTL = direction() === "rtl";
          let nextKey;
          if (focusedKey != null) {
            nextKey = delegate.getKeyRightOf(focusedKey);
          } else {
            nextKey = isRTL ? delegate.getLastKey?.() : delegate.getFirstKey?.();
          }
          navigateToKey(nextKey);
        }
        break;
      }
      case "Home":
        if (delegate.getFirstKey) {
          e.preventDefault();
          const firstKey = delegate.getFirstKey(focusedKey, isCtrlKeyPressed(e));
          if (firstKey != null) {
            manager.setFocusedKey(firstKey);
            if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode() === "multiple") {
              manager.extendSelection(firstKey);
            } else if (selectOnFocus) {
              manager.replaceSelection(firstKey);
            }
          }
        }
        break;
      case "End":
        if (delegate.getLastKey) {
          e.preventDefault();
          const lastKey = delegate.getLastKey(focusedKey, isCtrlKeyPressed(e));
          if (lastKey != null) {
            manager.setFocusedKey(lastKey);
            if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode() === "multiple") {
              manager.extendSelection(lastKey);
            } else if (selectOnFocus) {
              manager.replaceSelection(lastKey);
            }
          }
        }
        break;
      case "PageDown":
        if (delegate.getKeyPageBelow && focusedKey != null) {
          e.preventDefault();
          const nextKey = delegate.getKeyPageBelow(focusedKey);
          navigateToKey(nextKey);
        }
        break;
      case "PageUp":
        if (delegate.getKeyPageAbove && focusedKey != null) {
          e.preventDefault();
          const nextKey = delegate.getKeyPageAbove(focusedKey);
          navigateToKey(nextKey);
        }
        break;
      case "a":
        if (isCtrlKeyPressed(e) && manager.selectionMode() === "multiple" && access$1(mergedProps.disallowSelectAll) !== true) {
          e.preventDefault();
          manager.selectAll();
        }
        break;
      case "Escape":
        if (!e.defaultPrevented) {
          e.preventDefault();
          if (!access$1(mergedProps.disallowEmptySelection)) {
            manager.clearSelection();
          }
        }
        break;
      case "Tab": {
        if (!access$1(mergedProps.allowsTabNavigation)) {
          if (e.shiftKey) {
            refEl.focus();
          } else {
            const walker = getFocusableTreeWalker(refEl, {
              tabbable: true
            });
            let next;
            let last;
            do {
              last = walker.lastChild();
              if (last) {
                next = last;
              }
            } while (last);
            if (next && !next.contains(document.activeElement)) {
              focusWithoutScrolling(next);
            }
          }
          break;
        }
      }
    }
  };
  const onFocusIn = (e) => {
    const manager = access$1(mergedProps.selectionManager);
    const delegate = access$1(mergedProps.keyboardDelegate);
    const selectOnFocus = access$1(mergedProps.selectOnFocus);
    if (manager.isFocused()) {
      if (!e.currentTarget.contains(e.target)) {
        manager.setFocused(false);
      }
      return;
    }
    if (!e.currentTarget.contains(e.target)) {
      return;
    }
    manager.setFocused(true);
    if (manager.focusedKey() == null) {
      const navigateToFirstKey = (key) => {
        if (key == null) {
          return;
        }
        manager.setFocusedKey(key);
        if (selectOnFocus) {
          manager.replaceSelection(key);
        }
      };
      const relatedTarget = e.relatedTarget;
      if (relatedTarget && e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING) {
        navigateToFirstKey(manager.lastSelectedKey() ?? delegate.getLastKey?.());
      } else {
        navigateToFirstKey(manager.firstSelectedKey() ?? delegate.getFirstKey?.());
      }
    } else if (!access$1(mergedProps.isVirtualized)) {
      const scrollEl = finalScrollRef();
      if (scrollEl) {
        scrollEl.scrollTop = scrollPos.top;
        scrollEl.scrollLeft = scrollPos.left;
        const element = scrollEl.querySelector(`[data-key="${manager.focusedKey()}"]`);
        if (element) {
          focusWithoutScrolling(element);
          scrollIntoView(scrollEl, element);
        }
      }
    }
  };
  const onFocusOut = (e) => {
    const manager = access$1(mergedProps.selectionManager);
    if (!e.currentTarget.contains(e.relatedTarget)) {
      manager.setFocused(false);
    }
  };
  const onMouseDown = (e) => {
    if (finalScrollRef() === e.target) {
      e.preventDefault();
    }
  };
  const tryAutoFocus = () => {
    const autoFocus = access$1(mergedProps.autoFocus);
    if (!autoFocus) {
      return;
    }
    const manager = access$1(mergedProps.selectionManager);
    const delegate = access$1(mergedProps.keyboardDelegate);
    let focusedKey;
    if (autoFocus === "first") {
      focusedKey = delegate.getFirstKey?.();
    }
    if (autoFocus === "last") {
      focusedKey = delegate.getLastKey?.();
    }
    const selectedKeys = manager.selectedKeys();
    if (selectedKeys.size) {
      focusedKey = selectedKeys.values().next().value;
    }
    manager.setFocused(true);
    manager.setFocusedKey(focusedKey);
    const refEl = ref();
    if (refEl && focusedKey == null && !access$1(mergedProps.shouldUseVirtualFocus)) {
      focusWithoutScrolling(refEl);
    }
  };
  onMount(() => {
    if (mergedProps.deferAutoFocus) {
      setTimeout(tryAutoFocus, 0);
    } else {
      tryAutoFocus();
    }
  });
  createEffect(on([finalScrollRef, () => access$1(mergedProps.isVirtualized), () => access$1(mergedProps.selectionManager).focusedKey()], (newValue) => {
    const [scrollEl, isVirtualized, focusedKey] = newValue;
    if (isVirtualized) {
      focusedKey && mergedProps.scrollToKey?.(focusedKey);
    } else {
      if (focusedKey && scrollEl) {
        const element = scrollEl.querySelector(`[data-key="${focusedKey}"]`);
        if (element) {
          scrollIntoView(scrollEl, element);
        }
      }
    }
  }));
  const tabIndex = createMemo(() => {
    if (access$1(mergedProps.shouldUseVirtualFocus)) {
      return void 0;
    }
    return access$1(mergedProps.selectionManager).focusedKey() == null ? 0 : -1;
  });
  return {
    tabIndex,
    onKeyDown,
    onMouseDown,
    onFocusIn,
    onFocusOut
  };
}
function createSelectableItem(props, ref) {
  const manager = () => access$1(props.selectionManager);
  const key = () => access$1(props.key);
  const shouldUseVirtualFocus = () => access$1(props.shouldUseVirtualFocus);
  const onSelect = (e) => {
    if (manager().selectionMode() === "none") {
      return;
    }
    if (manager().selectionMode() === "single") {
      if (manager().isSelected(key()) && !manager().disallowEmptySelection()) {
        manager().toggleSelection(key());
      } else {
        manager().replaceSelection(key());
      }
    } else if (e?.shiftKey) {
      manager().extendSelection(key());
    } else if (manager().selectionBehavior() === "toggle" || isCtrlKeyPressed(e) || "pointerType" in e && e.pointerType === "touch") {
      manager().toggleSelection(key());
    } else {
      manager().replaceSelection(key());
    }
  };
  const isSelected = () => manager().isSelected(key());
  const isDisabled = () => access$1(props.disabled) || manager().isDisabled(key());
  const allowsSelection = () => !isDisabled() && manager().canSelectItem(key());
  let pointerDownType = null;
  const onPointerDown = (e) => {
    if (!allowsSelection()) {
      return;
    }
    pointerDownType = e.pointerType;
    if (e.pointerType === "mouse" && e.button === 0 && !access$1(props.shouldSelectOnPressUp)) {
      onSelect(e);
    }
  };
  const onPointerUp = (e) => {
    if (!allowsSelection()) {
      return;
    }
    if (e.pointerType === "mouse" && e.button === 0 && access$1(props.shouldSelectOnPressUp) && access$1(props.allowsDifferentPressOrigin)) {
      onSelect(e);
    }
  };
  const onClick = (e) => {
    if (!allowsSelection()) {
      return;
    }
    if (access$1(props.shouldSelectOnPressUp) && !access$1(props.allowsDifferentPressOrigin) || pointerDownType !== "mouse") {
      onSelect(e);
    }
  };
  const onKeyDown = (e) => {
    if (!allowsSelection() || !["Enter", " "].includes(e.key)) {
      return;
    }
    if (isNonContiguousSelectionModifier(e)) {
      manager().toggleSelection(key());
    } else {
      onSelect(e);
    }
  };
  const onMouseDown = (e) => {
    if (isDisabled()) {
      e.preventDefault();
    }
  };
  const onFocus = (e) => {
    const refEl = ref();
    if (shouldUseVirtualFocus() || isDisabled() || !refEl) {
      return;
    }
    if (e.target === refEl) {
      manager().setFocusedKey(key());
    }
  };
  const tabIndex = createMemo(() => {
    if (shouldUseVirtualFocus() || isDisabled()) {
      return void 0;
    }
    return key() === manager().focusedKey() ? 0 : -1;
  });
  const dataKey = createMemo(() => {
    return access$1(props.virtualized) ? void 0 : key();
  });
  createEffect(on([ref, key, shouldUseVirtualFocus, () => manager().focusedKey(), () => manager().isFocused()], ([refEl, key2, shouldUseVirtualFocus2, focusedKey, isFocused]) => {
    if (refEl && key2 === focusedKey && isFocused && !shouldUseVirtualFocus2 && document.activeElement !== refEl) {
      if (props.focus) {
        props.focus();
      } else {
        focusWithoutScrolling(refEl);
      }
    }
  }));
  return {
    isSelected,
    isDisabled,
    allowsSelection,
    tabIndex,
    dataKey,
    onPointerDown,
    onPointerUp,
    onClick,
    onKeyDown,
    onMouseDown,
    onFocus
  };
}
var SelectionManager = class {
  collection;
  state;
  constructor(collection, state) {
    this.collection = collection;
    this.state = state;
  }
  /** The type of selection that is allowed in the collection. */
  selectionMode() {
    return this.state.selectionMode();
  }
  /** Whether the collection allows empty selection. */
  disallowEmptySelection() {
    return this.state.disallowEmptySelection();
  }
  /** The selection behavior for the collection. */
  selectionBehavior() {
    return this.state.selectionBehavior();
  }
  /** Sets the selection behavior for the collection. */
  setSelectionBehavior(selectionBehavior) {
    this.state.setSelectionBehavior(selectionBehavior);
  }
  /** Whether the collection is currently focused. */
  isFocused() {
    return this.state.isFocused();
  }
  /** Sets whether the collection is focused. */
  setFocused(isFocused) {
    this.state.setFocused(isFocused);
  }
  /** The current focused key in the collection. */
  focusedKey() {
    return this.state.focusedKey();
  }
  /** Sets the focused key. */
  setFocusedKey(key) {
    if (key == null || this.collection().getItem(key)) {
      this.state.setFocusedKey(key);
    }
  }
  /** The currently selected keys in the collection. */
  selectedKeys() {
    return this.state.selectedKeys();
  }
  /** Returns whether a key is selected. */
  isSelected(key) {
    if (this.state.selectionMode() === "none") {
      return false;
    }
    const retrievedKey = this.getKey(key);
    if (retrievedKey == null) {
      return false;
    }
    return this.state.selectedKeys().has(retrievedKey);
  }
  /** Whether the selection is empty. */
  isEmpty() {
    return this.state.selectedKeys().size === 0;
  }
  /** Whether all items in the collection are selected. */
  isSelectAll() {
    if (this.isEmpty()) {
      return false;
    }
    const selectedKeys = this.state.selectedKeys();
    return this.getAllSelectableKeys().every((k) => selectedKeys.has(k));
  }
  firstSelectedKey() {
    let first;
    for (const key of this.state.selectedKeys()) {
      const item = this.collection().getItem(key);
      const isItemBeforeFirst = item?.index != null && first?.index != null && item.index < first.index;
      if (!first || isItemBeforeFirst) {
        first = item;
      }
    }
    return first?.key;
  }
  lastSelectedKey() {
    let last;
    for (const key of this.state.selectedKeys()) {
      const item = this.collection().getItem(key);
      const isItemAfterLast = item?.index != null && last?.index != null && item.index > last.index;
      if (!last || isItemAfterLast) {
        last = item;
      }
    }
    return last?.key;
  }
  /** Extends the selection to the given key. */
  extendSelection(toKey) {
    if (this.selectionMode() === "none") {
      return;
    }
    if (this.selectionMode() === "single") {
      this.replaceSelection(toKey);
      return;
    }
    const retrievedToKey = this.getKey(toKey);
    if (retrievedToKey == null) {
      return;
    }
    const selectedKeys = this.state.selectedKeys();
    const anchorKey = selectedKeys.anchorKey || retrievedToKey;
    const selection = new Selection(selectedKeys, anchorKey, retrievedToKey);
    for (const key of this.getKeyRange(anchorKey, selectedKeys.currentKey || retrievedToKey)) {
      selection.delete(key);
    }
    for (const key of this.getKeyRange(retrievedToKey, anchorKey)) {
      if (this.canSelectItem(key)) {
        selection.add(key);
      }
    }
    this.state.setSelectedKeys(selection);
  }
  getKeyRange(from, to) {
    const fromItem = this.collection().getItem(from);
    const toItem = this.collection().getItem(to);
    if (fromItem && toItem) {
      if (fromItem.index != null && toItem.index != null && fromItem.index <= toItem.index) {
        return this.getKeyRangeInternal(from, to);
      }
      return this.getKeyRangeInternal(to, from);
    }
    return [];
  }
  getKeyRangeInternal(from, to) {
    const keys = [];
    let key = from;
    while (key != null) {
      const item = this.collection().getItem(key);
      if (item && item.type === "item") {
        keys.push(key);
      }
      if (key === to) {
        return keys;
      }
      key = this.collection().getKeyAfter(key);
    }
    return [];
  }
  getKey(key) {
    const item = this.collection().getItem(key);
    if (!item) {
      return key;
    }
    if (!item || item.type !== "item") {
      return null;
    }
    return item.key;
  }
  /** Toggles whether the given key is selected. */
  toggleSelection(key) {
    if (this.selectionMode() === "none") {
      return;
    }
    if (this.selectionMode() === "single" && !this.isSelected(key)) {
      this.replaceSelection(key);
      return;
    }
    const retrievedKey = this.getKey(key);
    if (retrievedKey == null) {
      return;
    }
    const keys = new Selection(this.state.selectedKeys());
    if (keys.has(retrievedKey)) {
      keys.delete(retrievedKey);
    } else if (this.canSelectItem(retrievedKey)) {
      keys.add(retrievedKey);
      keys.anchorKey = retrievedKey;
      keys.currentKey = retrievedKey;
    }
    if (this.disallowEmptySelection() && keys.size === 0) {
      return;
    }
    this.state.setSelectedKeys(keys);
  }
  /** Replaces the selection with only the given key. */
  replaceSelection(key) {
    if (this.selectionMode() === "none") {
      return;
    }
    const retrievedKey = this.getKey(key);
    if (retrievedKey == null) {
      return;
    }
    const selection = this.canSelectItem(retrievedKey) ? new Selection([retrievedKey], retrievedKey, retrievedKey) : new Selection();
    this.state.setSelectedKeys(selection);
  }
  /** Replaces the selection with the given keys. */
  setSelectedKeys(keys) {
    if (this.selectionMode() === "none") {
      return;
    }
    const selection = new Selection();
    for (const key of keys) {
      const retrievedKey = this.getKey(key);
      if (retrievedKey != null) {
        selection.add(retrievedKey);
        if (this.selectionMode() === "single") {
          break;
        }
      }
    }
    this.state.setSelectedKeys(selection);
  }
  /** Selects all items in the collection. */
  selectAll() {
    if (this.selectionMode() === "multiple") {
      this.state.setSelectedKeys(new Set(this.getAllSelectableKeys()));
    }
  }
  /**
   * Removes all keys from the selection.
   */
  clearSelection() {
    const selectedKeys = this.state.selectedKeys();
    if (!this.disallowEmptySelection() && selectedKeys.size > 0) {
      this.state.setSelectedKeys(new Selection());
    }
  }
  /**
   * Toggles between select all and an empty selection.
   */
  toggleSelectAll() {
    if (this.isSelectAll()) {
      this.clearSelection();
    } else {
      this.selectAll();
    }
  }
  select(key, e) {
    if (this.selectionMode() === "none") {
      return;
    }
    if (this.selectionMode() === "single") {
      if (this.isSelected(key) && !this.disallowEmptySelection()) {
        this.toggleSelection(key);
      } else {
        this.replaceSelection(key);
      }
    } else if (this.selectionBehavior() === "toggle" || e && e.pointerType === "touch") {
      this.toggleSelection(key);
    } else {
      this.replaceSelection(key);
    }
  }
  /** Returns whether the current selection is equal to the given selection. */
  isSelectionEqual(selection) {
    if (selection === this.state.selectedKeys()) {
      return true;
    }
    const selectedKeys = this.selectedKeys();
    if (selection.size !== selectedKeys.size) {
      return false;
    }
    for (const key of selection) {
      if (!selectedKeys.has(key)) {
        return false;
      }
    }
    for (const key of selectedKeys) {
      if (!selection.has(key)) {
        return false;
      }
    }
    return true;
  }
  canSelectItem(key) {
    if (this.state.selectionMode() === "none") {
      return false;
    }
    const item = this.collection().getItem(key);
    return item != null && !item.disabled;
  }
  isDisabled(key) {
    const item = this.collection().getItem(key);
    return !item || item.disabled;
  }
  getAllSelectableKeys() {
    const keys = [];
    const addKeys = (key) => {
      while (key != null) {
        if (this.canSelectItem(key)) {
          const item = this.collection().getItem(key);
          if (!item) {
            continue;
          }
          if (item.type === "item") {
            keys.push(key);
          }
        }
        key = this.collection().getKeyAfter(key);
      }
    };
    addKeys(this.collection().getFirstKey());
    return keys;
  }
};
var ListCollection = class {
  keyMap = /* @__PURE__ */ new Map();
  iterable;
  firstKey;
  lastKey;
  constructor(nodes) {
    this.iterable = nodes;
    for (const node of nodes) {
      this.keyMap.set(node.key, node);
    }
    if (this.keyMap.size === 0) {
      return;
    }
    let last;
    let index = 0;
    for (const [key, node] of this.keyMap) {
      if (last) {
        last.nextKey = key;
        node.prevKey = last.key;
      } else {
        this.firstKey = key;
        node.prevKey = void 0;
      }
      if (node.type === "item") {
        node.index = index++;
      }
      last = node;
      last.nextKey = void 0;
    }
    this.lastKey = last.key;
  }
  *[Symbol.iterator]() {
    yield* this.iterable;
  }
  getSize() {
    return this.keyMap.size;
  }
  getKeys() {
    return this.keyMap.keys();
  }
  getKeyBefore(key) {
    return this.keyMap.get(key)?.prevKey;
  }
  getKeyAfter(key) {
    return this.keyMap.get(key)?.nextKey;
  }
  getFirstKey() {
    return this.firstKey;
  }
  getLastKey() {
    return this.lastKey;
  }
  getItem(key) {
    return this.keyMap.get(key);
  }
  at(idx) {
    const keys = [...this.getKeys()];
    return this.getItem(keys[idx]);
  }
};
function createListState(props) {
  const selectionState = createMultipleSelectionState(props);
  const factory = (nodes) => {
    return props.filter ? new ListCollection(props.filter(nodes)) : new ListCollection(nodes);
  };
  const collection = createCollection({
    dataSource: () => access$1(props.dataSource),
    getKey: () => access$1(props.getKey),
    getTextValue: () => access$1(props.getTextValue),
    getDisabled: () => access$1(props.getDisabled),
    getSectionChildren: () => access$1(props.getSectionChildren),
    factory
  }, [() => props.filter]);
  const selectionManager = new SelectionManager(collection, selectionState);
  createComputed(() => {
    const focusedKey = selectionState.focusedKey();
    if (focusedKey != null && !collection().getItem(focusedKey)) {
      selectionState.setFocusedKey(void 0);
    }
  });
  return {
    collection,
    selectionManager: () => selectionManager
  };
}

var ListKeyboardDelegate = class {
  collection;
  ref;
  collator;
  constructor(collection, ref, collator) {
    this.collection = collection;
    this.ref = ref;
    this.collator = collator;
  }
  getKeyBelow(key) {
    let keyAfter = this.collection().getKeyAfter(key);
    while (keyAfter != null) {
      const item = this.collection().getItem(keyAfter);
      if (item && item.type === "item" && !item.disabled) {
        return keyAfter;
      }
      keyAfter = this.collection().getKeyAfter(keyAfter);
    }
  }
  getKeyAbove(key) {
    let keyBefore = this.collection().getKeyBefore(key);
    while (keyBefore != null) {
      const item = this.collection().getItem(keyBefore);
      if (item && item.type === "item" && !item.disabled) {
        return keyBefore;
      }
      keyBefore = this.collection().getKeyBefore(keyBefore);
    }
  }
  getFirstKey() {
    let key = this.collection().getFirstKey();
    while (key != null) {
      const item = this.collection().getItem(key);
      if (item && item.type === "item" && !item.disabled) {
        return key;
      }
      key = this.collection().getKeyAfter(key);
    }
  }
  getLastKey() {
    let key = this.collection().getLastKey();
    while (key != null) {
      const item = this.collection().getItem(key);
      if (item && item.type === "item" && !item.disabled) {
        return key;
      }
      key = this.collection().getKeyBefore(key);
    }
  }
  getItem(key) {
    return this.ref?.()?.querySelector(`[data-key="${key}"]`) ?? null;
  }
  // TODO: not working correctly
  getKeyPageAbove(key) {
    const menu = this.ref?.();
    let item = this.getItem(key);
    if (!menu || !item) {
      return;
    }
    const pageY = Math.max(0, item.offsetTop + item.offsetHeight - menu.offsetHeight);
    let keyAbove = key;
    while (keyAbove && item && item.offsetTop > pageY) {
      keyAbove = this.getKeyAbove(keyAbove);
      item = keyAbove != null ? this.getItem(keyAbove) : null;
    }
    return keyAbove;
  }
  // TODO: not working correctly
  getKeyPageBelow(key) {
    const menu = this.ref?.();
    let item = this.getItem(key);
    if (!menu || !item) {
      return;
    }
    const pageY = Math.min(menu.scrollHeight, item.offsetTop - item.offsetHeight + menu.offsetHeight);
    let keyBelow = key;
    while (keyBelow && item && item.offsetTop < pageY) {
      keyBelow = this.getKeyBelow(keyBelow);
      item = keyBelow != null ? this.getItem(keyBelow) : null;
    }
    return keyBelow;
  }
  getKeyForSearch(search, fromKey) {
    const collator = this.collator?.();
    if (!collator) {
      return;
    }
    let key = fromKey != null ? this.getKeyBelow(fromKey) : this.getFirstKey();
    while (key != null) {
      const item = this.collection().getItem(key);
      if (item) {
        const substring = item.textValue.slice(0, search.length);
        if (item.textValue && collator.compare(substring, search) === 0) {
          return key;
        }
      }
      key = this.getKeyBelow(key);
    }
  }
};
function createSelectableList(props, ref, scrollRef) {
  const collator = createCollator({
    usage: "search",
    sensitivity: "base"
  });
  const delegate = createMemo(() => {
    const keyboardDelegate = access$1(props.keyboardDelegate);
    if (keyboardDelegate) {
      return keyboardDelegate;
    }
    return new ListKeyboardDelegate(props.collection, ref, collator);
  });
  return createSelectableCollection({
    selectionManager: () => access$1(props.selectionManager),
    keyboardDelegate: delegate,
    autoFocus: () => access$1(props.autoFocus),
    deferAutoFocus: () => access$1(props.deferAutoFocus),
    shouldFocusWrap: () => access$1(props.shouldFocusWrap),
    disallowEmptySelection: () => access$1(props.disallowEmptySelection),
    selectOnFocus: () => access$1(props.selectOnFocus),
    disallowTypeAhead: () => access$1(props.disallowTypeAhead),
    shouldUseVirtualFocus: () => access$1(props.shouldUseVirtualFocus),
    allowsTabNavigation: () => access$1(props.allowsTabNavigation),
    isVirtualized: () => access$1(props.isVirtualized),
    scrollToKey: (key) => access$1(props.scrollToKey)?.(key),
    orientation: () => access$1(props.orientation)
  }, ref);
}

var DATA_TOP_LAYER_ATTR = "data-kb-top-layer";
var originalBodyPointerEvents;
var hasDisabledBodyPointerEvents = false;
var layers = [];
function indexOf(node) {
  return layers.findIndex((layer) => layer.node === node);
}
function find(node) {
  return layers[indexOf(node)];
}
function isTopMostLayer(node) {
  return layers[layers.length - 1].node === node;
}
function getPointerBlockingLayers() {
  return layers.filter((layer) => layer.isPointerBlocking);
}
function getTopMostPointerBlockingLayer() {
  return [...getPointerBlockingLayers()].slice(-1)[0];
}
function hasPointerBlockingLayer() {
  return getPointerBlockingLayers().length > 0;
}
function isBelowPointerBlockingLayer(node) {
  const highestBlockingIndex = indexOf(getTopMostPointerBlockingLayer()?.node);
  return indexOf(node) < highestBlockingIndex;
}
function addLayer(layer) {
  layers.push(layer);
}
function removeLayer(node) {
  const index = indexOf(node);
  if (index < 0) {
    return;
  }
  layers.splice(index, 1);
}
function assignPointerEventToLayers() {
  for (const {
    node
  } of layers) {
    node.style.pointerEvents = isBelowPointerBlockingLayer(node) ? "none" : "auto";
  }
}
function disableBodyPointerEvents(node) {
  if (hasPointerBlockingLayer() && !hasDisabledBodyPointerEvents) {
    const ownerDocument = getDocument(node);
    originalBodyPointerEvents = document.body.style.pointerEvents;
    ownerDocument.body.style.pointerEvents = "none";
    hasDisabledBodyPointerEvents = true;
  }
}
function restoreBodyPointerEvents(node) {
  if (hasPointerBlockingLayer()) {
    return;
  }
  const ownerDocument = getDocument(node);
  ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
  if (ownerDocument.body.style.length === 0) {
    ownerDocument.body.removeAttribute("style");
  }
  hasDisabledBodyPointerEvents = false;
}
var layerStack = {
  layers,
  isTopMostLayer,
  hasPointerBlockingLayer,
  isBelowPointerBlockingLayer,
  addLayer,
  removeLayer,
  indexOf,
  find,
  assignPointerEventToLayers,
  disableBodyPointerEvents,
  restoreBodyPointerEvents
};

var AUTOFOCUS_ON_MOUNT_EVENT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT_EVENT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = {
  bubbles: false,
  cancelable: true
};
var focusScopeStack = {
  /** A stack of focus scopes, with the active one at the top */
  stack: [],
  active() {
    return this.stack[0];
  },
  add(scope) {
    if (scope !== this.active()) {
      this.active()?.pause();
    }
    this.stack = removeItemFromArray(this.stack, scope);
    this.stack.unshift(scope);
  },
  remove(scope) {
    this.stack = removeItemFromArray(this.stack, scope);
    this.active()?.resume();
  }
};
function createFocusScope(props, ref) {
  const [isPaused, setIsPaused] = createSignal(false);
  const focusScope = {
    pause() {
      setIsPaused(true);
    },
    resume() {
      setIsPaused(false);
    }
  };
  let lastFocusedElement = null;
  const onMountAutoFocus = (e) => props.onMountAutoFocus?.(e);
  const onUnmountAutoFocus = (e) => props.onUnmountAutoFocus?.(e);
  const ownerDocument = () => getDocument(ref());
  const createSentinel = () => {
    const element = ownerDocument().createElement("span");
    element.setAttribute("data-focus-trap", "");
    element.tabIndex = 0;
    Object.assign(element.style, visuallyHiddenStyles);
    return element;
  };
  const tabbables = () => {
    const container = ref();
    if (!container) {
      return [];
    }
    return getAllTabbableIn(container, true).filter((el) => !el.hasAttribute("data-focus-trap"));
  };
  const firstTabbable = () => {
    const items = tabbables();
    return items.length > 0 ? items[0] : null;
  };
  const lastTabbable = () => {
    const items = tabbables();
    return items.length > 0 ? items[items.length - 1] : null;
  };
  const shouldPreventUnmountAutoFocus = () => {
    const container = ref();
    if (!container) {
      return false;
    }
    const activeElement = getActiveElement(container);
    if (!activeElement) {
      return false;
    }
    if (contains$1(container, activeElement)) {
      return false;
    }
    return isFocusable(activeElement);
  };
  createEffect(() => {
    const container = ref();
    if (!container) {
      return;
    }
    focusScopeStack.add(focusScope);
    const previouslyFocusedElement = getActiveElement(container);
    const hasFocusedCandidate = contains$1(container, previouslyFocusedElement);
    if (!hasFocusedCandidate) {
      const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT_EVENT, EVENT_OPTIONS);
      container.addEventListener(AUTOFOCUS_ON_MOUNT_EVENT, onMountAutoFocus);
      container.dispatchEvent(mountEvent);
      if (!mountEvent.defaultPrevented) {
        setTimeout(() => {
          focusWithoutScrolling(firstTabbable());
          if (getActiveElement(container) === previouslyFocusedElement) {
            focusWithoutScrolling(container);
          }
        }, 0);
      }
    }
    onCleanup(() => {
      container.removeEventListener(AUTOFOCUS_ON_MOUNT_EVENT, onMountAutoFocus);
      setTimeout(() => {
        const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT_EVENT, EVENT_OPTIONS);
        if (shouldPreventUnmountAutoFocus()) {
          unmountEvent.preventDefault();
        }
        container.addEventListener(AUTOFOCUS_ON_UNMOUNT_EVENT, onUnmountAutoFocus);
        container.dispatchEvent(unmountEvent);
        if (!unmountEvent.defaultPrevented) {
          focusWithoutScrolling(previouslyFocusedElement ?? ownerDocument().body);
        }
        container.removeEventListener(AUTOFOCUS_ON_UNMOUNT_EVENT, onUnmountAutoFocus);
        focusScopeStack.remove(focusScope);
      }, 0);
    });
  });
  createEffect(() => {
    const container = ref();
    if (!container || !access$1(props.trapFocus) || isPaused()) {
      return;
    }
    const onFocusIn = (event) => {
      const target = event.target;
      if (target?.closest(`[${DATA_TOP_LAYER_ATTR}]`)) {
        return;
      }
      if (contains$1(container, target)) {
        lastFocusedElement = target;
      } else {
        focusWithoutScrolling(lastFocusedElement);
      }
    };
    const onFocusOut = (event) => {
      const relatedTarget = event.relatedTarget;
      const target = relatedTarget ?? getActiveElement(container);
      if (target?.closest(`[${DATA_TOP_LAYER_ATTR}]`)) {
        return;
      }
      if (!contains$1(container, target)) {
        focusWithoutScrolling(lastFocusedElement);
      }
    };
    ownerDocument().addEventListener("focusin", onFocusIn);
    ownerDocument().addEventListener("focusout", onFocusOut);
    onCleanup(() => {
      ownerDocument().removeEventListener("focusin", onFocusIn);
      ownerDocument().removeEventListener("focusout", onFocusOut);
    });
  });
  createEffect(() => {
    const container = ref();
    if (!container || !access$1(props.trapFocus) || isPaused()) {
      return;
    }
    const startSentinel = createSentinel();
    container.insertAdjacentElement("afterbegin", startSentinel);
    const endSentinel = createSentinel();
    container.insertAdjacentElement("beforeend", endSentinel);
    function onFocus(event) {
      const first = firstTabbable();
      const last = lastTabbable();
      if (event.relatedTarget === first) {
        focusWithoutScrolling(last);
      } else {
        focusWithoutScrolling(first);
      }
    }
    startSentinel.addEventListener("focusin", onFocus);
    endSentinel.addEventListener("focusin", onFocus);
    const observer = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        if (mutation.previousSibling === endSentinel) {
          endSentinel.remove();
          container.insertAdjacentElement("beforeend", endSentinel);
        }
        if (mutation.nextSibling === startSentinel) {
          startSentinel.remove();
          container.insertAdjacentElement("afterbegin", startSentinel);
        }
      }
    });
    observer.observe(container, {
      childList: true,
      subtree: false
    });
    onCleanup(() => {
      startSentinel.removeEventListener("focusin", onFocus);
      endSentinel.removeEventListener("focusin", onFocus);
      startSentinel.remove();
      endSentinel.remove();
      observer.disconnect();
    });
  });
}

var DATA_LIVE_ANNOUNCER_ATTR = "data-live-announcer";

function createHideOutside(props) {
  createEffect(() => {
    if (access$1(props.isDisabled)) {
      return;
    }
    onCleanup(ariaHideOutside(access$1(props.targets), access$1(props.root)));
  });
}
var refCountMap = /* @__PURE__ */ new WeakMap();
var observerStack = [];
function ariaHideOutside(targets, root = document.body) {
  const visibleNodes = new Set(targets);
  const hiddenNodes = /* @__PURE__ */ new Set();
  const walk = (root2) => {
    for (const element of root2.querySelectorAll(`[${DATA_LIVE_ANNOUNCER_ATTR}], [${DATA_TOP_LAYER_ATTR}]`)) {
      visibleNodes.add(element);
    }
    const acceptNode = (node) => {
      if (visibleNodes.has(node) || node.parentElement && hiddenNodes.has(node.parentElement) && node.parentElement.getAttribute("role") !== "row") {
        return NodeFilter.FILTER_REJECT;
      }
      for (const target of visibleNodes) {
        if (node.contains(target)) {
          return NodeFilter.FILTER_SKIP;
        }
      }
      return NodeFilter.FILTER_ACCEPT;
    };
    const walker = document.createTreeWalker(root2, NodeFilter.SHOW_ELEMENT, {
      acceptNode
    });
    const acceptRoot = acceptNode(root2);
    if (acceptRoot === NodeFilter.FILTER_ACCEPT) {
      hide(root2);
    }
    if (acceptRoot !== NodeFilter.FILTER_REJECT) {
      let node = walker.nextNode();
      while (node != null) {
        hide(node);
        node = walker.nextNode();
      }
    }
  };
  const hide = (node) => {
    const refCount = refCountMap.get(node) ?? 0;
    if (node.getAttribute("aria-hidden") === "true" && refCount === 0) {
      return;
    }
    if (refCount === 0) {
      node.setAttribute("aria-hidden", "true");
    }
    hiddenNodes.add(node);
    refCountMap.set(node, refCount + 1);
  };
  if (observerStack.length) {
    observerStack[observerStack.length - 1].disconnect();
  }
  walk(root);
  const observer = new MutationObserver((changes) => {
    for (const change of changes) {
      if (change.type !== "childList" || change.addedNodes.length === 0) {
        continue;
      }
      if (![...visibleNodes, ...hiddenNodes].some((node) => node.contains(change.target))) {
        for (const node of change.removedNodes) {
          if (node instanceof Element) {
            visibleNodes.delete(node);
            hiddenNodes.delete(node);
          }
        }
        for (const node of change.addedNodes) {
          if ((node instanceof HTMLElement || node instanceof SVGElement) && (node.dataset.liveAnnouncer === "true" || node.dataset.reactAriaTopLayer === "true")) {
            visibleNodes.add(node);
          } else if (node instanceof Element) {
            walk(node);
          }
        }
      }
    }
  });
  observer.observe(root, {
    childList: true,
    subtree: true
  });
  const observerWrapper = {
    observe() {
      observer.observe(root, {
        childList: true,
        subtree: true
      });
    },
    disconnect() {
      observer.disconnect();
    }
  };
  observerStack.push(observerWrapper);
  return () => {
    observer.disconnect();
    for (const node of hiddenNodes) {
      const count = refCountMap.get(node);
      if (count == null) {
        return;
      }
      if (count === 1) {
        node.removeAttribute("aria-hidden");
        refCountMap.delete(node);
      } else {
        refCountMap.set(node, count - 1);
      }
    }
    if (observerWrapper === observerStack[observerStack.length - 1]) {
      observerStack.pop();
      if (observerStack.length) {
        observerStack[observerStack.length - 1].observe();
      }
    } else {
      observerStack.splice(observerStack.indexOf(observerWrapper), 1);
    }
  };
}

function createEscapeKeyDown(props) {
  const handleKeyDown = (event) => {
    if (event.key === EventKey.Escape) {
      props.onEscapeKeyDown?.(event);
    }
  };
  createEffect(() => {
    if (access$1(props.isDisabled)) {
      return;
    }
    const document = props.ownerDocument?.() ?? getDocument();
    document.addEventListener("keydown", handleKeyDown);
    onCleanup(() => {
      document.removeEventListener("keydown", handleKeyDown);
    });
  });
}

var POINTER_DOWN_OUTSIDE_EVENT = "interactOutside.pointerDownOutside";
var FOCUS_OUTSIDE_EVENT = "interactOutside.focusOutside";
function createInteractOutside(props, ref) {
  let pointerDownTimeoutId;
  let clickHandler = noop;
  const ownerDocument = () => getDocument(ref());
  const onPointerDownOutside = (e) => props.onPointerDownOutside?.(e);
  const onFocusOutside = (e) => props.onFocusOutside?.(e);
  const onInteractOutside = (e) => props.onInteractOutside?.(e);
  const isEventOutside = (e) => {
    const target = e.target;
    if (!(target instanceof HTMLElement)) {
      return false;
    }
    if (target.closest(`[${DATA_TOP_LAYER_ATTR}]`)) {
      return false;
    }
    if (!contains$1(ownerDocument(), target)) {
      return false;
    }
    if (contains$1(ref(), target)) {
      return false;
    }
    return !props.shouldExcludeElement?.(target);
  };
  const onPointerDown = (e) => {
    function handler() {
      const container = ref();
      const target = e.target;
      if (!container || !target || !isEventOutside(e)) {
        return;
      }
      const handler2 = composeEventHandlers([onPointerDownOutside, onInteractOutside]);
      target.addEventListener(POINTER_DOWN_OUTSIDE_EVENT, handler2, {
        once: true
      });
      const pointerDownOutsideEvent = new CustomEvent(POINTER_DOWN_OUTSIDE_EVENT, {
        bubbles: false,
        cancelable: true,
        detail: {
          originalEvent: e,
          isContextMenu: e.button === 2 || isCtrlKey(e) && e.button === 0
        }
      });
      target.dispatchEvent(pointerDownOutsideEvent);
    }
    if (e.pointerType === "touch") {
      ownerDocument().removeEventListener("click", handler);
      clickHandler = handler;
      ownerDocument().addEventListener("click", handler, {
        once: true
      });
    } else {
      handler();
    }
  };
  const onFocusIn = (e) => {
    const container = ref();
    const target = e.target;
    if (!container || !target || !isEventOutside(e)) {
      return;
    }
    const handler = composeEventHandlers([onFocusOutside, onInteractOutside]);
    target.addEventListener(FOCUS_OUTSIDE_EVENT, handler, {
      once: true
    });
    const focusOutsideEvent = new CustomEvent(FOCUS_OUTSIDE_EVENT, {
      bubbles: false,
      cancelable: true,
      detail: {
        originalEvent: e,
        isContextMenu: false
      }
    });
    target.dispatchEvent(focusOutsideEvent);
  };
  createEffect(() => {
    if (access$1(props.isDisabled)) {
      return;
    }
    pointerDownTimeoutId = window.setTimeout(() => {
      ownerDocument().addEventListener("pointerdown", onPointerDown, true);
    }, 0);
    ownerDocument().addEventListener("focusin", onFocusIn, true);
    onCleanup(() => {
      window.clearTimeout(pointerDownTimeoutId);
      ownerDocument().removeEventListener("click", clickHandler);
      ownerDocument().removeEventListener("pointerdown", onPointerDown, true);
      ownerDocument().removeEventListener("focusin", onFocusIn, true);
    });
  });
}

var DismissableLayerContext = createContext();
function useOptionalDismissableLayerContext() {
  return useContext(DismissableLayerContext);
}
function DismissableLayer(props) {
  let ref;
  const parentContext = useOptionalDismissableLayerContext();
  const [local, others] = splitProps(props, ["ref", "disableOutsidePointerEvents", "excludedElements", "onEscapeKeyDown", "onPointerDownOutside", "onFocusOutside", "onInteractOutside", "onDismiss", "bypassTopMostLayerCheck"]);
  const nestedLayers = /* @__PURE__ */ new Set([]);
  const registerNestedLayer = (element) => {
    nestedLayers.add(element);
    const parentUnregister = parentContext?.registerNestedLayer(element);
    return () => {
      nestedLayers.delete(element);
      parentUnregister?.();
    };
  };
  const shouldExcludeElement = (element) => {
    if (!ref) {
      return false;
    }
    return local.excludedElements?.some((node) => contains$1(node(), element)) || [...nestedLayers].some((layer) => contains$1(layer, element));
  };
  const onPointerDownOutside = (e) => {
    if (!ref || layerStack.isBelowPointerBlockingLayer(ref)) {
      return;
    }
    if (!local.bypassTopMostLayerCheck && !layerStack.isTopMostLayer(ref)) {
      return;
    }
    local.onPointerDownOutside?.(e);
    local.onInteractOutside?.(e);
    if (!e.defaultPrevented) {
      local.onDismiss?.();
    }
  };
  const onFocusOutside = (e) => {
    local.onFocusOutside?.(e);
    local.onInteractOutside?.(e);
    if (!e.defaultPrevented) {
      local.onDismiss?.();
    }
  };
  createInteractOutside({
    shouldExcludeElement,
    onPointerDownOutside,
    onFocusOutside
  }, () => ref);
  createEscapeKeyDown({
    ownerDocument: () => getDocument(ref),
    onEscapeKeyDown: (e) => {
      if (!ref || !layerStack.isTopMostLayer(ref)) {
        return;
      }
      local.onEscapeKeyDown?.(e);
      if (!e.defaultPrevented && local.onDismiss) {
        e.preventDefault();
        local.onDismiss();
      }
    }
  });
  onMount(() => {
    if (!ref) {
      return;
    }
    layerStack.addLayer({
      node: ref,
      isPointerBlocking: local.disableOutsidePointerEvents,
      dismiss: local.onDismiss
    });
    const unregisterFromParentLayer = parentContext?.registerNestedLayer(ref);
    layerStack.assignPointerEventToLayers();
    layerStack.disableBodyPointerEvents(ref);
    onCleanup(() => {
      if (!ref) {
        return;
      }
      layerStack.removeLayer(ref);
      unregisterFromParentLayer?.();
      layerStack.assignPointerEventToLayers();
      layerStack.restoreBodyPointerEvents(ref);
    });
  });
  createEffect(on([() => ref, () => local.disableOutsidePointerEvents], ([ref2, disableOutsidePointerEvents]) => {
    if (!ref2) {
      return;
    }
    const layer = layerStack.find(ref2);
    if (layer && layer.isPointerBlocking !== disableOutsidePointerEvents) {
      layer.isPointerBlocking = disableOutsidePointerEvents;
      layerStack.assignPointerEventToLayers();
    }
    if (disableOutsidePointerEvents) {
      layerStack.disableBodyPointerEvents(ref2);
    }
    onCleanup(() => {
      layerStack.restoreBodyPointerEvents(ref2);
    });
  }, {
    defer: true
  }));
  const context = {
    registerNestedLayer
  };
  return createComponent(DismissableLayerContext.Provider, {
    value: context,
    get children() {
      return createComponent(Polymorphic, mergeProps({
        as: "div",
        ref(r$) {
          var _ref$ = mergeRefs((el) => ref = el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        }
      }, others));
    }
  });
}

function createToggleState(props = {}) {
  const [isSelected, _setIsSelected] = createControllableBooleanSignal({
    value: () => access$1(props.isSelected),
    defaultValue: () => !!access$1(props.defaultIsSelected),
    onChange: (value) => props.onSelectedChange?.(value)
  });
  const setIsSelected = (value) => {
    if (!access$1(props.isReadOnly) && !access$1(props.isDisabled)) {
      _setIsSelected(value);
    }
  };
  const toggle = () => {
    if (!access$1(props.isReadOnly) && !access$1(props.isDisabled)) {
      _setIsSelected(!isSelected());
    }
  };
  return {
    isSelected,
    setIsSelected,
    toggle
  };
}

function createDisclosureState(props = {}) {
  const [isOpen, setIsOpen] = createControllableBooleanSignal({
    value: () => access$1(props.open),
    defaultValue: () => !!access$1(props.defaultOpen),
    onChange: (value) => props.onOpenChange?.(value)
  });
  const open = () => {
    setIsOpen(true);
  };
  const close = () => {
    setIsOpen(false);
  };
  const toggle = () => {
    isOpen() ? close() : open();
  };
  return {
    isOpen,
    setIsOpen,
    open,
    close,
    toggle
  };
}

function createTagName(ref, fallback) {
  const [tagName, setTagName] = createSignal(stringOrUndefined(fallback?.()));
  createEffect(() => {
    setTagName(ref()?.tagName.toLowerCase() || stringOrUndefined(fallback?.()));
  });
  return tagName;
}
function stringOrUndefined(value) {
  return isString(value) ? value : void 0;
}

var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all) __defProp(target, name, {
    get: all[name],
    enumerable: true
  });
};

var button_exports = {};
__export(button_exports, {
  Button: () => Button$1,
  Root: () => ButtonRoot
});
var BUTTON_INPUT_TYPES = ["button", "color", "file", "image", "reset", "submit"];
function isButton(element) {
  const tagName = element.tagName.toLowerCase();
  if (tagName === "button") {
    return true;
  }
  if (tagName === "input" && element.type) {
    return BUTTON_INPUT_TYPES.indexOf(element.type) !== -1;
  }
  return false;
}
function ButtonRoot(props) {
  let ref;
  const mergedProps = mergeDefaultProps({
    type: "button"
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "type", "disabled"]);
  const tagName = createTagName(() => ref, () => "button");
  const isNativeButton = createMemo(() => {
    const elementTagName = tagName();
    if (elementTagName == null) {
      return false;
    }
    return isButton({
      tagName: elementTagName,
      type: local.type
    });
  });
  const isNativeInput = createMemo(() => {
    return tagName() === "input";
  });
  const isNativeLink = createMemo(() => {
    return tagName() === "a" && ref?.getAttribute("href") != null;
  });
  return createComponent(Polymorphic, mergeProps({
    as: "button",
    ref(r$) {
      var _ref$ = mergeRefs((el) => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get type() {
      return isNativeButton() || isNativeInput() ? local.type : void 0;
    },
    get role() {
      return !isNativeButton() && !isNativeLink() ? "button" : void 0;
    },
    get tabIndex() {
      return !isNativeButton() && !isNativeLink() && !local.disabled ? 0 : void 0;
    },
    get disabled() {
      return isNativeButton() || isNativeInput() ? local.disabled : void 0;
    },
    get ["aria-disabled"]() {
      return !isNativeButton() && !isNativeInput() && local.disabled ? true : void 0;
    },
    get ["data-disabled"]() {
      return local.disabled ? "" : void 0;
    }
  }, others));
}
var Button$1 = ButtonRoot;

function createRegisterId(setter) {
  return (id) => {
    setter(id);
    return () => setter(void 0);
  };
}

var access = (v) => typeof v === "function" ? v() : v;

var contains = (wrapper, target) => {
  if (wrapper.contains(target)) return true;
  let currentElement = target;
  while (currentElement) {
    if (currentElement === wrapper) return true;
    currentElement = currentElement._$host ?? currentElement.parentElement;
  }
  return false;
};

var activeStyles = /* @__PURE__ */ new Map();
var createStyle = (props) => {
  createEffect(() => {
    const style = access(props.style) ?? {};
    const properties = access(props.properties) ?? [];
    const originalStyles = {};
    for (const key in style) {
      originalStyles[key] = props.element.style[key];
    }
    const activeStyle = activeStyles.get(props.key);
    if (activeStyle) {
      activeStyle.activeCount++;
    } else {
      activeStyles.set(props.key, {
        activeCount: 1,
        originalStyles,
        properties: properties.map((property) => property.key)
      });
    }
    Object.assign(props.element.style, props.style);
    for (const property of properties) {
      props.element.style.setProperty(property.key, property.value);
    }
    onCleanup(() => {
      const activeStyle2 = activeStyles.get(props.key);
      if (!activeStyle2) return;
      if (activeStyle2.activeCount !== 1) {
        activeStyle2.activeCount--;
        return;
      }
      activeStyles.delete(props.key);
      for (const [key, value] of Object.entries(activeStyle2.originalStyles)) {
        props.element.style[key] = value;
      }
      for (const property of activeStyle2.properties) {
        props.element.style.removeProperty(property);
      }
      if (props.element.style.length === 0) {
        props.element.removeAttribute("style");
      }
      props.cleanup?.();
    });
  });
};
var style_default = createStyle;

var getScrollDimensions = (element, axis) => {
  switch (axis) {
    case "x":
      return [element.clientWidth, element.scrollLeft, element.scrollWidth];
    case "y":
      return [element.clientHeight, element.scrollTop, element.scrollHeight];
  }
};
var isScrollContainer = (element, axis) => {
  const styles = getComputedStyle(element);
  const overflow = axis === "x" ? styles.overflowX : styles.overflowY;
  return overflow === "auto" || overflow === "scroll" || // The HTML element is a scroll container if it has overflow visible
  element.tagName === "HTML" && overflow === "visible";
};
var getScrollAtLocation = (location, axis, stopAt) => {
  const directionFactor = axis === "x" && window.getComputedStyle(location).direction === "rtl" ? -1 : 1;
  let currentElement = location;
  let availableScroll = 0;
  let availableScrollTop = 0;
  let wrapperReached = false;
  do {
    const [clientSize, scrollOffset, scrollSize] = getScrollDimensions(currentElement, axis);
    const scrolled = scrollSize - clientSize - directionFactor * scrollOffset;
    if ((scrollOffset !== 0 || scrolled !== 0) && isScrollContainer(currentElement, axis)) {
      availableScroll += scrolled;
      availableScrollTop += scrollOffset;
    }
    if (currentElement === (stopAt ?? document.documentElement)) {
      wrapperReached = true;
    } else {
      currentElement = currentElement._$host ?? currentElement.parentElement;
    }
  } while (currentElement && !wrapperReached);
  return [availableScroll, availableScrollTop];
};

var [preventScrollStack, setPreventScrollStack] = createSignal([]);
var isActive = (id) => preventScrollStack().indexOf(id) === preventScrollStack().length - 1;
var createPreventScroll = (props) => {
  const defaultedProps = mergeProps({
    element: null,
    enabled: true,
    hideScrollbar: true,
    preventScrollbarShift: true,
    preventScrollbarShiftMode: "padding",
    restoreScrollPosition: true,
    allowPinchZoom: false
  }, props);
  const preventScrollId = createUniqueId();
  let currentTouchStart = [0, 0];
  let currentTouchStartAxis = null;
  let currentTouchStartDelta = null;
  createEffect(() => {
    if (!access(defaultedProps.enabled)) return;
    setPreventScrollStack((stack) => [...stack, preventScrollId]);
    onCleanup(() => {
      setPreventScrollStack((stack) => stack.filter((id) => id !== preventScrollId));
    });
  });
  createEffect(() => {
    if (!access(defaultedProps.enabled) || !access(defaultedProps.hideScrollbar)) return;
    const {
      body
    } = document;
    const scrollbarWidth = window.innerWidth - body.offsetWidth;
    if (access(defaultedProps.preventScrollbarShift)) {
      const style = {
        overflow: "hidden"
      };
      const properties = [];
      if (scrollbarWidth > 0) {
        if (access(defaultedProps.preventScrollbarShiftMode) === "padding") {
          style.paddingRight = `calc(${window.getComputedStyle(body).paddingRight} + ${scrollbarWidth}px)`;
        } else {
          style.marginRight = `calc(${window.getComputedStyle(body).marginRight} + ${scrollbarWidth}px)`;
        }
        properties.push({
          key: "--scrollbar-width",
          value: `${scrollbarWidth}px`
        });
      }
      const offsetTop = window.scrollY;
      const offsetLeft = window.scrollX;
      style_default({
        key: "prevent-scroll",
        element: body,
        style,
        properties,
        cleanup: () => {
          if (access(defaultedProps.restoreScrollPosition) && scrollbarWidth > 0) {
            window.scrollTo(offsetLeft, offsetTop);
          }
        }
      });
    } else {
      style_default({
        key: "prevent-scroll",
        element: body,
        style: {
          overflow: "hidden"
        }
      });
    }
  });
  createEffect(() => {
    if (!isActive(preventScrollId) || !access(defaultedProps.enabled)) return;
    document.addEventListener("wheel", maybePreventWheel, {
      passive: false
    });
    document.addEventListener("touchstart", logTouchStart, {
      passive: false
    });
    document.addEventListener("touchmove", maybePreventTouch, {
      passive: false
    });
    onCleanup(() => {
      document.removeEventListener("wheel", maybePreventWheel);
      document.removeEventListener("touchstart", logTouchStart);
      document.removeEventListener("touchmove", maybePreventTouch);
    });
  });
  const logTouchStart = (event) => {
    currentTouchStart = getTouchXY(event);
    currentTouchStartAxis = null;
    currentTouchStartDelta = null;
  };
  const maybePreventWheel = (event) => {
    const target = event.target;
    const wrapper = access(defaultedProps.element);
    const delta = getDeltaXY(event);
    const axis = Math.abs(delta[0]) > Math.abs(delta[1]) ? "x" : "y";
    const axisDelta = axis === "x" ? delta[0] : delta[1];
    const resultsInScroll = wouldScroll(target, axis, axisDelta, wrapper);
    let shouldCancel;
    if (wrapper && contains(wrapper, target)) {
      shouldCancel = !resultsInScroll;
    } else {
      shouldCancel = true;
    }
    if (shouldCancel && event.cancelable) {
      event.preventDefault();
    }
  };
  const maybePreventTouch = (event) => {
    const wrapper = access(defaultedProps.element);
    const target = event.target;
    let shouldCancel;
    if (event.touches.length === 2) {
      shouldCancel = !access(defaultedProps.allowPinchZoom);
    } else {
      if (currentTouchStartAxis == null || currentTouchStartDelta === null) {
        const delta = getTouchXY(event).map((touch, i) => currentTouchStart[i] - touch);
        const axis = Math.abs(delta[0]) > Math.abs(delta[1]) ? "x" : "y";
        currentTouchStartAxis = axis;
        currentTouchStartDelta = axis === "x" ? delta[0] : delta[1];
      }
      if (target.type === "range") {
        shouldCancel = false;
      } else {
        const wouldResultInScroll = wouldScroll(target, currentTouchStartAxis, currentTouchStartDelta, wrapper);
        if (wrapper && contains(wrapper, target)) {
          shouldCancel = !wouldResultInScroll;
        } else {
          shouldCancel = true;
        }
      }
    }
    if (shouldCancel && event.cancelable) {
      event.preventDefault();
    }
  };
};
var getDeltaXY = (event) => [event.deltaX, event.deltaY];
var getTouchXY = (event) => event.changedTouches[0] ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
var wouldScroll = (target, axis, delta, wrapper) => {
  const targetInWrapper = wrapper !== null && contains(wrapper, target);
  const [availableScroll, availableScrollTop] = getScrollAtLocation(target, axis, targetInWrapper ? wrapper : void 0);
  if (delta > 0 && Math.abs(availableScroll) <= 1) {
    return false;
  }
  if (delta < 0 && Math.abs(availableScrollTop) < 1) {
    return false;
  }
  return true;
};
var preventScroll_default = createPreventScroll;
var src_default$1 = preventScroll_default;

var createPresence = (props) => {
  const refStyles = createMemo(() => {
    const element = access(props.element);
    if (!element) return;
    return getComputedStyle(element);
  });
  const getAnimationName = () => {
    return refStyles()?.animationName ?? "none";
  };
  const [presentState, setPresentState] = createSignal(access(props.show) ? "present" : "hidden");
  let animationName = "none";
  createEffect((prevShow) => {
    const show = access(props.show);
    untrack(() => {
      if (prevShow === show) return show;
      const prevAnimationName = animationName;
      const currentAnimationName = getAnimationName();
      if (show) {
        setPresentState("present");
      } else if (currentAnimationName === "none" || refStyles()?.display === "none") {
        setPresentState("hidden");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (prevShow === true && isAnimating) {
          setPresentState("hiding");
        } else {
          setPresentState("hidden");
        }
      }
    });
    return show;
  });
  createEffect(() => {
    const element = access(props.element);
    if (!element) return;
    const handleAnimationStart = (event) => {
      if (event.target === element) {
        animationName = getAnimationName();
      }
    };
    const handleAnimationEnd = (event) => {
      const currentAnimationName = getAnimationName();
      const isCurrentAnimation = currentAnimationName.includes(event.animationName);
      if (event.target === element && isCurrentAnimation && presentState() === "hiding") {
        setPresentState("hidden");
      }
    };
    element.addEventListener("animationstart", handleAnimationStart);
    element.addEventListener("animationcancel", handleAnimationEnd);
    element.addEventListener("animationend", handleAnimationEnd);
    onCleanup(() => {
      element.removeEventListener("animationstart", handleAnimationStart);
      element.removeEventListener("animationcancel", handleAnimationEnd);
      element.removeEventListener("animationend", handleAnimationEnd);
    });
  });
  return {
    present: () => presentState() === "present" || presentState() === "hiding",
    state: presentState,
    setState: setPresentState
  };
};
var presence_default = createPresence;
var src_default = presence_default;

var MenuContext = createContext();
function useOptionalMenuContext() {
  return useContext(MenuContext);
}
function useMenuContext() {
  const context = useOptionalMenuContext();
  if (context === void 0) {
    throw new Error("[kobalte]: `useMenuContext` must be used within a `Menu` component");
  }
  return context;
}
var MenuItemContext = createContext();
function useMenuItemContext() {
  const context = useContext(MenuItemContext);
  if (context === void 0) {
    throw new Error("[kobalte]: `useMenuItemContext` must be used within a `Menu.Item` component");
  }
  return context;
}
var MenuRootContext = createContext();
function useMenuRootContext() {
  const context = useContext(MenuRootContext);
  if (context === void 0) {
    throw new Error("[kobalte]: `useMenuRootContext` must be used within a `MenuRoot` component");
  }
  return context;
}
function MenuItemBase(props) {
  let ref;
  const rootContext = useMenuRootContext();
  const menuContext = useMenuContext();
  const mergedProps = mergeDefaultProps({
    id: rootContext.generateId(`item-${createUniqueId()}`)
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "textValue", "disabled", "closeOnSelect", "checked", "indeterminate", "onSelect", "onPointerMove", "onPointerLeave", "onPointerDown", "onPointerUp", "onClick", "onKeyDown", "onMouseDown", "onFocus"]);
  const [labelId, setLabelId] = createSignal();
  const [descriptionId, setDescriptionId] = createSignal();
  const [labelRef, setLabelRef] = createSignal();
  const selectionManager = () => menuContext.listState().selectionManager();
  const key = () => others.id;
  const isHighlighted = () => selectionManager().focusedKey() === key();
  const onSelect = () => {
    local.onSelect?.();
    if (local.closeOnSelect) {
      setTimeout(() => {
        menuContext.close(true);
      });
    }
  };
  createDomCollectionItem({
    getItem: () => ({
      ref: () => ref,
      type: "item",
      key: key(),
      textValue: local.textValue ?? labelRef()?.textContent ?? ref?.textContent ?? "",
      disabled: local.disabled ?? false
    })
  });
  const selectableItem = createSelectableItem({
    key,
    selectionManager,
    shouldSelectOnPressUp: true,
    allowsDifferentPressOrigin: true,
    disabled: () => local.disabled
  }, () => ref);
  const onPointerMove = (e) => {
    callHandler(e, local.onPointerMove);
    if (e.pointerType !== "mouse") {
      return;
    }
    if (local.disabled) {
      menuContext.onItemLeave(e);
    } else {
      menuContext.onItemEnter(e);
      if (!e.defaultPrevented) {
        focusWithoutScrolling(e.currentTarget);
        menuContext.listState().selectionManager().setFocused(true);
        menuContext.listState().selectionManager().setFocusedKey(key());
      }
    }
  };
  const onPointerLeave = (e) => {
    callHandler(e, local.onPointerLeave);
    if (e.pointerType !== "mouse") {
      return;
    }
    menuContext.onItemLeave(e);
  };
  const onPointerUp = (e) => {
    callHandler(e, local.onPointerUp);
    if (!local.disabled && e.button === 0) {
      onSelect();
    }
  };
  const onKeyDown = (e) => {
    callHandler(e, local.onKeyDown);
    if (e.repeat) {
      return;
    }
    if (local.disabled) {
      return;
    }
    switch (e.key) {
      case "Enter":
      case " ":
        onSelect();
        break;
    }
  };
  const ariaChecked = createMemo(() => {
    if (local.indeterminate) {
      return "mixed";
    }
    if (local.checked == null) {
      return void 0;
    }
    return local.checked;
  });
  const dataset = createMemo(() => ({
    "data-indeterminate": local.indeterminate ? "" : void 0,
    "data-checked": local.checked && !local.indeterminate ? "" : void 0,
    "data-disabled": local.disabled ? "" : void 0,
    "data-highlighted": isHighlighted() ? "" : void 0
  }));
  const context = {
    isChecked: () => local.checked,
    dataset,
    setLabelRef,
    generateId: createGenerateId(() => others.id),
    registerLabel: createRegisterId(setLabelId),
    registerDescription: createRegisterId(setDescriptionId)
  };
  return createComponent(MenuItemContext.Provider, {
    value: context,
    get children() {
      return createComponent(Polymorphic, mergeProps({
        as: "div",
        ref(r$) {
          var _ref$ = mergeRefs((el) => ref = el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        get tabIndex() {
          return selectableItem.tabIndex();
        },
        get ["aria-checked"]() {
          return ariaChecked();
        },
        get ["aria-disabled"]() {
          return local.disabled;
        },
        get ["aria-labelledby"]() {
          return labelId();
        },
        get ["aria-describedby"]() {
          return descriptionId();
        },
        get ["data-key"]() {
          return selectableItem.dataKey();
        },
        get onPointerDown() {
          return composeEventHandlers([local.onPointerDown, selectableItem.onPointerDown]);
        },
        get onPointerUp() {
          return composeEventHandlers([onPointerUp, selectableItem.onPointerUp]);
        },
        get onClick() {
          return composeEventHandlers([local.onClick, selectableItem.onClick]);
        },
        get onKeyDown() {
          return composeEventHandlers([onKeyDown, selectableItem.onKeyDown]);
        },
        get onMouseDown() {
          return composeEventHandlers([local.onMouseDown, selectableItem.onMouseDown]);
        },
        get onFocus() {
          return composeEventHandlers([local.onFocus, selectableItem.onFocus]);
        },
        onPointerMove,
        onPointerLeave
      }, dataset, others));
    }
  });
}
function MenuCheckboxItem(props) {
  const mergedProps = mergeDefaultProps({
    closeOnSelect: false
  }, props);
  const [local, others] = splitProps(mergedProps, ["checked", "defaultChecked", "onChange", "onSelect"]);
  const state = createToggleState({
    isSelected: () => local.checked,
    defaultIsSelected: () => local.defaultChecked,
    onSelectedChange: (checked) => local.onChange?.(checked),
    isDisabled: () => others.disabled
  });
  const onSelect = () => {
    local.onSelect?.();
    state.toggle();
  };
  return createComponent(MenuItemBase, mergeProps({
    role: "menuitemcheckbox",
    get checked() {
      return state.isSelected();
    },
    onSelect
  }, others));
}
var MenubarContext = createContext();
function useOptionalMenubarContext() {
  return useContext(MenubarContext);
}
var MENUBAR_KEYS = {
  next: (dir, orientation) => dir === "ltr" ? orientation === "horizontal" ? "ArrowRight" : "ArrowDown" : orientation === "horizontal" ? "ArrowLeft" : "ArrowUp",
  previous: (dir, orientation) => MENUBAR_KEYS.next(dir === "ltr" ? "rtl" : "ltr", orientation)
};
var MENU_KEYS = {
  first: (orientation) => orientation === "horizontal" ? "ArrowDown" : "ArrowRight",
  last: (orientation) => orientation === "horizontal" ? "ArrowUp" : "ArrowLeft"
};
function MenuTrigger(props) {
  const rootContext = useMenuRootContext();
  const context = useMenuContext();
  const optionalMenubarContext = useOptionalMenubarContext();
  const {
    direction
  } = useLocale();
  const mergedProps = mergeDefaultProps({
    id: rootContext.generateId("trigger")
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "id", "disabled", "onPointerDown", "onClick", "onKeyDown", "onMouseOver", "onFocus"]);
  let key = () => rootContext.value();
  if (optionalMenubarContext !== void 0) {
    key = () => rootContext.value() ?? local.id;
    if (optionalMenubarContext.lastValue() === void 0) optionalMenubarContext.setLastValue(key);
  }
  const tagName = createTagName(() => context.triggerRef(), () => "button");
  const isNativeLink = createMemo(() => {
    return tagName() === "a" && context.triggerRef()?.getAttribute("href") != null;
  });
  createEffect(on(() => optionalMenubarContext?.value(), (value) => {
    if (!isNativeLink()) return;
    if (value === key()) context.triggerRef()?.focus();
  }));
  const handleClick = () => {
    if (optionalMenubarContext !== void 0) {
      if (!context.isOpen()) {
        if (!optionalMenubarContext.autoFocusMenu()) {
          optionalMenubarContext.setAutoFocusMenu(true);
        }
        context.open(false);
      } else {
        if (optionalMenubarContext.value() === key()) optionalMenubarContext.closeMenu();
      }
    } else context.toggle(true);
  };
  const onPointerDown = (e) => {
    callHandler(e, local.onPointerDown);
    e.currentTarget.dataset.pointerType = e.pointerType;
    if (!local.disabled && e.pointerType !== "touch" && e.button === 0) {
      handleClick();
    }
  };
  const onClick = (e) => {
    callHandler(e, local.onClick);
    if (!local.disabled) {
      if (e.currentTarget.dataset.pointerType === "touch") handleClick();
    }
  };
  const onKeyDown = (e) => {
    callHandler(e, local.onKeyDown);
    if (local.disabled) {
      return;
    }
    if (isNativeLink()) {
      switch (e.key) {
        case "Enter":
        case " ":
          return;
      }
    }
    switch (e.key) {
      case "Enter":
      case " ":
      case MENU_KEYS.first(rootContext.orientation()):
        e.stopPropagation();
        e.preventDefault();
        scrollIntoViewport(e.currentTarget);
        context.open("first");
        optionalMenubarContext?.setAutoFocusMenu(true);
        optionalMenubarContext?.setValue(key);
        break;
      case MENU_KEYS.last(rootContext.orientation()):
        e.stopPropagation();
        e.preventDefault();
        context.open("last");
        break;
      case MENUBAR_KEYS.next(direction(), rootContext.orientation()):
        if (optionalMenubarContext === void 0) break;
        e.stopPropagation();
        e.preventDefault();
        optionalMenubarContext.nextMenu();
        break;
      case MENUBAR_KEYS.previous(direction(), rootContext.orientation()):
        if (optionalMenubarContext === void 0) break;
        e.stopPropagation();
        e.preventDefault();
        optionalMenubarContext.previousMenu();
        break;
    }
  };
  const onMouseOver = (e) => {
    callHandler(e, local.onMouseOver);
    if (context.triggerRef()?.dataset.pointerType === "touch") return;
    if (!local.disabled && optionalMenubarContext !== void 0 && optionalMenubarContext.value() !== void 0) {
      optionalMenubarContext.setValue(key);
    }
  };
  const onFocus = (e) => {
    callHandler(e, local.onFocus);
    if (optionalMenubarContext !== void 0 && e.currentTarget.dataset.pointerType !== "touch") optionalMenubarContext.setValue(key);
  };
  createEffect(() => onCleanup(context.registerTriggerId(local.id)));
  return createComponent(ButtonRoot, mergeProps({
    ref(r$) {
      var _ref$2 = mergeRefs(context.setTriggerRef, local.ref);
      typeof _ref$2 === "function" && _ref$2(r$);
    },
    get ["data-kb-menu-value-trigger"]() {
      return rootContext.value();
    },
    get id() {
      return local.id;
    },
    get disabled() {
      return local.disabled;
    },
    "aria-haspopup": "true",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return createMemo(() => !!context.isOpen())() ? context.contentId() : void 0;
    },
    get ["data-highlighted"]() {
      return key() !== void 0 && optionalMenubarContext?.value() === key() ? true : void 0;
    },
    get tabIndex() {
      return optionalMenubarContext !== void 0 ? optionalMenubarContext.value() === key() || optionalMenubarContext.lastValue() === key() ? 0 : -1 : void 0;
    },
    onPointerDown,
    onMouseOver,
    onClick,
    onKeyDown,
    onFocus,
    role: optionalMenubarContext !== void 0 ? "menuitem" : void 0
  }, () => context.dataset(), others));
}
var NavigationMenuContext = createContext();
function useOptionalNavigationMenuContext() {
  return useContext(NavigationMenuContext);
}
function MenuContentBase(props) {
  let ref;
  const rootContext = useMenuRootContext();
  const context = useMenuContext();
  const optionalMenubarContext = useOptionalMenubarContext();
  const optionalNavigationMenuContext = useOptionalNavigationMenuContext();
  const {
    direction
  } = useLocale();
  const mergedProps = mergeDefaultProps({
    id: rootContext.generateId(`content-${createUniqueId()}`)
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "id", "style", "onOpenAutoFocus", "onCloseAutoFocus", "onEscapeKeyDown", "onFocusOutside", "onPointerEnter", "onPointerMove", "onKeyDown", "onMouseDown", "onFocusIn", "onFocusOut"]);
  let lastPointerX = 0;
  const isRootModalContent = () => {
    return context.parentMenuContext() == null && optionalMenubarContext === void 0 && rootContext.isModal();
  };
  const selectableList = createSelectableList({
    selectionManager: context.listState().selectionManager,
    collection: context.listState().collection,
    autoFocus: context.autoFocus,
    deferAutoFocus: true,
    // ensure all menu items are mounted and collection is not empty before trying to autofocus.
    shouldFocusWrap: true,
    disallowTypeAhead: () => !context.listState().selectionManager().isFocused(),
    orientation: () => rootContext.orientation() === "horizontal" ? "vertical" : "horizontal"
  }, () => ref);
  createFocusScope({
    trapFocus: () => isRootModalContent() && context.isOpen(),
    onMountAutoFocus: (event) => {
      if (optionalMenubarContext === void 0) local.onOpenAutoFocus?.(event);
    },
    onUnmountAutoFocus: local.onCloseAutoFocus
  }, () => ref);
  const onKeyDown = (e) => {
    if (!contains$1(e.currentTarget, e.target)) {
      return;
    }
    if (e.key === "Tab" && context.isOpen()) {
      e.preventDefault();
    }
    if (optionalMenubarContext !== void 0) {
      if (e.currentTarget.getAttribute("aria-haspopup") !== "true") switch (e.key) {
        case MENUBAR_KEYS.next(direction(), rootContext.orientation()):
          e.stopPropagation();
          e.preventDefault();
          context.close(true);
          optionalMenubarContext.setAutoFocusMenu(true);
          optionalMenubarContext.nextMenu();
          break;
        case MENUBAR_KEYS.previous(direction(), rootContext.orientation()):
          if (e.currentTarget.hasAttribute("data-closed")) break;
          e.stopPropagation();
          e.preventDefault();
          context.close(true);
          optionalMenubarContext.setAutoFocusMenu(true);
          optionalMenubarContext.previousMenu();
          break;
      }
    }
  };
  const onEscapeKeyDown = (e) => {
    local.onEscapeKeyDown?.(e);
    optionalMenubarContext?.setAutoFocusMenu(false);
    context.close(true);
  };
  const onFocusOutside = (e) => {
    local.onFocusOutside?.(e);
    if (rootContext.isModal()) {
      e.preventDefault();
    }
  };
  const onPointerEnter = (e) => {
    callHandler(e, local.onPointerEnter);
    if (!context.isOpen()) {
      return;
    }
    context.parentMenuContext()?.listState().selectionManager().setFocused(false);
    context.parentMenuContext()?.listState().selectionManager().setFocusedKey(void 0);
  };
  const onPointerMove = (e) => {
    callHandler(e, local.onPointerMove);
    if (e.pointerType !== "mouse") {
      return;
    }
    const target = e.target;
    const pointerXHasChanged = lastPointerX !== e.clientX;
    if (contains$1(e.currentTarget, target) && pointerXHasChanged) {
      context.setPointerDir(e.clientX > lastPointerX ? "right" : "left");
      lastPointerX = e.clientX;
    }
  };
  createEffect(() => onCleanup(context.registerContentId(local.id)));
  onCleanup(() => context.setContentRef(void 0));
  const commonAttributes = {
    ref: mergeRefs((el) => {
      context.setContentRef(el);
      ref = el;
    }, local.ref),
    role: "menu",
    get id() {
      return local.id;
    },
    get tabIndex() {
      return selectableList.tabIndex();
    },
    get "aria-labelledby"() {
      return context.triggerId();
    },
    onKeyDown: composeEventHandlers([local.onKeyDown, selectableList.onKeyDown, onKeyDown]),
    onMouseDown: composeEventHandlers([local.onMouseDown, selectableList.onMouseDown]),
    onFocusIn: composeEventHandlers([local.onFocusIn, selectableList.onFocusIn]),
    onFocusOut: composeEventHandlers([local.onFocusOut, selectableList.onFocusOut]),
    onPointerEnter,
    onPointerMove,
    get "data-orientation"() {
      return rootContext.orientation();
    }
  };
  return createComponent(Show, {
    get when() {
      return context.contentPresent();
    },
    get children() {
      return createComponent(Show, {
        get when() {
          return optionalNavigationMenuContext === void 0 || context.parentMenuContext() != null;
        },
        get fallback() {
          return createComponent(Polymorphic, mergeProps({
            as: "div"
          }, () => context.dataset(), commonAttributes, others));
        },
        get children() {
          return createComponent(Popper.Positioner, {
            get children() {
              return createComponent(DismissableLayer, mergeProps({
                get disableOutsidePointerEvents() {
                  return createMemo(() => !!isRootModalContent())() && context.isOpen();
                },
                get excludedElements() {
                  return [context.triggerRef];
                },
                bypassTopMostLayerCheck: true,
                get style() {
                  return combineStyle({
                    "--kb-menu-content-transform-origin": "var(--kb-popper-content-transform-origin)",
                    position: "relative"
                  }, local.style);
                },
                onEscapeKeyDown,
                onFocusOutside,
                get onDismiss() {
                  return context.close;
                }
              }, () => context.dataset(), commonAttributes, others));
            }
          });
        }
      });
    }
  });
}
function MenuContent(props) {
  let ref;
  const rootContext = useMenuRootContext();
  const context = useMenuContext();
  const [local, others] = splitProps(props, ["ref"]);
  src_default$1({
    element: () => ref ?? null,
    enabled: () => context.contentPresent() && rootContext.preventScroll()
  });
  return createComponent(MenuContentBase, mergeProps({
    ref(r$) {
      var _ref$3 = mergeRefs((el) => {
        ref = el;
      }, local.ref);
      typeof _ref$3 === "function" && _ref$3(r$);
    }
  }, others));
}
var MenuGroupContext = createContext();
function useMenuGroupContext() {
  const context = useContext(MenuGroupContext);
  if (context === void 0) {
    throw new Error("[kobalte]: `useMenuGroupContext` must be used within a `Menu.Group` component");
  }
  return context;
}
function MenuGroup(props) {
  const rootContext = useMenuRootContext();
  const mergedProps = mergeDefaultProps({
    id: rootContext.generateId(`group-${createUniqueId()}`)
  }, props);
  const [labelId, setLabelId] = createSignal();
  const context = {
    generateId: createGenerateId(() => mergedProps.id),
    registerLabelId: createRegisterId(setLabelId)
  };
  return createComponent(MenuGroupContext.Provider, {
    value: context,
    get children() {
      return createComponent(Polymorphic, mergeProps({
        as: "div",
        role: "group",
        get ["aria-labelledby"]() {
          return labelId();
        }
      }, mergedProps));
    }
  });
}
function MenuGroupLabel(props) {
  const context = useMenuGroupContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("label")
  }, props);
  const [local, others] = splitProps(mergedProps, ["id"]);
  createEffect(() => onCleanup(context.registerLabelId(local.id)));
  return createComponent(Polymorphic, mergeProps({
    as: "span",
    get id() {
      return local.id;
    },
    "aria-hidden": "true"
  }, others));
}
function MenuIcon(props) {
  const context = useMenuContext();
  const mergedProps = mergeDefaultProps({
    children: ""
  }, props);
  return createComponent(Polymorphic, mergeProps({
    as: "span",
    "aria-hidden": "true"
  }, () => context.dataset(), mergedProps));
}
function MenuItem(props) {
  return createComponent(MenuItemBase, mergeProps({
    role: "menuitem",
    closeOnSelect: true
  }, props));
}
function MenuItemDescription(props) {
  const context = useMenuItemContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("description")
  }, props);
  const [local, others] = splitProps(mergedProps, ["id"]);
  createEffect(() => onCleanup(context.registerDescription(local.id)));
  return createComponent(Polymorphic, mergeProps({
    as: "div",
    get id() {
      return local.id;
    }
  }, () => context.dataset(), others));
}
function MenuItemIndicator(props) {
  const context = useMenuItemContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("indicator")
  }, props);
  const [local, others] = splitProps(mergedProps, ["forceMount"]);
  return createComponent(Show, {
    get when() {
      return local.forceMount || context.isChecked();
    },
    get children() {
      return createComponent(Polymorphic, mergeProps({
        as: "div"
      }, () => context.dataset(), others));
    }
  });
}
function MenuItemLabel(props) {
  const context = useMenuItemContext();
  const mergedProps = mergeDefaultProps({
    id: context.generateId("label")
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "id"]);
  createEffect(() => onCleanup(context.registerLabel(local.id)));
  return createComponent(Polymorphic, mergeProps({
    as: "div",
    ref(r$) {
      var _ref$4 = mergeRefs(context.setLabelRef, local.ref);
      typeof _ref$4 === "function" && _ref$4(r$);
    },
    get id() {
      return local.id;
    }
  }, () => context.dataset(), others));
}
function MenuPortal(props) {
  const context = useMenuContext();
  return createComponent(Show, {
    get when() {
      return context.contentPresent();
    },
    get children() {
      return createComponent(Portal, props);
    }
  });
}
var MenuRadioGroupContext = createContext();
function useMenuRadioGroupContext() {
  const context = useContext(MenuRadioGroupContext);
  if (context === void 0) {
    throw new Error("[kobalte]: `useMenuRadioGroupContext` must be used within a `Menu.RadioGroup` component");
  }
  return context;
}
function MenuRadioGroup(props) {
  const rootContext = useMenuRootContext();
  const defaultId = rootContext.generateId(`radiogroup-${createUniqueId()}`);
  const mergedProps = mergeDefaultProps({
    id: defaultId
  }, props);
  const [local, others] = splitProps(mergedProps, ["value", "defaultValue", "onChange", "disabled"]);
  const [selected, setSelected] = createControllableSignal({
    value: () => local.value,
    defaultValue: () => local.defaultValue,
    onChange: (value) => local.onChange?.(value)
  });
  const context = {
    isDisabled: () => local.disabled,
    isSelectedValue: (value) => value === selected(),
    setSelectedValue: setSelected
  };
  return createComponent(MenuRadioGroupContext.Provider, {
    value: context,
    get children() {
      return createComponent(MenuGroup, others);
    }
  });
}
function MenuRadioItem(props) {
  const context = useMenuRadioGroupContext();
  const mergedProps = mergeDefaultProps({
    closeOnSelect: false
  }, props);
  const [local, others] = splitProps(mergedProps, ["value", "onSelect"]);
  const onSelect = () => {
    local.onSelect?.();
    context.setSelectedValue(local.value);
  };
  return createComponent(MenuItemBase, mergeProps({
    role: "menuitemradio",
    get checked() {
      return context.isSelectedValue(local.value);
    },
    onSelect
  }, others));
}
function getPointerGraceArea(placement, event, contentEl) {
  const basePlacement = placement.split("-")[0];
  const contentRect = contentEl.getBoundingClientRect();
  const polygon = [];
  const pointerX = event.clientX;
  const pointerY = event.clientY;
  switch (basePlacement) {
    case "top":
      polygon.push([pointerX, pointerY + 5]);
      polygon.push([contentRect.left, contentRect.bottom]);
      polygon.push([contentRect.left, contentRect.top]);
      polygon.push([contentRect.right, contentRect.top]);
      polygon.push([contentRect.right, contentRect.bottom]);
      break;
    case "right":
      polygon.push([pointerX - 5, pointerY]);
      polygon.push([contentRect.left, contentRect.top]);
      polygon.push([contentRect.right, contentRect.top]);
      polygon.push([contentRect.right, contentRect.bottom]);
      polygon.push([contentRect.left, contentRect.bottom]);
      break;
    case "bottom":
      polygon.push([pointerX, pointerY - 5]);
      polygon.push([contentRect.right, contentRect.top]);
      polygon.push([contentRect.right, contentRect.bottom]);
      polygon.push([contentRect.left, contentRect.bottom]);
      polygon.push([contentRect.left, contentRect.top]);
      break;
    case "left":
      polygon.push([pointerX + 5, pointerY]);
      polygon.push([contentRect.right, contentRect.bottom]);
      polygon.push([contentRect.left, contentRect.bottom]);
      polygon.push([contentRect.left, contentRect.top]);
      polygon.push([contentRect.right, contentRect.top]);
      break;
  }
  return polygon;
}
function isPointerInGraceArea(event, area) {
  if (!area) {
    return false;
  }
  return isPointInPolygon([event.clientX, event.clientY], area);
}
function Menu(props) {
  const rootContext = useMenuRootContext();
  const parentDomCollectionContext = useOptionalDomCollectionContext();
  const parentMenuContext = useOptionalMenuContext();
  const optionalMenubarContext = useOptionalMenubarContext();
  const optionalNavigationMenuContext = useOptionalNavigationMenuContext();
  const mergedProps = mergeDefaultProps({
    placement: rootContext.orientation() === "horizontal" ? "bottom-start" : "right-start"
  }, props);
  const [local, others] = splitProps(mergedProps, ["open", "defaultOpen", "onOpenChange"]);
  let pointerGraceTimeoutId = 0;
  let pointerGraceIntent = null;
  let pointerDir = "right";
  const [triggerId, setTriggerId] = createSignal();
  const [contentId, setContentId] = createSignal();
  const [triggerRef, setTriggerRef] = createSignal();
  const [contentRef, setContentRef] = createSignal();
  const [focusStrategy, setFocusStrategy] = createSignal(true);
  const [currentPlacement, setCurrentPlacement] = createSignal(others.placement);
  const [nestedMenus, setNestedMenus] = createSignal([]);
  const [items, setItems] = createSignal([]);
  const {
    DomCollectionProvider
  } = createDomCollection({
    items,
    onItemsChange: setItems
  });
  const disclosureState = createDisclosureState({
    open: () => local.open,
    defaultOpen: () => local.defaultOpen,
    onOpenChange: (isOpen) => local.onOpenChange?.(isOpen)
  });
  const {
    present: contentPresent
  } = src_default({
    show: () => rootContext.forceMount() || disclosureState.isOpen(),
    element: () => contentRef() ?? null
  });
  const listState = createListState({
    selectionMode: "none",
    dataSource: items
  });
  const open = (focusStrategy2) => {
    setFocusStrategy(focusStrategy2);
    disclosureState.open();
  };
  const close = (recursively = false) => {
    disclosureState.close();
    if (recursively && parentMenuContext) {
      parentMenuContext.close(true);
    }
  };
  const toggle = (focusStrategy2) => {
    setFocusStrategy(focusStrategy2);
    disclosureState.toggle();
  };
  const _focusContent = () => {
    const content = contentRef();
    if (content) {
      focusWithoutScrolling(content);
      listState.selectionManager().setFocused(true);
      listState.selectionManager().setFocusedKey(void 0);
    }
  };
  const focusContent = () => {
    if (optionalNavigationMenuContext != null) setTimeout(() => _focusContent());
    else _focusContent();
  };
  const registerNestedMenu = (element) => {
    setNestedMenus((prev) => [...prev, element]);
    const parentUnregister = parentMenuContext?.registerNestedMenu(element);
    return () => {
      setNestedMenus((prev) => removeItemFromArray(prev, element));
      parentUnregister?.();
    };
  };
  const isPointerMovingToSubmenu = (e) => {
    const isMovingTowards = pointerDir === pointerGraceIntent?.side;
    return isMovingTowards && isPointerInGraceArea(e, pointerGraceIntent?.area);
  };
  const onItemEnter = (e) => {
    if (isPointerMovingToSubmenu(e)) {
      e.preventDefault();
    }
  };
  const onItemLeave = (e) => {
    if (isPointerMovingToSubmenu(e)) {
      return;
    }
    focusContent();
  };
  const onTriggerLeave = (e) => {
    if (isPointerMovingToSubmenu(e)) {
      e.preventDefault();
    }
  };
  createHideOutside({
    isDisabled: () => {
      return !(parentMenuContext == null && disclosureState.isOpen() && rootContext.isModal());
    },
    targets: () => [contentRef(), ...nestedMenus()].filter(Boolean)
  });
  createEffect(() => {
    const contentEl = contentRef();
    if (!contentEl || !parentMenuContext) {
      return;
    }
    const parentUnregister = parentMenuContext.registerNestedMenu(contentEl);
    onCleanup(() => {
      parentUnregister();
    });
  });
  createEffect(() => {
    if (parentMenuContext !== void 0) return;
    optionalMenubarContext?.registerMenu(rootContext.value(), [contentRef(), ...nestedMenus()]);
  });
  createEffect(() => {
    if (parentMenuContext !== void 0 || optionalMenubarContext === void 0) return;
    if (optionalMenubarContext.value() === rootContext.value()) {
      triggerRef()?.focus();
      if (optionalMenubarContext.autoFocusMenu()) open(true);
    } else close();
  });
  createEffect(() => {
    if (parentMenuContext !== void 0 || optionalMenubarContext === void 0) return;
    if (disclosureState.isOpen()) optionalMenubarContext.setValue(rootContext.value());
  });
  onCleanup(() => {
    if (parentMenuContext !== void 0) return;
    optionalMenubarContext?.unregisterMenu(rootContext.value());
  });
  const dataset = createMemo(() => ({
    "data-expanded": disclosureState.isOpen() ? "" : void 0,
    "data-closed": !disclosureState.isOpen() ? "" : void 0
  }));
  const context = {
    dataset,
    isOpen: disclosureState.isOpen,
    contentPresent,
    nestedMenus,
    currentPlacement,
    pointerGraceTimeoutId: () => pointerGraceTimeoutId,
    autoFocus: focusStrategy,
    listState: () => listState,
    parentMenuContext: () => parentMenuContext,
    triggerRef,
    contentRef,
    triggerId,
    contentId,
    setTriggerRef,
    setContentRef,
    open,
    close,
    toggle,
    focusContent,
    onItemEnter,
    onItemLeave,
    onTriggerLeave,
    setPointerDir: (dir) => pointerDir = dir,
    setPointerGraceTimeoutId: (id) => pointerGraceTimeoutId = id,
    setPointerGraceIntent: (intent) => pointerGraceIntent = intent,
    registerNestedMenu,
    registerItemToParentDomCollection: parentDomCollectionContext?.registerItem,
    registerTriggerId: createRegisterId(setTriggerId),
    registerContentId: createRegisterId(setContentId)
  };
  return createComponent(DomCollectionProvider, {
    get children() {
      return createComponent(MenuContext.Provider, {
        value: context,
        get children() {
          return createComponent(Show, {
            when: optionalNavigationMenuContext === void 0,
            get fallback() {
              return others.children;
            },
            get children() {
              return createComponent(Popper, mergeProps({
                anchorRef: triggerRef,
                contentRef,
                onCurrentPlacementChange: setCurrentPlacement
              }, others));
            }
          });
        }
      });
    }
  });
}
function MenuSub(props) {
  const {
    direction
  } = useLocale();
  return createComponent(Menu, mergeProps({
    get placement() {
      return direction() === "rtl" ? "left-start" : "right-start";
    },
    flip: true
  }, props));
}
var SUB_CLOSE_KEYS = {
  close: (dir, orientation) => {
    if (dir === "ltr") {
      return [orientation === "horizontal" ? "ArrowLeft" : "ArrowUp"];
    }
    return [orientation === "horizontal" ? "ArrowRight" : "ArrowDown"];
  }
};
function MenuSubContent(props) {
  const context = useMenuContext();
  const rootContext = useMenuRootContext();
  const [local, others] = splitProps(props, ["onFocusOutside", "onKeyDown"]);
  const {
    direction
  } = useLocale();
  const onOpenAutoFocus = (e) => {
    e.preventDefault();
  };
  const onCloseAutoFocus = (e) => {
    e.preventDefault();
  };
  const onFocusOutside = (e) => {
    local.onFocusOutside?.(e);
    const target = e.target;
    if (!contains$1(context.triggerRef(), target)) {
      context.close();
    }
  };
  const onKeyDown = (e) => {
    callHandler(e, local.onKeyDown);
    const isKeyDownInside = contains$1(e.currentTarget, e.target);
    const isCloseKey = SUB_CLOSE_KEYS.close(direction(), rootContext.orientation()).includes(e.key);
    const isSubMenu = context.parentMenuContext() != null;
    if (isKeyDownInside && isCloseKey && isSubMenu) {
      context.close();
      focusWithoutScrolling(context.triggerRef());
    }
  };
  return createComponent(MenuContentBase, mergeProps({
    onOpenAutoFocus,
    onCloseAutoFocus,
    onFocusOutside,
    onKeyDown
  }, others));
}
var SELECTION_KEYS = ["Enter", " "];
var SUB_OPEN_KEYS = {
  open: (dir, orientation) => {
    if (dir === "ltr") {
      return [...SELECTION_KEYS, orientation === "horizontal" ? "ArrowRight" : "ArrowDown"];
    }
    return [...SELECTION_KEYS, orientation === "horizontal" ? "ArrowLeft" : "ArrowUp"];
  }
};
function MenuSubTrigger(props) {
  let ref;
  const rootContext = useMenuRootContext();
  const context = useMenuContext();
  const mergedProps = mergeDefaultProps({
    id: rootContext.generateId(`sub-trigger-${createUniqueId()}`)
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "id", "textValue", "disabled", "onPointerMove", "onPointerLeave", "onPointerDown", "onPointerUp", "onClick", "onKeyDown", "onMouseDown", "onFocus"]);
  let openTimeoutId = null;
  const clearOpenTimeout = () => {
    if (openTimeoutId) {
      window.clearTimeout(openTimeoutId);
    }
    openTimeoutId = null;
  };
  const {
    direction
  } = useLocale();
  const key = () => local.id;
  const parentSelectionManager = () => {
    const parentMenuContext = context.parentMenuContext();
    if (parentMenuContext == null) {
      throw new Error("[kobalte]: `Menu.SubTrigger` must be used within a `Menu.Sub` component");
    }
    return parentMenuContext.listState().selectionManager();
  };
  const collection = () => context.listState().collection();
  const isHighlighted = () => parentSelectionManager().focusedKey() === key();
  const selectableItem = createSelectableItem({
    key,
    selectionManager: parentSelectionManager,
    shouldSelectOnPressUp: true,
    allowsDifferentPressOrigin: true,
    disabled: () => local.disabled
  }, () => ref);
  const onClick = (e) => {
    callHandler(e, local.onClick);
    if (!context.isOpen() && !local.disabled) {
      context.open(true);
    }
  };
  const onPointerMove = (e) => {
    callHandler(e, local.onPointerMove);
    if (e.pointerType !== "mouse") {
      return;
    }
    const parentMenuContext = context.parentMenuContext();
    parentMenuContext?.onItemEnter(e);
    if (e.defaultPrevented) {
      return;
    }
    if (local.disabled) {
      parentMenuContext?.onItemLeave(e);
      return;
    }
    if (!context.isOpen() && !openTimeoutId) {
      context.parentMenuContext()?.setPointerGraceIntent(null);
      openTimeoutId = window.setTimeout(() => {
        context.open(false);
        clearOpenTimeout();
      }, 100);
    }
    parentMenuContext?.onItemEnter(e);
    if (!e.defaultPrevented) {
      if (context.listState().selectionManager().isFocused()) {
        context.listState().selectionManager().setFocused(false);
        context.listState().selectionManager().setFocusedKey(void 0);
      }
      focusWithoutScrolling(e.currentTarget);
      parentMenuContext?.listState().selectionManager().setFocused(true);
      parentMenuContext?.listState().selectionManager().setFocusedKey(key());
    }
  };
  const onPointerLeave = (e) => {
    callHandler(e, local.onPointerLeave);
    if (e.pointerType !== "mouse") {
      return;
    }
    clearOpenTimeout();
    const parentMenuContext = context.parentMenuContext();
    const contentEl = context.contentRef();
    if (contentEl) {
      parentMenuContext?.setPointerGraceIntent({
        area: getPointerGraceArea(context.currentPlacement(), e, contentEl),
        // Safe because sub menu always open "left" or "right".
        side: context.currentPlacement().split("-")[0]
      });
      window.clearTimeout(parentMenuContext?.pointerGraceTimeoutId());
      const pointerGraceTimeoutId = window.setTimeout(() => {
        parentMenuContext?.setPointerGraceIntent(null);
      }, 300);
      parentMenuContext?.setPointerGraceTimeoutId(pointerGraceTimeoutId);
    } else {
      parentMenuContext?.onTriggerLeave(e);
      if (e.defaultPrevented) {
        return;
      }
      parentMenuContext?.setPointerGraceIntent(null);
    }
    parentMenuContext?.onItemLeave(e);
  };
  const onKeyDown = (e) => {
    callHandler(e, local.onKeyDown);
    if (e.repeat) {
      return;
    }
    if (local.disabled) {
      return;
    }
    if (SUB_OPEN_KEYS.open(direction(), rootContext.orientation()).includes(e.key)) {
      e.stopPropagation();
      e.preventDefault();
      parentSelectionManager().setFocused(false);
      parentSelectionManager().setFocusedKey(void 0);
      if (!context.isOpen()) {
        context.open("first");
      }
      context.focusContent();
      context.listState().selectionManager().setFocused(true);
      context.listState().selectionManager().setFocusedKey(collection().getFirstKey());
    }
  };
  createEffect(() => {
    if (context.registerItemToParentDomCollection == null) {
      throw new Error("[kobalte]: `Menu.SubTrigger` must be used within a `Menu.Sub` component");
    }
    const unregister = context.registerItemToParentDomCollection({
      ref: () => ref,
      type: "item",
      key: key(),
      textValue: local.textValue ?? ref?.textContent ?? "",
      disabled: local.disabled ?? false
    });
    onCleanup(unregister);
  });
  createEffect(on(() => context.parentMenuContext()?.pointerGraceTimeoutId(), (pointerGraceTimer) => {
    onCleanup(() => {
      window.clearTimeout(pointerGraceTimer);
      context.parentMenuContext()?.setPointerGraceIntent(null);
    });
  }));
  createEffect(() => onCleanup(context.registerTriggerId(local.id)));
  onCleanup(() => {
    clearOpenTimeout();
  });
  return createComponent(Polymorphic, mergeProps({
    as: "div",
    ref(r$) {
      var _ref$5 = mergeRefs((el) => {
        context.setTriggerRef(el);
        ref = el;
      }, local.ref);
      typeof _ref$5 === "function" && _ref$5(r$);
    },
    get id() {
      return local.id;
    },
    role: "menuitem",
    get tabIndex() {
      return selectableItem.tabIndex();
    },
    "aria-haspopup": "true",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return createMemo(() => !!context.isOpen())() ? context.contentId() : void 0;
    },
    get ["aria-disabled"]() {
      return local.disabled;
    },
    get ["data-key"]() {
      return selectableItem.dataKey();
    },
    get ["data-highlighted"]() {
      return isHighlighted() ? "" : void 0;
    },
    get ["data-disabled"]() {
      return local.disabled ? "" : void 0;
    },
    get onPointerDown() {
      return composeEventHandlers([local.onPointerDown, selectableItem.onPointerDown]);
    },
    get onPointerUp() {
      return composeEventHandlers([local.onPointerUp, selectableItem.onPointerUp]);
    },
    get onClick() {
      return composeEventHandlers([onClick, selectableItem.onClick]);
    },
    get onKeyDown() {
      return composeEventHandlers([onKeyDown, selectableItem.onKeyDown]);
    },
    get onMouseDown() {
      return composeEventHandlers([local.onMouseDown, selectableItem.onMouseDown]);
    },
    get onFocus() {
      return composeEventHandlers([local.onFocus, selectableItem.onFocus]);
    },
    onPointerMove,
    onPointerLeave
  }, () => context.dataset(), others));
}
function MenuRoot(props) {
  const optionalMenubarContext = useOptionalMenubarContext();
  const defaultId = `menu-${createUniqueId()}`;
  const mergedProps = mergeDefaultProps({
    id: defaultId,
    modal: true
  }, props);
  const [local, others] = splitProps(mergedProps, ["id", "modal", "preventScroll", "forceMount", "open", "defaultOpen", "onOpenChange", "value", "orientation"]);
  const disclosureState = createDisclosureState({
    open: () => local.open,
    defaultOpen: () => local.defaultOpen,
    onOpenChange: (isOpen) => local.onOpenChange?.(isOpen)
  });
  const context = {
    isModal: () => local.modal ?? true,
    preventScroll: () => local.preventScroll ?? context.isModal(),
    forceMount: () => local.forceMount ?? false,
    generateId: createGenerateId(() => local.id),
    value: () => local.value,
    orientation: () => local.orientation ?? optionalMenubarContext?.orientation() ?? "horizontal"
  };
  return createComponent(MenuRootContext.Provider, {
    value: context,
    get children() {
      return createComponent(Menu, mergeProps({
        get open() {
          return disclosureState.isOpen();
        },
        get onOpenChange() {
          return disclosureState.setIsOpen;
        }
      }, others));
    }
  });
}

var separator_exports = {};
__export(separator_exports, {
  Root: () => SeparatorRoot,
  Separator: () => Separator
});
function SeparatorRoot(props) {
  let ref;
  const mergedProps = mergeDefaultProps({
    orientation: "horizontal"
  }, props);
  const [local, others] = splitProps(mergedProps, ["ref", "orientation"]);
  const tagName = createTagName(() => ref, () => "hr");
  return createComponent(Polymorphic, mergeProps({
    as: "hr",
    ref(r$) {
      var _ref$ = mergeRefs((el) => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get role() {
      return tagName() !== "hr" ? "separator" : void 0;
    },
    get ["aria-orientation"]() {
      return local.orientation === "vertical" ? "vertical" : void 0;
    },
    get ["data-orientation"]() {
      return local.orientation;
    }
  }, others));
}
var Separator = SeparatorRoot;

var dropdown_menu_exports = {};
__export(dropdown_menu_exports, {
  Arrow: () => PopperArrow,
  CheckboxItem: () => MenuCheckboxItem,
  Content: () => DropdownMenuContent,
  DropdownMenu: () => DropdownMenu,
  Group: () => MenuGroup,
  GroupLabel: () => MenuGroupLabel,
  Icon: () => MenuIcon,
  Item: () => MenuItem,
  ItemDescription: () => MenuItemDescription,
  ItemIndicator: () => MenuItemIndicator,
  ItemLabel: () => MenuItemLabel,
  Portal: () => MenuPortal,
  RadioGroup: () => MenuRadioGroup,
  RadioItem: () => MenuRadioItem,
  Root: () => DropdownMenuRoot,
  Separator: () => SeparatorRoot,
  Sub: () => MenuSub,
  SubContent: () => MenuSubContent,
  SubTrigger: () => MenuSubTrigger,
  Trigger: () => MenuTrigger
});
function DropdownMenuContent(props) {
  const rootContext = useMenuRootContext();
  const context = useMenuContext();
  const [local, others] = splitProps(props, ["onCloseAutoFocus", "onInteractOutside"]);
  let hasInteractedOutside = false;
  const onCloseAutoFocus = (e) => {
    local.onCloseAutoFocus?.(e);
    if (!hasInteractedOutside) {
      focusWithoutScrolling(context.triggerRef());
    }
    hasInteractedOutside = false;
    e.preventDefault();
  };
  const onInteractOutside = (e) => {
    local.onInteractOutside?.(e);
    if (!rootContext.isModal() || e.detail.isContextMenu) {
      hasInteractedOutside = true;
    }
  };
  return createComponent(MenuContent, mergeProps({
    onCloseAutoFocus,
    onInteractOutside
  }, others));
}
function DropdownMenuRoot(props) {
  const defaultId = `dropdownmenu-${createUniqueId()}`;
  const mergedProps = mergeDefaultProps({
    id: defaultId
  }, props);
  return createComponent(MenuRoot, mergedProps);
}
var DropdownMenu = Object.assign(DropdownMenuRoot, {
  Arrow: PopperArrow,
  CheckboxItem: MenuCheckboxItem,
  Content: DropdownMenuContent,
  Group: MenuGroup,
  GroupLabel: MenuGroupLabel,
  Icon: MenuIcon,
  Item: MenuItem,
  ItemDescription: MenuItemDescription,
  ItemIndicator: MenuItemIndicator,
  ItemLabel: MenuItemLabel,
  Portal: MenuPortal,
  RadioGroup: MenuRadioGroup,
  RadioItem: MenuRadioItem,
  Separator: SeparatorRoot,
  Sub: MenuSub,
  SubContent: MenuSubContent,
  SubTrigger: MenuSubTrigger,
  Trigger: MenuTrigger
});

function r(e){var t,f,n="";if("string"==typeof e||"number"==typeof e)n+=e;else if("object"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=" "),n+=f);}else for(f in e)e[f]&&(n&&(n+=" "),n+=f);return n}function clsx(){for(var e,t,f=0,n="",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=" "),n+=t);return n}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var build;
var hasRequiredBuild;

function requireBuild () {
	if (hasRequiredBuild) return build;
	hasRequiredBuild = 1;

	/**
	 * MIDI file format constants.
	 * @return {Constants}
	 */
	var Constants = {
	    VERSION: '3.1.1',
	    HEADER_CHUNK_TYPE: [0x4d, 0x54, 0x68, 0x64],
	    HEADER_CHUNK_LENGTH: [0x00, 0x00, 0x00, 0x06],
	    HEADER_CHUNK_FORMAT0: [0x00, 0x00],
	    HEADER_CHUNK_FORMAT1: [0x00, 0x01],
	    HEADER_CHUNK_DIVISION: [0x00, 0x80],
	    TRACK_CHUNK_TYPE: [0x4d, 0x54, 0x72, 0x6b],
	    META_EVENT_ID: 0xFF,
	    META_SMTPE_OFFSET: 0x54
	};

	// src/utils.ts
	var fillStr = (s, n) => Array(Math.abs(n) + 1).join(s);

	// src/named.ts
	function isNamed(src) {
	  return src !== null && typeof src === "object" && typeof src.name === "string" ? true : false;
	}

	// src/pitch.ts
	function isPitch(pitch) {
	  return pitch !== null && typeof pitch === "object" && typeof pitch.step === "number" && typeof pitch.alt === "number" ? true : false;
	}
	var FIFTHS = [0, 2, 4, -1, 1, 3, 5];
	var STEPS_TO_OCTS = FIFTHS.map(
	  (fifths) => Math.floor(fifths * 7 / 12)
	);
	function encode(pitch) {
	  const { step, alt, oct, dir = 1 } = pitch;
	  const f = FIFTHS[step] + 7 * alt;
	  if (oct === void 0) {
	    return [dir * f];
	  }
	  const o = oct - STEPS_TO_OCTS[step] - 4 * alt;
	  return [dir * f, dir * o];
	}

	// src/note.ts
	var NoNote = { empty: true, name: "", pc: "", acc: "" };
	var cache = /* @__PURE__ */ new Map();
	var stepToLetter = (step) => "CDEFGAB".charAt(step);
	var altToAcc = (alt) => alt < 0 ? fillStr("b", -alt) : fillStr("#", alt);
	var accToAlt = (acc) => acc[0] === "b" ? -acc.length : acc.length;
	function note(src) {
	  const stringSrc = JSON.stringify(src);
	  const cached = cache.get(stringSrc);
	  if (cached) {
	    return cached;
	  }
	  const value = typeof src === "string" ? parse(src) : isPitch(src) ? note(pitchName(src)) : isNamed(src) ? note(src.name) : NoNote;
	  cache.set(stringSrc, value);
	  return value;
	}
	var REGEX = /^([a-gA-G]?)(#{1,}|b{1,}|x{1,}|)(-?\d*)\s*(.*)$/;
	function tokenizeNote(str) {
	  const m = REGEX.exec(str);
	  return [m[1].toUpperCase(), m[2].replace(/x/g, "##"), m[3], m[4]];
	}
	var mod = (n, m) => (n % m + m) % m;
	var SEMI = [0, 2, 4, 5, 7, 9, 11];
	function parse(noteName) {
	  const tokens = tokenizeNote(noteName);
	  if (tokens[0] === "" || tokens[3] !== "") {
	    return NoNote;
	  }
	  const letter = tokens[0];
	  const acc = tokens[1];
	  const octStr = tokens[2];
	  const step = (letter.charCodeAt(0) + 3) % 7;
	  const alt = accToAlt(acc);
	  const oct = octStr.length ? +octStr : void 0;
	  const coord = encode({ step, alt, oct });
	  const name = letter + acc + octStr;
	  const pc = letter + acc;
	  const chroma = (SEMI[step] + alt + 120) % 12;
	  const height = oct === void 0 ? mod(SEMI[step] + alt, 12) - 12 * 99 : SEMI[step] + alt + 12 * (oct + 1);
	  const midi = height >= 0 && height <= 127 ? height : null;
	  const freq = oct === void 0 ? null : Math.pow(2, (height - 69) / 12) * 440;
	  return {
	    empty: false,
	    acc,
	    alt,
	    chroma,
	    coord,
	    freq,
	    height,
	    letter,
	    midi,
	    name,
	    oct,
	    pc,
	    step
	  };
	}
	function pitchName(props) {
	  const { step, alt, oct } = props;
	  const letter = stepToLetter(step);
	  if (!letter) {
	    return "";
	  }
	  const pc = letter + altToAcc(alt);
	  return oct || oct === 0 ? pc + oct : pc;
	}

	// index.ts
	function isMidi(arg) {
	  return +arg >= 0 && +arg <= 127;
	}
	function toMidi(note$1) {
	  if (isMidi(note$1)) {
	    return +note$1;
	  }
	  const n = note(note$1);
	  return n.empty ? null : n.midi;
	}

	/**
	 * Static utility functions used throughout the library.
	 */
	var Utils = /** @class */ (function () {
	    function Utils() {
	    }
	    /**
	     * Gets MidiWriterJS version number.
	     * @return {string}
	     */
	    Utils.version = function () {
	        return Constants.VERSION;
	    };
	    /**
	     * Convert a string to an array of bytes
	     * @param {string} string
	     * @return {array}
	     */
	    Utils.stringToBytes = function (string) {
	        return string.split('').map(function (char) { return char.charCodeAt(0); });
	    };
	    /**
	     * Checks if argument is a valid number.
	     * @param {*} n - Value to check
	     * @return {boolean}
	     */
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    Utils.isNumeric = function (n) {
	        return !isNaN(parseFloat(n)) && isFinite(n);
	    };
	    /**
	     * Returns the correct MIDI number for the specified pitch.
	     * Uses Tonal Midi - https://github.com/danigb/tonal/tree/master/packages/midi
	     * @param {(string|number)} pitch - 'C#4' or midi note code
	     * @param {string} middleC
	     * @return {number}
	     */
	    Utils.getPitch = function (pitch, middleC) {
	        if (middleC === void 0) { middleC = 'C4'; }
	        return 60 - toMidi(middleC) + toMidi(pitch);
	    };
	    /**
	     * Translates number of ticks to MIDI timestamp format, returning an array of
	     * hex strings with the time values. Midi has a very particular time to express time,
	     * take a good look at the spec before ever touching this function.
	     * Thanks to https://github.com/sergi/jsmidi
	     *
	     * @param {number} ticks - Number of ticks to be translated
	     * @return {array} - Bytes that form the MIDI time value
	     */
	    Utils.numberToVariableLength = function (ticks) {
	        ticks = Math.round(ticks);
	        var buffer = ticks & 0x7F;
	        // eslint-disable-next-line no-cond-assign
	        while (ticks = ticks >> 7) {
	            buffer <<= 8;
	            buffer |= ((ticks & 0x7F) | 0x80);
	        }
	        var bList = [];
	        // eslint-disable-next-line no-constant-condition
	        while (true) {
	            bList.push(buffer & 0xff);
	            if (buffer & 0x80)
	                buffer >>= 8;
	            else {
	                break;
	            }
	        }
	        return bList;
	    };
	    /**
	     * Counts number of bytes in string
	     * @param {string} s
	     * @return {number}
	     */
	    Utils.stringByteCount = function (s) {
	        return encodeURI(s).split(/%..|./).length - 1;
	    };
	    /**
	     * Get an int from an array of bytes.
	     * @param {array} bytes
	     * @return {number}
	     */
	    Utils.numberFromBytes = function (bytes) {
	        var hex = '';
	        var stringResult;
	        bytes.forEach(function (byte) {
	            stringResult = byte.toString(16);
	            // ensure string is 2 chars
	            if (stringResult.length == 1)
	                stringResult = "0" + stringResult;
	            hex += stringResult;
	        });
	        return parseInt(hex, 16);
	    };
	    /**
	     * Takes a number and splits it up into an array of bytes.  Can be padded by passing a number to bytesNeeded
	     * @param {number} number
	     * @param {number} bytesNeeded
	     * @return {array} - Array of bytes
	     */
	    Utils.numberToBytes = function (number, bytesNeeded) {
	        bytesNeeded = bytesNeeded || 1;
	        var hexString = number.toString(16);
	        if (hexString.length & 1) { // Make sure hex string is even number of chars
	            hexString = '0' + hexString;
	        }
	        // Split hex string into an array of two char elements
	        var hexArray = hexString.match(/.{2}/g);
	        // Now parse them out as integers
	        var intArray = hexArray.map(function (item) { return parseInt(item, 16); });
	        // Prepend empty bytes if we don't have enough
	        if (intArray.length < bytesNeeded) {
	            while (bytesNeeded - intArray.length > 0) {
	                intArray.unshift(0);
	            }
	        }
	        return intArray;
	    };
	    /**
	     * Converts value to array if needed.
	     * @param {any} value
	     * @return {array}
	     */
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    Utils.toArray = function (value) {
	        if (Array.isArray(value))
	            return value;
	        return [value];
	    };
	    /**
	     * Converts velocity to value 0-127
	     * @param {number} velocity - Velocity value 1-100
	     * @return {number}
	     */
	    Utils.convertVelocity = function (velocity) {
	        // Max passed value limited to 100
	        velocity = velocity > 100 ? 100 : velocity;
	        return Math.round(velocity / 100 * 127);
	    };
	    /**
	     * Gets the total number of ticks of a specified duration.
	     * Note: type=='note' defaults to quarter note, type==='rest' defaults to 0
	     * @param {(string|array)} duration
	     * @return {number}
	     */
	    Utils.getTickDuration = function (duration) {
	        if (Array.isArray(duration)) {
	            // Recursively execute this method for each item in the array and return the sum of tick durations.
	            return duration.map(function (value) {
	                return Utils.getTickDuration(value);
	            }).reduce(function (a, b) {
	                return a + b;
	            }, 0);
	        }
	        duration = duration.toString();
	        if (duration.toLowerCase().charAt(0) === 't') {
	            // If duration starts with 't' then the number that follows is an explicit tick count
	            var ticks = parseInt(duration.substring(1));
	            if (isNaN(ticks) || ticks < 0) {
	                throw new Error(duration + ' is not a valid duration.');
	            }
	            return ticks;
	        }
	        // Need to apply duration here.  Quarter note == Constants.HEADER_CHUNK_DIVISION
	        var quarterTicks = Utils.numberFromBytes(Constants.HEADER_CHUNK_DIVISION);
	        var tickDuration = quarterTicks * Utils.getDurationMultiplier(duration);
	        return Utils.getRoundedIfClose(tickDuration);
	    };
	    /**
	     * Due to rounding errors in JavaScript engines,
	     * it's safe to round when we're very close to the actual tick number
	     *
	     * @static
	     * @param {number} tick
	     * @return {number}
	     */
	    Utils.getRoundedIfClose = function (tick) {
	        var roundedTick = Math.round(tick);
	        return Math.abs(roundedTick - tick) < 0.000001 ? roundedTick : tick;
	    };
	    /**
	     * Due to low precision of MIDI,
	     * we need to keep track of rounding errors in deltas.
	     * This function will calculate the rounding error for a given duration.
	     *
	     * @static
	     * @param {number} tick
	     * @return {number}
	     */
	    Utils.getPrecisionLoss = function (tick) {
	        var roundedTick = Math.round(tick);
	        return roundedTick - tick;
	    };
	    /**
	     * Gets what to multiple ticks/quarter note by to get the specified duration.
	     * Note: type=='note' defaults to quarter note, type==='rest' defaults to 0
	     * @param {string} duration
	     * @return {number}
	     */
	    Utils.getDurationMultiplier = function (duration) {
	        // Need to apply duration here.
	        // Quarter note == Constants.HEADER_CHUNK_DIVISION ticks.
	        if (duration === '0')
	            return 0;
	        var match = duration.match(/^(?<dotted>d+)?(?<base>\d+)(?:t(?<tuplet>\d*))?/);
	        if (match) {
	            var base = Number(match.groups.base);
	            // 1 or any power of two:
	            var isValidBase = base === 1 || ((base & (base - 1)) === 0);
	            if (isValidBase) {
	                // how much faster or slower is this note compared to a quarter?
	                var ratio = base / 4;
	                var durationInQuarters = 1 / ratio;
	                var _a = match.groups, dotted = _a.dotted, tuplet = _a.tuplet;
	                if (dotted) {
	                    var thisManyDots = dotted.length;
	                    var divisor = Math.pow(2, thisManyDots);
	                    durationInQuarters = durationInQuarters + (durationInQuarters * ((divisor - 1) / divisor));
	                }
	                if (typeof tuplet === 'string') {
	                    var fitInto = durationInQuarters * 2;
	                    // default to triplet:
	                    var thisManyNotes = Number(tuplet || '3');
	                    durationInQuarters = fitInto / thisManyNotes;
	                }
	                return durationInQuarters;
	            }
	        }
	        throw new Error(duration + ' is not a valid duration.');
	    };
	    return Utils;
	}());

	/**
	 * Holds all data for a "controller change" MIDI event
	 * @param {object} fields {controllerNumber: integer, controllerValue: integer, delta: integer}
	 * @return {ControllerChangeEvent}
	 */
	var ControllerChangeEvent = /** @class */ (function () {
	    function ControllerChangeEvent(fields) {
	        this.channel = fields.channel - 1 || 0;
	        this.controllerValue = fields.controllerValue;
	        this.controllerNumber = fields.controllerNumber;
	        this.delta = fields.delta || 0x00;
	        this.name = 'ControllerChangeEvent';
	        this.status = 0xB0;
	        this.data = Utils.numberToVariableLength(fields.delta).concat(this.status | this.channel, this.controllerNumber, this.controllerValue);
	    }
	    return ControllerChangeEvent;
	}());

	/**
	 * Object representation of a tempo meta event.
	 * @param {object} fields {text: string, delta: integer}
	 * @return {CopyrightEvent}
	 */
	var CopyrightEvent = /** @class */ (function () {
	    function CopyrightEvent(fields) {
	        this.delta = fields.delta || 0x00;
	        this.name = 'CopyrightEvent';
	        this.text = fields.text;
	        this.type = 0x02;
	        var textBytes = Utils.stringToBytes(this.text);
	        // Start with zero time delta
	        this.data = Utils.numberToVariableLength(this.delta).concat(Constants.META_EVENT_ID, this.type, Utils.numberToVariableLength(textBytes.length), // Size
	        textBytes);
	    }
	    return CopyrightEvent;
	}());

	/**
	 * Object representation of a cue point meta event.
	 * @param {object} fields {text: string, delta: integer}
	 * @return {CuePointEvent}
	 */
	var CuePointEvent = /** @class */ (function () {
	    function CuePointEvent(fields) {
	        this.delta = fields.delta || 0x00;
	        this.name = 'CuePointEvent';
	        this.text = fields.text;
	        this.type = 0x07;
	        var textBytes = Utils.stringToBytes(this.text);
	        // Start with zero time delta
	        this.data = Utils.numberToVariableLength(this.delta).concat(Constants.META_EVENT_ID, this.type, Utils.numberToVariableLength(textBytes.length), // Size
	        textBytes);
	    }
	    return CuePointEvent;
	}());

	/**
	 * Object representation of a end track meta event.
	 * @param {object} fields {delta: integer}
	 * @return {EndTrackEvent}
	 */
	var EndTrackEvent = /** @class */ (function () {
	    function EndTrackEvent(fields) {
	        this.delta = (fields === null || fields === void 0 ? void 0 : fields.delta) || 0x00;
	        this.name = 'EndTrackEvent';
	        this.type = [0x2F, 0x00];
	        // Start with zero time delta
	        this.data = Utils.numberToVariableLength(this.delta).concat(Constants.META_EVENT_ID, this.type);
	    }
	    return EndTrackEvent;
	}());

	/**
	 * Object representation of an instrument name meta event.
	 * @param {object} fields {text: string, delta: integer}
	 * @return {InstrumentNameEvent}
	 */
	var InstrumentNameEvent = /** @class */ (function () {
	    function InstrumentNameEvent(fields) {
	        this.delta = fields.delta || 0x00;
	        this.name = 'InstrumentNameEvent';
	        this.text = fields.text;
	        this.type = 0x04;
	        var textBytes = Utils.stringToBytes(this.text);
	        // Start with zero time delta
	        this.data = Utils.numberToVariableLength(this.delta).concat(Constants.META_EVENT_ID, this.type, Utils.numberToVariableLength(textBytes.length), // Size
	        textBytes);
	    }
	    return InstrumentNameEvent;
	}());

	/**
	 * Object representation of a key signature meta event.
	 * @return {KeySignatureEvent}
	 */
	var KeySignatureEvent = /** @class */ (function () {
	    function KeySignatureEvent(sf, mi) {
	        this.name = 'KeySignatureEvent';
	        this.type = 0x59;
	        var mode = mi || 0;
	        sf = sf || 0;
	        //	Function called with string notation
	        if (typeof mi === 'undefined') {
	            var fifths = [
	                ['Cb', 'Gb', 'Db', 'Ab', 'Eb', 'Bb', 'F', 'C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#'],
	                ['ab', 'eb', 'bb', 'f', 'c', 'g', 'd', 'a', 'e', 'b', 'f#', 'c#', 'g#', 'd#', 'a#']
	            ];
	            var _sflen = sf.length;
	            var note = sf || 'C';
	            if (sf[0] === sf[0].toLowerCase())
	                mode = 1;
	            if (_sflen > 1) {
	                switch (sf.charAt(_sflen - 1)) {
	                    case 'm':
	                        mode = 1;
	                        note = sf.charAt(0).toLowerCase();
	                        note = note.concat(sf.substring(1, _sflen - 1));
	                        break;
	                    case '-':
	                        mode = 1;
	                        note = sf.charAt(0).toLowerCase();
	                        note = note.concat(sf.substring(1, _sflen - 1));
	                        break;
	                    case 'M':
	                        mode = 0;
	                        note = sf.charAt(0).toUpperCase();
	                        note = note.concat(sf.substring(1, _sflen - 1));
	                        break;
	                    case '+':
	                        mode = 0;
	                        note = sf.charAt(0).toUpperCase();
	                        note = note.concat(sf.substring(1, _sflen - 1));
	                        break;
	                }
	            }
	            var fifthindex = fifths[mode].indexOf(note);
	            sf = fifthindex === -1 ? 0 : fifthindex - 7;
	        }
	        // Start with zero time delta
	        this.data = Utils.numberToVariableLength(0x00).concat(Constants.META_EVENT_ID, this.type, [0x02], // Size
	        Utils.numberToBytes(sf, 1), // Number of sharp or flats ( < 0 flat; > 0 sharp)
	        Utils.numberToBytes(mode, 1));
	    }
	    return KeySignatureEvent;
	}());

	/**
	 * Object representation of a lyric meta event.
	 * @param {object} fields {text: string, delta: integer}
	 * @return {LyricEvent}
	 */
	var LyricEvent = /** @class */ (function () {
	    function LyricEvent(fields) {
	        this.delta = fields.delta || 0x00;
	        this.name = 'LyricEvent';
	        this.text = fields.text;
	        this.type = 0x05;
	        var textBytes = Utils.stringToBytes(this.text);
	        // Start with zero time delta
	        this.data = Utils.numberToVariableLength(this.delta).concat(Constants.META_EVENT_ID, this.type, Utils.numberToVariableLength(textBytes.length), // Size
	        textBytes);
	    }
	    return LyricEvent;
	}());

	/**
	 * Object representation of a marker meta event.
	 * @param {object} fields {text: string, delta: integer}
	 * @return {MarkerEvent}
	 */
	var MarkerEvent = /** @class */ (function () {
	    function MarkerEvent(fields) {
	        this.delta = fields.delta || 0x00;
	        this.name = 'MarkerEvent';
	        this.text = fields.text;
	        this.type = 0x06;
	        var textBytes = Utils.stringToBytes(this.text);
	        // Start with zero time delta
	        this.data = Utils.numberToVariableLength(this.delta).concat(Constants.META_EVENT_ID, this.type, Utils.numberToVariableLength(textBytes.length), // Size
	        textBytes);
	    }
	    return MarkerEvent;
	}());

	/**
	 * Holds all data for a "note on" MIDI event
	 * @param {object} fields {data: []}
	 * @return {NoteOnEvent}
	 */
	var NoteOnEvent = /** @class */ (function () {
	    function NoteOnEvent(fields) {
	        this.name = 'NoteOnEvent';
	        this.channel = fields.channel || 1;
	        this.pitch = fields.pitch;
	        this.wait = fields.wait || 0;
	        this.velocity = fields.velocity || 50;
	        this.tick = fields.tick || null;
	        this.delta = null;
	        this.data = fields.data;
	        this.status = 0x90;
	    }
	    /**
	     * Builds int array for this event.
	     * @param {Track} track - parent track
	     * @return {NoteOnEvent}
	     */
	    NoteOnEvent.prototype.buildData = function (track, precisionDelta, options) {
	        if (options === void 0) { options = {}; }
	        this.data = [];
	        // Explicitly defined startTick event
	        if (this.tick) {
	            this.tick = Utils.getRoundedIfClose(this.tick);
	            // If this is the first event in the track then use event's starting tick as delta.
	            if (track.tickPointer == 0) {
	                this.delta = this.tick;
	            }
	        }
	        else {
	            this.delta = Utils.getTickDuration(this.wait);
	            this.tick = Utils.getRoundedIfClose(track.tickPointer + this.delta);
	        }
	        this.deltaWithPrecisionCorrection = Utils.getRoundedIfClose(this.delta - precisionDelta);
	        this.data = Utils.numberToVariableLength(this.deltaWithPrecisionCorrection)
	            .concat(this.status | this.channel - 1, Utils.getPitch(this.pitch, options.middleC), Utils.convertVelocity(this.velocity));
	        return this;
	    };
	    return NoteOnEvent;
	}());

	/**
	 * Holds all data for a "note off" MIDI event
	 * @param {object} fields {data: []}
	 * @return {NoteOffEvent}
	 */
	var NoteOffEvent = /** @class */ (function () {
	    function NoteOffEvent(fields) {
	        this.name = 'NoteOffEvent';
	        this.channel = fields.channel || 1;
	        this.pitch = fields.pitch;
	        this.velocity = fields.velocity || 50;
	        this.tick = fields.tick || null;
	        this.data = fields.data;
	        this.delta = fields.delta || Utils.getTickDuration(fields.duration);
	        this.status = 0x80;
	    }
	    /**
	     * Builds int array for this event.
	     * @param {Track} track - parent track
	     * @return {NoteOffEvent}
	     */
	    NoteOffEvent.prototype.buildData = function (track, precisionDelta, options) {
	        if (options === void 0) { options = {}; }
	        if (this.tick === null) {
	            this.tick = Utils.getRoundedIfClose(this.delta + track.tickPointer);
	        }
	        this.deltaWithPrecisionCorrection = Utils.getRoundedIfClose(this.delta - precisionDelta);
	        this.data = Utils.numberToVariableLength(this.deltaWithPrecisionCorrection)
	            .concat(this.status | this.channel - 1, Utils.getPitch(this.pitch, options.middleC), Utils.convertVelocity(this.velocity));
	        return this;
	    };
	    return NoteOffEvent;
	}());

	/**
	 * Wrapper for noteOnEvent/noteOffEvent objects that builds both events.
	 * @param {object} fields - {pitch: '[C4]', duration: '4', wait: '4', velocity: 1-100}
	 * @return {NoteEvent}
	 */
	var NoteEvent = /** @class */ (function () {
	    function NoteEvent(fields) {
	        this.data = [];
	        this.name = 'NoteEvent';
	        this.pitch = Utils.toArray(fields.pitch);
	        this.channel = fields.channel || 1;
	        this.duration = fields.duration || '4';
	        this.grace = fields.grace;
	        this.repeat = fields.repeat || 1;
	        this.sequential = fields.sequential || false;
	        this.tick = fields.startTick || fields.tick || null;
	        this.velocity = fields.velocity || 50;
	        this.wait = fields.wait || 0;
	        this.tickDuration = Utils.getTickDuration(this.duration);
	        this.restDuration = Utils.getTickDuration(this.wait);
	        this.events = []; // Hold actual NoteOn/NoteOff events
	    }
	    /**
	     * Builds int array for this event.
	     * @return {NoteEvent}
	     */
	    NoteEvent.prototype.buildData = function () {
	        var _this = this;
	        // Reset data array
	        this.data = [];
	        // Apply grace note(s) and subtract ticks (currently 1 tick per grace note) from tickDuration so net value is the same
	        if (this.grace) {
	            var graceDuration_1 = 1;
	            this.grace = Utils.toArray(this.grace);
	            this.grace.forEach(function () {
	                var noteEvent = new NoteEvent({ pitch: _this.grace, duration: 'T' + graceDuration_1 });
	                _this.data = _this.data.concat(noteEvent.data);
	            });
	        }
	        // fields.pitch could be an array of pitches.
	        // If so create note events for each and apply the same duration.
	        // By default this is a chord if it's an array of notes that requires one NoteOnEvent.
	        // If this.sequential === true then it's a sequential string of notes that requires separate NoteOnEvents.
	        if (!this.sequential) {
	            // Handle repeat
	            for (var j = 0; j < this.repeat; j++) {
	                // Note on
	                this.pitch.forEach(function (p, i) {
	                    var noteOnNew;
	                    if (i == 0) {
	                        noteOnNew = new NoteOnEvent({
	                            channel: _this.channel,
	                            wait: _this.wait,
	                            delta: Utils.getTickDuration(_this.wait),
	                            velocity: _this.velocity,
	                            pitch: p,
	                            tick: _this.tick,
	                        });
	                    }
	                    else {
	                        // Running status (can ommit the note on status)
	                        //noteOn = new NoteOnEvent({data: [0, Utils.getPitch(p), Utils.convertVelocity(this.velocity)]});
	                        noteOnNew = new NoteOnEvent({
	                            channel: _this.channel,
	                            wait: 0,
	                            delta: 0,
	                            velocity: _this.velocity,
	                            pitch: p,
	                            tick: _this.tick,
	                        });
	                    }
	                    _this.events.push(noteOnNew);
	                });
	                // Note off
	                this.pitch.forEach(function (p, i) {
	                    var noteOffNew;
	                    if (i == 0) {
	                        //noteOff = new NoteOffEvent({data: Utils.numberToVariableLength(tickDuration).concat(this.getNoteOffStatus(), Utils.getPitch(p), Utils.convertVelocity(this.velocity))});
	                        noteOffNew = new NoteOffEvent({
	                            channel: _this.channel,
	                            duration: _this.duration,
	                            velocity: _this.velocity,
	                            pitch: p,
	                            tick: _this.tick !== null ? Utils.getTickDuration(_this.duration) + _this.tick : null,
	                        });
	                    }
	                    else {
	                        // Running status (can omit the note off status)
	                        //noteOff = new NoteOffEvent({data: [0, Utils.getPitch(p), Utils.convertVelocity(this.velocity)]});
	                        noteOffNew = new NoteOffEvent({
	                            channel: _this.channel,
	                            duration: 0,
	                            velocity: _this.velocity,
	                            pitch: p,
	                            tick: _this.tick !== null ? Utils.getTickDuration(_this.duration) + _this.tick : null,
	                        });
	                    }
	                    _this.events.push(noteOffNew);
	                });
	            }
	        }
	        else {
	            // Handle repeat
	            for (var j = 0; j < this.repeat; j++) {
	                this.pitch.forEach(function (p, i) {
	                    var noteOnNew = new NoteOnEvent({
	                        channel: _this.channel,
	                        wait: (i > 0 ? 0 : _this.wait),
	                        delta: (i > 0 ? 0 : Utils.getTickDuration(_this.wait)),
	                        velocity: _this.velocity,
	                        pitch: p,
	                        tick: _this.tick,
	                    });
	                    var noteOffNew = new NoteOffEvent({
	                        channel: _this.channel,
	                        duration: _this.duration,
	                        velocity: _this.velocity,
	                        pitch: p,
	                    });
	                    _this.events.push(noteOnNew, noteOffNew);
	                });
	            }
	        }
	        return this;
	    };
	    return NoteEvent;
	}());

	/**
	 * Holds all data for a "Pitch Bend" MIDI event
	 * [ -1.0, 0, 1.0 ] ->  [ 0, 8192, 16383]
	 * @param {object} fields { bend : float, channel : int, delta: int }
	 * @return {PitchBendEvent}
	 */
	var PitchBendEvent = /** @class */ (function () {
	    function PitchBendEvent(fields) {
	        this.channel = fields.channel || 0;
	        this.delta = fields.delta || 0x00;
	        this.name = 'PitchBendEvent';
	        this.status = 0xE0;
	        var bend14 = this.scale14bits(fields.bend);
	        var lsbValue = bend14 & 0x7f;
	        var msbValue = (bend14 >> 7) & 0x7f;
	        this.data = Utils.numberToVariableLength(this.delta).concat(this.status | this.channel, lsbValue, msbValue);
	    }
	    PitchBendEvent.prototype.scale14bits = function (zeroOne) {
	        if (zeroOne <= 0) {
	            return Math.floor(16384 * (zeroOne + 1) / 2);
	        }
	        return Math.floor(16383 * (zeroOne + 1) / 2);
	    };
	    return PitchBendEvent;
	}());

	/**
	 * Holds all data for a "program change" MIDI event
	 * @param {object} fields {instrument: integer, delta: integer}
	 * @return {ProgramChangeEvent}
	 */
	var ProgramChangeEvent = /** @class */ (function () {
	    function ProgramChangeEvent(fields) {
	        this.channel = fields.channel || 0;
	        this.delta = fields.delta || 0x00;
	        this.instrument = fields.instrument;
	        this.status = 0xC0;
	        this.name = 'ProgramChangeEvent';
	        // delta time defaults to 0.
	        this.data = Utils.numberToVariableLength(this.delta).concat(this.status | this.channel, this.instrument);
	    }
	    return ProgramChangeEvent;
	}());

	/**
	 * Object representation of a tempo meta event.
	 * @param {object} fields {bpm: integer, delta: integer}
	 * @return {TempoEvent}
	 */
	var TempoEvent = /** @class */ (function () {
	    function TempoEvent(fields) {
	        this.bpm = fields.bpm;
	        this.delta = fields.delta || 0x00;
	        this.tick = fields.tick;
	        this.name = 'TempoEvent';
	        this.type = 0x51;
	        var tempo = Math.round(60000000 / this.bpm);
	        // Start with zero time delta
	        this.data = Utils.numberToVariableLength(this.delta).concat(Constants.META_EVENT_ID, this.type, [0x03], // Size
	        Utils.numberToBytes(tempo, 3));
	    }
	    return TempoEvent;
	}());

	/**
	 * Object representation of a tempo meta event.
	 * @param {object} fields {text: string, delta: integer}
	 * @return {TextEvent}
	 */
	var TextEvent = /** @class */ (function () {
	    function TextEvent(fields) {
	        this.delta = fields.delta || 0x00;
	        this.text = fields.text;
	        this.name = 'TextEvent';
	        this.type = 0x01;
	        var textBytes = Utils.stringToBytes(this.text);
	        // Start with zero time delta
	        this.data = Utils.numberToVariableLength(fields.delta).concat(Constants.META_EVENT_ID, this.type, Utils.numberToVariableLength(textBytes.length), // Size
	        textBytes);
	    }
	    return TextEvent;
	}());

	/**
	 * Object representation of a time signature meta event.
	 * @return {TimeSignatureEvent}
	 */
	var TimeSignatureEvent = /** @class */ (function () {
	    function TimeSignatureEvent(numerator, denominator, midiclockspertick, notespermidiclock) {
	        this.name = 'TimeSignatureEvent';
	        this.type = 0x58;
	        // Start with zero time delta
	        this.data = Utils.numberToVariableLength(0x00).concat(Constants.META_EVENT_ID, this.type, [0x04], // Size
	        Utils.numberToBytes(numerator, 1), // Numerator, 1 bytes
	        Utils.numberToBytes(Math.log2(denominator), 1), // Denominator is expressed as pow of 2, 1 bytes
	        Utils.numberToBytes(midiclockspertick || 24, 1), // MIDI Clocks per tick, 1 bytes
	        Utils.numberToBytes(notespermidiclock || 8, 1));
	    }
	    return TimeSignatureEvent;
	}());

	/**
	 * Object representation of a tempo meta event.
	 * @param {object} fields {text: string, delta: integer}
	 * @return {TrackNameEvent}
	 */
	var TrackNameEvent = /** @class */ (function () {
	    function TrackNameEvent(fields) {
	        this.delta = fields.delta || 0x00;
	        this.name = 'TrackNameEvent';
	        this.text = fields.text;
	        this.type = 0x03;
	        var textBytes = Utils.stringToBytes(this.text);
	        // Start with zero time delta
	        this.data = Utils.numberToVariableLength(this.delta).concat(Constants.META_EVENT_ID, this.type, Utils.numberToVariableLength(textBytes.length), // Size
	        textBytes);
	    }
	    return TrackNameEvent;
	}());

	/**
	 * Holds all data for a track.
	 * @param {object} fields {type: number, data: array, size: array, events: array}
	 * @return {Track}
	 */
	var Track = /** @class */ (function () {
	    function Track() {
	        this.type = Constants.TRACK_CHUNK_TYPE;
	        this.data = [];
	        this.size = [];
	        this.events = [];
	        this.explicitTickEvents = [];
	        // If there are any events with an explicit tick defined then we will create a "sub" track for those
	        // and merge them in and the end.
	        this.tickPointer = 0; // Each time an event is added this will increase
	    }
	    /**
	     * Adds any event type to the track.
	     * Events without a specific startTick property are assumed to be added in order of how they should output.
	     * Events with a specific startTick property are set aside for now will be merged in during build process.
	     *
	     * TODO: Don't put startTick events in their own array.  Just lump everything together and sort it out during buildData();
	     * @param {(NoteEvent|ProgramChangeEvent)} events - Event object or array of Event objects.
	     * @param {Function} mapFunction - Callback which can be used to apply specific properties to all events.
	     * @return {Track}
	     */
	    Track.prototype.addEvent = function (events, mapFunction) {
	        var _this = this;
	        Utils.toArray(events).forEach(function (event, i) {
	            if (event instanceof NoteEvent) {
	                // Handle map function if provided
	                if (typeof mapFunction === 'function') {
	                    var properties = mapFunction(i, event);
	                    if (typeof properties === 'object') {
	                        Object.assign(event, properties);
	                    }
	                }
	                // If this note event has an explicit startTick then we need to set aside for now
	                if (event.tick !== null) {
	                    _this.explicitTickEvents.push(event);
	                }
	                else {
	                    // Push each on/off event to track's event stack
	                    event.buildData().events.forEach(function (e) { return _this.events.push(e); });
	                }
	            }
	            else {
	                _this.events.push(event);
	            }
	        });
	        return this;
	    };
	    /**
	     * Builds int array of all events.
	     * @param {object} options
	     * @return {Track}
	     */
	    Track.prototype.buildData = function (options) {
	        var _this = this;
	        if (options === void 0) { options = {}; }
	        // Reset
	        this.data = [];
	        this.size = [];
	        this.tickPointer = 0;
	        var precisionLoss = 0;
	        this.events.forEach(function (event) {
	            // Build event & add to total tick duration
	            if (event instanceof NoteOnEvent || event instanceof NoteOffEvent) {
	                var built = event.buildData(_this, precisionLoss, options);
	                precisionLoss = Utils.getPrecisionLoss(event.deltaWithPrecisionCorrection || 0);
	                _this.data = _this.data.concat(built.data);
	                _this.tickPointer = Utils.getRoundedIfClose(event.tick);
	            }
	            else if (event instanceof TempoEvent) {
	                _this.tickPointer = Utils.getRoundedIfClose(event.tick);
	                _this.data = _this.data.concat(event.data);
	            }
	            else {
	                _this.data = _this.data.concat(event.data);
	            }
	        });
	        this.mergeExplicitTickEvents();
	        // If the last event isn't EndTrackEvent, then tack it onto the data.
	        if (!this.events.length || !(this.events[this.events.length - 1] instanceof EndTrackEvent)) {
	            this.data = this.data.concat((new EndTrackEvent).data);
	        }
	        this.size = Utils.numberToBytes(this.data.length, 4); // 4 bytes long
	        return this;
	    };
	    Track.prototype.mergeExplicitTickEvents = function () {
	        var _this = this;
	        if (!this.explicitTickEvents.length)
	            return;
	        // First sort asc list of events by startTick
	        this.explicitTickEvents.sort(function (a, b) { return a.tick - b.tick; });
	        // Now this.explicitTickEvents is in correct order, and so is this.events naturally.
	        // For each explicit tick event, splice it into the main list of events and
	        // adjust the delta on the following events so they still play normally.
	        this.explicitTickEvents.forEach(function (noteEvent) {
	            // Convert NoteEvent to it's respective NoteOn/NoteOff events
	            // Note that as we splice in events the delta for the NoteOff ones will
	            // Need to change based on what comes before them after the splice.
	            noteEvent.buildData().events.forEach(function (e) { return e.buildData(_this); });
	            // Merge each event individually into this track's event list.
	            noteEvent.events.forEach(function (event) { return _this.mergeSingleEvent(event); });
	        });
	        // Hacky way to rebuild track with newly spliced events.  Need better solution.
	        this.explicitTickEvents = [];
	        this.buildData();
	    };
	    /**
	     * Merges another track's events with this track.
	     * @param {Track} track
	     * @return {Track}
	     */
	    Track.prototype.mergeTrack = function (track) {
	        var _this = this;
	        // First build this track to populate each event's tick property
	        this.buildData();
	        // Then build track to be merged so that tick property is populated on all events & merge each event.
	        track.buildData().events.forEach(function (event) { return _this.mergeSingleEvent(event); });
	        return this;
	    };
	    /**
	     * Merges a single event into this track's list of events based on event.tick property.
	     * @param {AbstractEvent} - event
	     * @return {Track}
	     */
	    Track.prototype.mergeSingleEvent = function (event) {
	        // There are no events yet, so just add it in.
	        if (!this.events.length) {
	            this.addEvent(event);
	            return;
	        }
	        // Find index of existing event we need to follow with
	        var lastEventIndex;
	        for (var i = 0; i < this.events.length; i++) {
	            if (this.events[i].tick > event.tick)
	                break;
	            lastEventIndex = i;
	        }
	        var splicedEventIndex = lastEventIndex + 1;
	        // Need to adjust the delta of this event to ensure it falls on the correct tick.
	        event.delta = event.tick - this.events[lastEventIndex].tick;
	        // Splice this event at lastEventIndex + 1
	        this.events.splice(splicedEventIndex, 0, event);
	        // Now adjust delta of all following events
	        for (var i = splicedEventIndex + 1; i < this.events.length; i++) {
	            // Since each existing event should have a tick value at this point we just need to
	            // adjust delta to that the event still falls on the correct tick.
	            this.events[i].delta = this.events[i].tick - this.events[i - 1].tick;
	        }
	    };
	    /**
	     * Removes all events matching specified type.
	     * @param {string} eventName - Event type
	     * @return {Track}
	     */
	    Track.prototype.removeEventsByName = function (eventName) {
	        var _this = this;
	        this.events.forEach(function (event, index) {
	            if (event.name === eventName) {
	                _this.events.splice(index, 1);
	            }
	        });
	        return this;
	    };
	    /**
	     * Sets tempo of the MIDI file.
	     * @param {number} bpm - Tempo in beats per minute.
	     * @param {number} tick - Start tick.
	     * @return {Track}
	     */
	    Track.prototype.setTempo = function (bpm, tick) {
	        if (tick === void 0) { tick = 0; }
	        return this.addEvent(new TempoEvent({ bpm: bpm, tick: tick }));
	    };
	    /**
	     * Sets time signature.
	     * @param {number} numerator - Top number of the time signature.
	     * @param {number} denominator - Bottom number of the time signature.
	     * @param {number} midiclockspertick - Defaults to 24.
	     * @param {number} notespermidiclock - Defaults to 8.
	     * @return {Track}
	     */
	    Track.prototype.setTimeSignature = function (numerator, denominator, midiclockspertick, notespermidiclock) {
	        return this.addEvent(new TimeSignatureEvent(numerator, denominator, midiclockspertick, notespermidiclock));
	    };
	    /**
	     * Sets key signature.
	     * @param {*} sf -
	     * @param {*} mi -
	     * @return {Track}
	     */
	    Track.prototype.setKeySignature = function (sf, mi) {
	        return this.addEvent(new KeySignatureEvent(sf, mi));
	    };
	    /**
	     * Adds text to MIDI file.
	     * @param {string} text - Text to add.
	     * @return {Track}
	     */
	    Track.prototype.addText = function (text) {
	        return this.addEvent(new TextEvent({ text: text }));
	    };
	    /**
	     * Adds copyright to MIDI file.
	     * @param {string} text - Text of copyright line.
	     * @return {Track}
	     */
	    Track.prototype.addCopyright = function (text) {
	        return this.addEvent(new CopyrightEvent({ text: text }));
	    };
	    /**
	     * Adds Sequence/Track Name.
	     * @param {string} text - Text of track name.
	     * @return {Track}
	     */
	    Track.prototype.addTrackName = function (text) {
	        return this.addEvent(new TrackNameEvent({ text: text }));
	    };
	    /**
	     * Sets instrument name of track.
	     * @param {string} text - Name of instrument.
	     * @return {Track}
	     */
	    Track.prototype.addInstrumentName = function (text) {
	        return this.addEvent(new InstrumentNameEvent({ text: text }));
	    };
	    /**
	     * Adds marker to MIDI file.
	     * @param {string} text - Marker text.
	     * @return {Track}
	     */
	    Track.prototype.addMarker = function (text) {
	        return this.addEvent(new MarkerEvent({ text: text }));
	    };
	    /**
	     * Adds cue point to MIDI file.
	     * @param {string} text - Text of cue point.
	     * @return {Track}
	     */
	    Track.prototype.addCuePoint = function (text) {
	        return this.addEvent(new CuePointEvent({ text: text }));
	    };
	    /**
	     * Adds lyric to MIDI file.
	     * @param {string} text - Lyric text to add.
	     * @return {Track}
	     */
	    Track.prototype.addLyric = function (text) {
	        return this.addEvent(new LyricEvent({ text: text }));
	    };
	    /**
	     * Channel mode messages
	     * @return {Track}
	     */
	    Track.prototype.polyModeOn = function () {
	        var event = new NoteOnEvent({ data: [0x00, 0xB0, 0x7E, 0x00] });
	        return this.addEvent(event);
	    };
	    /**
	     * Sets a pitch bend.
	     * @param {float} bend - Bend value ranging [-1,1], zero meaning no bend.
	     * @return {Track}
	     */
	    Track.prototype.setPitchBend = function (bend) {
	        return this.addEvent(new PitchBendEvent({ bend: bend }));
	    };
	    /**
	     * Adds a controller change event
	     * @param {number} number - Control number.
	     * @param {number} value - Control value.
	     * @param {number} channel - Channel to send controller change event on (1-based).
	     * @param {number} delta - Track tick offset for cc event.
	     * @return {Track}
	     */
	    Track.prototype.controllerChange = function (number, value, channel, delta) {
	        return this.addEvent(new ControllerChangeEvent({ controllerNumber: number, controllerValue: value, channel: channel, delta: delta }));
	    };
	    return Track;
	}());

	var VexFlow = /** @class */ (function () {
	    function VexFlow() {
	    }
	    /**
	     * Support for converting VexFlow voice into MidiWriterJS track
	     * @return MidiWriter.Track object
	     */
	    VexFlow.prototype.trackFromVoice = function (voice, options) {
	        var _this = this;
	        if (options === void 0) { options = { addRenderedAccidentals: false }; }
	        var track = new Track;
	        var wait = [];
	        voice.tickables.forEach(function (tickable) {
	            if (tickable.noteType === 'n') {
	                track.addEvent(new NoteEvent({
	                    pitch: tickable.keys.map(function (pitch, index) { return _this.convertPitch(pitch, index, tickable, options.addRenderedAccidentals); }),
	                    duration: _this.convertDuration(tickable),
	                    wait: wait
	                }));
	                // reset wait
	                wait = [];
	            }
	            else if (tickable.noteType === 'r') {
	                // move on to the next tickable and add this to the stack
	                // of the `wait` property for the next note event
	                wait.push(_this.convertDuration(tickable));
	            }
	        });
	        // There may be outstanding rests at the end of the track,
	        // pad with a ghost note (zero duration and velocity), just to capture the wait.
	        if (wait.length > 0) {
	            track.addEvent(new NoteEvent({ pitch: '[c4]', duration: '0', wait: wait, velocity: '0' }));
	        }
	        return track;
	    };
	    /**
	     * Converts VexFlow pitch syntax to MidiWriterJS syntax
	     * @param pitch string
	     * @param index pitch index
	     * @param note struct from Vexflow
	     * @param addRenderedAccidentals adds Vexflow rendered accidentals
	     */
	    VexFlow.prototype.convertPitch = function (pitch, index, note, addRenderedAccidentals) {
	        var _a;
	        if (addRenderedAccidentals === void 0) { addRenderedAccidentals = false; }
	        // Splits note name from octave
	        var pitchParts = pitch.split('/');
	        // Retrieves accidentals from pitch
	        // Removes natural accidentals since they are not accepted in Tonal Midi
	        var accidentals = pitchParts[0].substring(1).replace('n', '');
	        if (addRenderedAccidentals) {
	            (_a = note.getAccidentals()) === null || _a === void 0 ? void 0 : _a.forEach(function (accidental) {
	                if (accidental.index === index) {
	                    if (accidental.type === 'n') {
	                        accidentals = '';
	                    }
	                    else {
	                        accidentals += accidental.type;
	                    }
	                }
	            });
	        }
	        return pitchParts[0][0] + accidentals + pitchParts[1];
	    };
	    /**
	     * Converts VexFlow duration syntax to MidiWriterJS syntax
	     * @param note struct from VexFlow
	     */
	    VexFlow.prototype.convertDuration = function (note) {
	        return 'd'.repeat(note.dots) + this.convertBaseDuration(note.duration) + (note.tuplet ? 't' + note.tuplet.num_notes : '');
	    };
	    /**
	     * Converts VexFlow base duration syntax to MidiWriterJS syntax
	     * @param duration Vexflow duration
	     * @returns MidiWriterJS duration
	     */
	    VexFlow.prototype.convertBaseDuration = function (duration) {
	        switch (duration) {
	            case 'w':
	                return '1';
	            case 'h':
	                return '2';
	            case 'q':
	                return '4';
	            default:
	                return duration;
	        }
	    };
	    return VexFlow;
	}());

	/**
	 * Object representation of a header chunk section of a MIDI file.
	 * @param {number} numberOfTracks - Number of tracks
	 * @return {Header}
	 */
	var Header = /** @class */ (function () {
	    function Header(numberOfTracks) {
	        this.type = Constants.HEADER_CHUNK_TYPE;
	        var trackType = numberOfTracks > 1 ? Constants.HEADER_CHUNK_FORMAT1 : Constants.HEADER_CHUNK_FORMAT0;
	        this.data = trackType.concat(Utils.numberToBytes(numberOfTracks, 2), // two bytes long,
	        Constants.HEADER_CHUNK_DIVISION);
	        this.size = [0, 0, 0, this.data.length];
	    }
	    return Header;
	}());

	/**
	 * Object that puts together tracks and provides methods for file output.
	 * @param {array|Track} tracks - A single {Track} object or an array of {Track} objects.
	 * @param {object} options - {middleC: 'C4'}
	 * @return {Writer}
	 */
	var Writer = /** @class */ (function () {
	    function Writer(tracks, options) {
	        if (options === void 0) { options = {}; }
	        // Ensure tracks is an array
	        this.tracks = Utils.toArray(tracks);
	        this.options = options;
	    }
	    /**
	     * Builds array of data from chunkschunks.
	     * @return {array}
	     */
	    Writer.prototype.buildData = function () {
	        var _this = this;
	        var data = [];
	        data.push(new Header(this.tracks.length));
	        // For each track add final end of track event and build data
	        this.tracks.forEach(function (track) {
	            data.push(track.buildData(_this.options));
	        });
	        return data;
	    };
	    /**
	     * Builds the file into a Uint8Array
	     * @return {Uint8Array}
	     */
	    Writer.prototype.buildFile = function () {
	        var build = [];
	        // Data consists of chunks which consists of data
	        this.buildData().forEach(function (d) { return build = build.concat(d.type, d.size, d.data); });
	        return new Uint8Array(build);
	    };
	    /**
	     * Convert file buffer to a base64 string.  Different methods depending on if browser or node.
	     * @return {string}
	     */
	    Writer.prototype.base64 = function () {
	        if (typeof btoa === 'function') {
	            var binary = '';
	            var bytes = this.buildFile();
	            var len = bytes.byteLength;
	            for (var i = 0; i < len; i++) {
	                binary += String.fromCharCode(bytes[i]);
	            }
	            return btoa(binary);
	        }
	        return Buffer.from(this.buildFile()).toString('base64');
	    };
	    /**
	     * Get the data URI.
	     * @return {string}
	     */
	    Writer.prototype.dataUri = function () {
	        return 'data:audio/midi;base64,' + this.base64();
	    };
	    /**
	     * Set option on instantiated Writer.
	     * @param {string} key
	     * @param {any} value
	     * @return {Writer}
	     */
	    Writer.prototype.setOption = function (key, value) {
	        this.options[key] = value;
	        return this;
	    };
	    /**
	     * Output to stdout
	     * @return {string}
	     */
	    Writer.prototype.stdout = function () {
	        return process.stdout.write(Buffer.from(this.buildFile()));
	    };
	    return Writer;
	}());

	var main = {
	    Constants: Constants,
	    ControllerChangeEvent: ControllerChangeEvent,
	    CopyrightEvent: CopyrightEvent,
	    CuePointEvent: CuePointEvent,
	    EndTrackEvent: EndTrackEvent,
	    InstrumentNameEvent: InstrumentNameEvent,
	    KeySignatureEvent: KeySignatureEvent,
	    LyricEvent: LyricEvent,
	    MarkerEvent: MarkerEvent,
	    NoteOnEvent: NoteOnEvent,
	    NoteOffEvent: NoteOffEvent,
	    NoteEvent: NoteEvent,
	    PitchBendEvent: PitchBendEvent,
	    ProgramChangeEvent: ProgramChangeEvent,
	    TempoEvent: TempoEvent,
	    TextEvent: TextEvent,
	    TimeSignatureEvent: TimeSignatureEvent,
	    Track: Track,
	    TrackNameEvent: TrackNameEvent,
	    Utils: Utils,
	    VexFlow: VexFlow,
	    Writer: Writer
	};

	build = main;
	return build;
}

var buildExports = requireBuild();
const MidiWriter = /*@__PURE__*/getDefaultExportFromCjs(buildExports);

/* IMPORT */
/* MAIN */
const WebCrypto = crypto;

/* IMPORT */
function makeRNG(constructor) {
    let pool;
    let cursor = 0;
    return () => {
        if (!pool || cursor === pool.length) { // Replenishing pool
            pool = new constructor(65536 / (constructor.BYTES_PER_ELEMENT * 8));
            cursor = 0;
            WebCrypto.getRandomValues(pool);
        }
        return pool[cursor++];
    };
}
function makeBitRNG(rng, bits) {
    let pool = 0;
    let cursor = bits;
    return () => {
        if (cursor === bits) { // Replenishing pool
            pool = rng();
            cursor = 0;
        }
        return (pool & (1 << cursor++)) ? 1 : 0;
    };
}
/* MAIN */
const RNG = {
    get1: makeBitRNG(makeRNG(Uint8Array), 8),
    get8: makeRNG(Uint8Array),
    get16: makeRNG(Uint16Array),
    get32: makeRNG(Uint32Array),
    get64: makeRNG(BigUint64Array)
};

/* IMPORT */
/* HELPERS */
const DEC2HEX = Array.from({ length: 256 }, (_, idx) => idx.toString(16).padStart(2, '0'));
/* MAIN */
const get = () => {
    let id = '';
    for (let i = 0; i < 4; i++) {
        const uint32 = RNG.get32();
        id += DEC2HEX[(uint32 >>> 24) & 255];
        id += DEC2HEX[(uint32 >>> 16) & 255];
        id += DEC2HEX[(uint32 >>> 8) & 255];
        id += DEC2HEX[(uint32 & 255)];
    }
    return id;
};

const main = "_main_10m9e_62";
const piano = "_piano_10m9e_67";
const note = "_note_10m9e_73";
const selected = "_selected_10m9e_75";
const now$1 = "_now_10m9e_80";
const hud = "_hud_10m9e_87";
const topHudContainer = "_topHudContainer_10m9e_100";
const bottomHudContainer = "_bottomHudContainer_10m9e_101";
const topRightHud = "_topRightHud_10m9e_111";
const topLeftHud = "_topLeftHud_10m9e_112";
const bottomLeftHud = "_bottomLeftHud_10m9e_113";
const listContainer = "_listContainer_10m9e_122";
const list = "_list_10m9e_122";
const bottomRightHud = "_bottomRightHud_10m9e_162";
const contentHide = "_contentHide_10m9e_1";
const contentShow = "_contentShow_10m9e_1";
const button = "_button_10m9e_349";
const active = "_active_10m9e_365";
const horizontal = "_horizontal_10m9e_380";
const trigger = "_trigger_10m9e_420";
const numberButton = "_numberButton_10m9e_426";
const textContainer = "_textContainer_10m9e_441";
const numberButtonLabel = "_numberButtonLabel_10m9e_445";
const numberButtonValue = "_numberButtonValue_10m9e_452";
const buttonContainer = "_buttonContainer_10m9e_468";
const styles = {
	main: main,
	piano: piano,
	note: note,
	selected: selected,
	now: now$1,
	hud: hud,
	topHudContainer: topHudContainer,
	bottomHudContainer: bottomHudContainer,
	topRightHud: topRightHud,
	topLeftHud: topLeftHud,
	bottomLeftHud: bottomLeftHud,
	listContainer: listContainer,
	list: list,
	bottomRightHud: bottomRightHud,
	"dropdown-menu__trigger": "_dropdown-menu__trigger_10m9e_223",
	"dropdown-menu__content": "_dropdown-menu__content_10m9e_238",
	"dropdown-menu__sub-content": "_dropdown-menu__sub-content_10m9e_242",
	contentHide: contentHide,
	contentShow: contentShow,
	"dropdown-menu__item": "_dropdown-menu__item_10m9e_259",
	"dropdown-menu__checkbox-item": "_dropdown-menu__checkbox-item_10m9e_263",
	"dropdown-menu__radio-item": "_dropdown-menu__radio-item_10m9e_264",
	"dropdown-menu__sub-trigger": "_dropdown-menu__sub-trigger_10m9e_265",
	"dropdown-menu__group-label": "_dropdown-menu__group-label_10m9e_295",
	"dropdown-menu__separator": "_dropdown-menu__separator_10m9e_300",
	"dropdown-menu__item-indicator": "_dropdown-menu__item-indicator_10m9e_305",
	"dropdown-menu__item-right-slot": "_dropdown-menu__item-right-slot_10m9e_314",
	button: button,
	active: active,
	horizontal: horizontal,
	trigger: trigger,
	numberButton: numberButton,
	textContainer: textContainer,
	numberButtonLabel: numberButtonLabel,
	numberButtonValue: numberButtonValue,
	buttonContainer: buttonContainer
};

// Properties of the document root object
const STATE = Symbol.for("_am_meta"); // symbol used to hide application metadata on automerge objects
const TRACE = Symbol.for("_am_trace"); // used for debugging
const OBJECT_ID = Symbol.for("_am_objectId"); // symbol used to hide the object id on automerge objects
const IS_PROXY = Symbol.for("_am_isProxy"); // symbol used to test if the document is a proxy object
const CLEAR_CACHE = Symbol.for("_am_clearCache"); // symbol used to tell a proxy object to clear its cache
const UINT = Symbol.for("_am_uint");
const INT = Symbol.for("_am_int");
const F64 = Symbol.for("_am_f64");
const COUNTER = Symbol.for("_am_counter");
const TEXT = Symbol.for("_am_text");

class Text {
    constructor(text) {
        if (typeof text === "string") {
            this.elems = [...text];
        }
        else if (Array.isArray(text)) {
            this.elems = text;
        }
        else if (text === undefined) {
            this.elems = [];
        }
        else {
            throw new TypeError(`Unsupported initial value for Text: ${text}`);
        }
        Reflect.defineProperty(this, TEXT, { value: true });
    }
    get length() {
        return this.elems.length;
    }
    //eslint-disable-next-line @typescript-eslint/no-explicit-any
    get(index) {
        return this.elems[index];
    }
    /**
     * Iterates over the text elements character by character, including any
     * inline objects.
     */
    [Symbol.iterator]() {
        const elems = this.elems;
        let index = -1;
        return {
            next() {
                index += 1;
                if (index < elems.length) {
                    return { done: false, value: elems[index] };
                }
                else {
                    return { done: true };
                }
            },
        };
    }
    /**
     * Returns the content of the Text object as a simple string, ignoring any
     * non-character elements.
     */
    toString() {
        if (!this.str) {
            // Concatting to a string is faster than creating an array and then
            // .join()ing for small (<100KB) arrays.
            // https://jsperf.com/join-vs-loop-w-type-test
            this.str = "";
            for (const elem of this.elems) {
                if (typeof elem === "string")
                    this.str += elem;
                else
                    this.str += "\uFFFC";
            }
        }
        return this.str;
    }
    /**
     * Returns the content of the Text object as a sequence of strings,
     * interleaved with non-character elements.
     *
     * For example, the value `['a', 'b', {x: 3}, 'c', 'd']` has spans:
     * `=> ['ab', {x: 3}, 'cd']`
     */
    toSpans() {
        if (!this.spans) {
            this.spans = [];
            let chars = "";
            for (const elem of this.elems) {
                if (typeof elem === "string") {
                    chars += elem;
                }
                else {
                    if (chars.length > 0) {
                        this.spans.push(chars);
                        chars = "";
                    }
                    this.spans.push(elem);
                }
            }
            if (chars.length > 0) {
                this.spans.push(chars);
            }
        }
        return this.spans;
    }
    /**
     * Returns the content of the Text object as a simple string, so that the
     * JSON serialization of an Automerge document represents text nicely.
     */
    toJSON() {
        return this.toString();
    }
    /**
     * Updates the list item at position `index` to a new value `value`.
     */
    set(index, value) {
        if (this[STATE]) {
            throw new RangeError("object cannot be modified outside of a change block");
        }
        this.elems[index] = value;
    }
    /**
     * Inserts new list items `values` starting at position `index`.
     */
    insertAt(index, ...values) {
        if (this[STATE]) {
            throw new RangeError("object cannot be modified outside of a change block");
        }
        if (values.every(v => typeof v === "string")) {
            this.elems.splice(index, 0, ...values.join(""));
        }
        else {
            this.elems.splice(index, 0, ...values);
        }
    }
    /**
     * Deletes `numDelete` list items starting at position `index`.
     * if `numDelete` is not given, one item is deleted.
     */
    deleteAt(index, numDelete = 1) {
        if (this[STATE]) {
            throw new RangeError("object cannot be modified outside of a change block");
        }
        this.elems.splice(index, numDelete);
    }
    map(callback) {
        this.elems.map(callback);
    }
    lastIndexOf(searchElement, fromIndex) {
        this.elems.lastIndexOf(searchElement, fromIndex);
    }
    concat(other) {
        return new Text(this.elems.concat(other.elems));
    }
    every(test) {
        return this.elems.every(test);
    }
    filter(test) {
        return new Text(this.elems.filter(test));
    }
    find(test) {
        return this.elems.find(test);
    }
    findIndex(test) {
        return this.elems.findIndex(test);
    }
    forEach(f) {
        this.elems.forEach(f);
    }
    includes(elem) {
        return this.elems.includes(elem);
    }
    indexOf(elem) {
        return this.elems.indexOf(elem);
    }
    join(sep) {
        return this.elems.join(sep);
    }
    reduce(f) {
        this.elems.reduce(f);
    }
    reduceRight(f) {
        this.elems.reduceRight(f);
    }
    slice(start, end) {
        return new Text(this.elems.slice(start, end));
    }
    some(test) {
        return this.elems.some(test);
    }
    toLocaleString() {
        this.toString();
    }
}

/**
 * The most basic CRDT: an integer value that can be changed only by
 * incrementing and decrementing. Since addition of integers is commutative,
 * the value trivially converges.
 */
class Counter {
    constructor(value) {
        this.value = value || 0;
        Reflect.defineProperty(this, COUNTER, { value: true });
    }
    /**
     * A peculiar JavaScript language feature from its early days: if the object
     * `x` has a `valueOf()` method that returns a number, you can use numerical
     * operators on the object `x` directly, such as `x + 1` or `x < 4`.
     * This method is also called when coercing a value to a string by
     * concatenating it with another string, as in `x + ''`.
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf
     */
    valueOf() {
        return this.value;
    }
    /**
     * Returns the counter value as a decimal string. If `x` is a counter object,
     * this method is called e.g. when you do `['value: ', x].join('')` or when
     * you use string interpolation: `value: ${x}`.
     */
    toString() {
        return this.valueOf().toString();
    }
    /**
     * Returns the counter value, so that a JSON serialization of an Automerge
     * document represents the counter simply as an integer.
     */
    toJSON() {
        return this.value;
    }
    /**
     * Increases the value of the counter by `delta`. If `delta` is not given,
     * increases the value of the counter by 1.
     *
     * Will throw an error if used outside of a change callback.
     */
    increment(_delta) {
        throw new Error("Counters should not be incremented outside of a change callback");
    }
    /**
     * Decreases the value of the counter by `delta`. If `delta` is not given,
     * decreases the value of the counter by 1.
     *
     * Will throw an error if used outside of a change callback.
     */
    decrement(_delta) {
        throw new Error("Counters should not be decremented outside of a change callback");
    }
}
/**
 * An instance of this class is used when a counter is accessed within a change
 * callback.
 */
class WriteableCounter extends Counter {
    constructor(value, context, path, objectId, key) {
        super(value);
        this.context = context;
        this.path = path;
        this.objectId = objectId;
        this.key = key;
    }
    /**
     * Increases the value of the counter by `delta`. If `delta` is not given,
     * increases the value of the counter by 1.
     */
    increment(delta) {
        delta = typeof delta === "number" ? delta : 1;
        this.context.increment(this.objectId, this.key, delta);
        this.value += delta;
        return this.value;
    }
    /**
     * Decreases the value of the counter by `delta`. If `delta` is not given,
     * decreases the value of the counter by 1.
     */
    decrement(delta) {
        return this.increment(typeof delta === "number" ? -delta : -1);
    }
}
/**
 * Returns an instance of `WriteableCounter` for use in a change callback.
 * `context` is the proxy context that keeps track of the mutations.
 * `objectId` is the ID of the object containing the counter, and `key` is
 * the property name (key in map, or index in list) where the counter is
 * located.
 */
function getWriteableCounter(value, context, path, objectId, key) {
    return new WriteableCounter(value, context, path, objectId, key);
}
//module.exports = { Counter, getWriteableCounter }

class RawString {
    constructor(val) {
        this.val = val;
    }
    /**
     * Returns the content of the RawString object as a simple string
     */
    toString() {
        return this.val;
    }
    toJSON() {
        return this.val;
    }
}

/* eslint-disable  @typescript-eslint/no-explicit-any */
function parseListIndex(key) {
    if (typeof key === "string" && /^[0-9]+$/.test(key))
        key = parseInt(key, 10);
    if (typeof key !== "number") {
        return key;
    }
    if (key < 0 || isNaN(key) || key === Infinity || key === -Infinity) {
        throw new RangeError("A list index must be positive, but you passed " + key);
    }
    return key;
}
function valueAt(target, prop) {
    const { context, objectId, path, textV2 } = target;
    const value = context.getWithType(objectId, prop);
    if (value === null) {
        return;
    }
    const datatype = value[0];
    const val = value[1];
    switch (datatype) {
        case undefined:
            return;
        case "map":
            return mapProxy(context, val, textV2, [...path, prop]);
        case "list":
            return listProxy(context, val, textV2, [...path, prop]);
        case "text":
            if (textV2) {
                return context.text(val);
            }
            else {
                return textProxy(context, val, [
                    ...path,
                    prop,
                ]);
            }
        case "str":
            return val;
        case "uint":
            return val;
        case "int":
            return val;
        case "f64":
            return val;
        case "boolean":
            return val;
        case "null":
            return null;
        case "bytes":
            return val;
        case "timestamp":
            return val;
        case "counter": {
            const counter = getWriteableCounter(val, context, path, objectId, prop);
            return counter;
        }
        default:
            throw RangeError(`datatype ${datatype} unimplemented`);
    }
}
function import_value(value, textV2, path, context) {
    const type = typeof value;
    switch (type) {
        case "object":
            if (value == null) {
                return [null, "null"];
            }
            else if (value[UINT]) {
                return [value.value, "uint"];
            }
            else if (value[INT]) {
                return [value.value, "int"];
            }
            else if (value[F64]) {
                return [value.value, "f64"];
            }
            else if (value[COUNTER]) {
                return [value.value, "counter"];
            }
            else if (value instanceof Date) {
                return [value.getTime(), "timestamp"];
            }
            else if (value instanceof RawString) {
                return [value.toString(), "str"];
            }
            else if (value instanceof Text) {
                return [value, "text"];
            }
            else if (value instanceof Uint8Array) {
                return [value, "bytes"];
            }
            else if (value instanceof Array) {
                return [value, "list"];
            }
            else if (Object.prototype.toString.call(value) === "[object Object]") {
                return [value, "map"];
            }
            else if (isSameDocument(value, context)) {
                throw new RangeError("Cannot create a reference to an existing document object");
            }
            else {
                throw new RangeError(`Cannot assign unknown object: ${value}`);
            }
        case "boolean":
            return [value, "boolean"];
        case "number":
            if (Number.isInteger(value)) {
                return [value, "int"];
            }
            else {
                return [value, "f64"];
            }
        case "string":
            if (textV2) {
                return [value, "text"];
            }
            else {
                return [value, "str"];
            }
        case "undefined":
            throw new RangeError([
                `Cannot assign undefined value at ${printPath(path)}, `,
                "because `undefined` is not a valid JSON data type. ",
                "You might consider setting the property's value to `null`, ",
                "or using `delete` to remove it altogether.",
            ].join(""));
        default:
            throw new RangeError([
                `Cannot assign ${type} value at ${printPath(path)}. `,
                `All JSON primitive datatypes (object, array, string, number, boolean, null) `,
                `are supported in an Automerge document; ${type} values are not. `,
            ].join(""));
    }
}
// When we assign a value to a property in a proxy we recursively walk through
// the value we are assigning and copy it into the document. This is generally
// desirable behaviour. However, a very common bug is to accidentally assign a
// value which is already in the document to another key within the same
// document, this often leads to surprising behaviour where users expected to
// _move_ the object, but it is instead copied. To avoid this we check if the
// value is from the same document and if it is we throw an error, this means
// we require an explicit Object.assign call to copy the object, thus avoiding
// the footgun
function isSameDocument(val, context) {
    var _b, _c;
    // Date is technically an object, but immutable, so allowing people to assign
    // a date from one place in the document to another place in the document is
    // not likely to be a bug
    if (val instanceof Date) {
        return false;
    }
    // this depends on __wbg_ptr being the wasm pointer
    // a new version of wasm-bindgen will break this
    // but the tests should expose the break
    if (val && ((_c = (_b = val[STATE]) === null || _b === void 0 ? void 0 : _b.handle) === null || _c === void 0 ? void 0 : _c.__wbg_ptr) === context.__wbg_ptr) {
        return true;
    }
    return false;
}
const MapHandler = {
    get(target, key) {
        const { context, objectId, cache } = target;
        if (key === Symbol.toStringTag) {
            return target[Symbol.toStringTag];
        }
        if (key === OBJECT_ID)
            return objectId;
        if (key === IS_PROXY)
            return true;
        if (key === TRACE)
            return target.trace;
        if (key === STATE)
            return { handle: context, textV2: target.textV2 };
        if (!cache[key]) {
            cache[key] = valueAt(target, key);
        }
        return cache[key];
    },
    set(target, key, val) {
        const { context, objectId, path, textV2 } = target;
        target.cache = {}; // reset cache on set
        if (isSameDocument(val, context)) {
            throw new RangeError("Cannot create a reference to an existing document object");
        }
        if (key === TRACE) {
            target.trace = val;
            return true;
        }
        if (key === CLEAR_CACHE) {
            return true;
        }
        const [value, datatype] = import_value(val, textV2, [...path, key], context);
        switch (datatype) {
            case "list": {
                const list = context.putObject(objectId, key, []);
                const proxyList = listProxy(context, list, textV2, [...path, key]);
                for (let i = 0; i < value.length; i++) {
                    proxyList[i] = value[i];
                }
                break;
            }
            case "text": {
                if (textV2) {
                    assertString(value);
                    context.putObject(objectId, key, value);
                }
                else {
                    assertText(value);
                    const text = context.putObject(objectId, key, "");
                    const proxyText = textProxy(context, text, [...path, key]);
                    proxyText.splice(0, 0, ...value);
                }
                break;
            }
            case "map": {
                const map = context.putObject(objectId, key, {});
                const proxyMap = mapProxy(context, map, textV2, [...path, key]);
                for (const key in value) {
                    proxyMap[key] = value[key];
                }
                break;
            }
            default:
                context.put(objectId, key, value, datatype);
        }
        return true;
    },
    deleteProperty(target, key) {
        const { context, objectId } = target;
        target.cache = {}; // reset cache on delete
        context.delete(objectId, key);
        return true;
    },
    has(target, key) {
        const value = this.get(target, key);
        return value !== undefined;
    },
    getOwnPropertyDescriptor(target, key) {
        // const { context, objectId } = target
        const value = this.get(target, key);
        if (typeof value !== "undefined") {
            return {
                configurable: true,
                enumerable: true,
                value,
            };
        }
    },
    ownKeys(target) {
        const { context, objectId } = target;
        // FIXME - this is a tmp workaround until fix the dupe key bug in keys()
        const keys = context.keys(objectId);
        return [...new Set(keys)];
    },
};
const ListHandler = {
    get(target, index) {
        const { context, objectId } = target;
        index = parseListIndex(index);
        if (index === Symbol.hasInstance) {
            return (instance) => {
                return Array.isArray(instance);
            };
        }
        if (index === Symbol.toStringTag) {
            return target[Symbol.toStringTag];
        }
        if (index === OBJECT_ID)
            return objectId;
        if (index === IS_PROXY)
            return true;
        if (index === TRACE)
            return target.trace;
        if (index === STATE)
            return { handle: context };
        if (index === "length")
            return context.length(objectId);
        if (typeof index === "number") {
            return valueAt(target, index);
        }
        else {
            return listMethods(target)[index];
        }
    },
    set(target, index, val) {
        const { context, objectId, path, textV2 } = target;
        index = parseListIndex(index);
        if (isSameDocument(val, context)) {
            throw new RangeError("Cannot create a reference to an existing document object");
        }
        if (index === CLEAR_CACHE) {
            return true;
        }
        if (index === TRACE) {
            target.trace = val;
            return true;
        }
        if (typeof index == "string") {
            throw new RangeError("list index must be a number");
        }
        const [value, datatype] = import_value(val, textV2, [...path, index], context);
        switch (datatype) {
            case "list": {
                let list;
                if (index >= context.length(objectId)) {
                    list = context.insertObject(objectId, index, []);
                }
                else {
                    list = context.putObject(objectId, index, []);
                }
                const proxyList = listProxy(context, list, textV2, [...path, index]);
                proxyList.splice(0, 0, ...value);
                break;
            }
            case "text": {
                if (textV2) {
                    assertString(value);
                    if (index >= context.length(objectId)) {
                        context.insertObject(objectId, index, value);
                    }
                    else {
                        context.putObject(objectId, index, value);
                    }
                }
                else {
                    let text;
                    assertText(value);
                    if (index >= context.length(objectId)) {
                        text = context.insertObject(objectId, index, "");
                    }
                    else {
                        text = context.putObject(objectId, index, "");
                    }
                    const proxyText = textProxy(context, text, [...path, index]);
                    proxyText.splice(0, 0, ...value);
                }
                break;
            }
            case "map": {
                let map;
                if (index >= context.length(objectId)) {
                    map = context.insertObject(objectId, index, {});
                }
                else {
                    map = context.putObject(objectId, index, {});
                }
                const proxyMap = mapProxy(context, map, textV2, [...path, index]);
                for (const key in value) {
                    proxyMap[key] = value[key];
                }
                break;
            }
            default:
                if (index >= context.length(objectId)) {
                    context.insert(objectId, index, value, datatype);
                }
                else {
                    context.put(objectId, index, value, datatype);
                }
        }
        return true;
    },
    deleteProperty(target, index) {
        const { context, objectId } = target;
        index = parseListIndex(index);
        const elem = context.get(objectId, index);
        if (elem != null && elem[0] == "counter") {
            throw new TypeError("Unsupported operation: deleting a counter from a list");
        }
        context.delete(objectId, index);
        return true;
    },
    has(target, index) {
        const { context, objectId } = target;
        index = parseListIndex(index);
        if (typeof index === "number") {
            return index < context.length(objectId);
        }
        return index === "length";
    },
    getOwnPropertyDescriptor(target, index) {
        const { context, objectId } = target;
        if (index === "length")
            return { writable: true, value: context.length(objectId) };
        if (index === OBJECT_ID)
            return { configurable: false, enumerable: false, value: objectId };
        index = parseListIndex(index);
        const value = valueAt(target, index);
        return { configurable: true, enumerable: true, value };
    },
    getPrototypeOf(target) {
        return Object.getPrototypeOf(target);
    },
    ownKeys( /*target*/) {
        const keys = [];
        // uncommenting this causes assert.deepEqual() to fail when comparing to a pojo array
        // but not uncommenting it causes for (i in list) {} to not enumerate values properly
        //const {context, objectId } = target
        //for (let i = 0; i < target.context.length(objectId); i++) { keys.push(i.toString()) }
        keys.push("length");
        return keys;
    },
};
const TextHandler = Object.assign({}, ListHandler, {
    get(target, index) {
        const { context, objectId } = target;
        index = parseListIndex(index);
        if (index === Symbol.hasInstance) {
            return (instance) => {
                return Array.isArray(instance);
            };
        }
        if (index === Symbol.toStringTag) {
            return target[Symbol.toStringTag];
        }
        if (index === OBJECT_ID)
            return objectId;
        if (index === IS_PROXY)
            return true;
        if (index === TRACE)
            return target.trace;
        if (index === STATE)
            return { handle: context };
        if (index === "length")
            return context.length(objectId);
        if (typeof index === "number") {
            return valueAt(target, index);
        }
        else {
            return textMethods(target)[index] || listMethods(target)[index];
        }
    },
    getPrototypeOf( /*target*/) {
        return Object.getPrototypeOf(new Text());
    },
});
function mapProxy(context, objectId, textV2, path) {
    const target = {
        context,
        objectId,
        path: path || [],
        cache: {},
        textV2,
    };
    const proxied = {};
    Object.assign(proxied, target);
    const result = new Proxy(proxied, MapHandler);
    // conversion through unknown is necessary because the types are so different
    return result;
}
function listProxy(context, objectId, textV2, path) {
    const target = {
        context,
        objectId,
        path: path || [],
        cache: {},
        textV2,
    };
    const proxied = [];
    Object.assign(proxied, target);
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    return new Proxy(proxied, ListHandler);
}
function textProxy(context, objectId, path) {
    const target = {
        context,
        objectId,
        path: path || [],
        cache: {},
        textV2: false,
    };
    const proxied = {};
    Object.assign(proxied, target);
    return new Proxy(proxied, TextHandler);
}
function rootProxy(context, textV2) {
    /* eslint-disable-next-line */
    return mapProxy(context, "_root", textV2, []);
}
function listMethods(target) {
    const { context, objectId, path, textV2 } = target;
    const methods = {
        deleteAt(index, numDelete) {
            if (typeof numDelete === "number") {
                context.splice(objectId, index, numDelete);
            }
            else {
                context.delete(objectId, index);
            }
            return this;
        },
        fill(val, start, end) {
            const [value, datatype] = import_value(val, textV2, [...path, start], context);
            const length = context.length(objectId);
            start = parseListIndex(start || 0);
            end = parseListIndex(end || length);
            for (let i = start; i < Math.min(end, length); i++) {
                if (datatype === "list" || datatype === "map") {
                    context.putObject(objectId, i, value);
                }
                else if (datatype === "text") {
                    if (textV2) {
                        assertString(value);
                        context.putObject(objectId, i, value);
                    }
                    else {
                        assertText(value);
                        const text = context.putObject(objectId, i, "");
                        const proxyText = textProxy(context, text, [...path, i]);
                        for (let i = 0; i < value.length; i++) {
                            proxyText[i] = value.get(i);
                        }
                    }
                }
                else {
                    context.put(objectId, i, value, datatype);
                }
            }
            return this;
        },
        indexOf(o, start = 0) {
            const length = context.length(objectId);
            for (let i = start; i < length; i++) {
                const value = context.getWithType(objectId, i);
                if (value && (value[1] === o[OBJECT_ID] || value[1] === o)) {
                    return i;
                }
            }
            return -1;
        },
        insertAt(index, ...values) {
            this.splice(index, 0, ...values);
            return this;
        },
        pop() {
            const length = context.length(objectId);
            if (length == 0) {
                return undefined;
            }
            const last = valueAt(target, length - 1);
            context.delete(objectId, length - 1);
            return last;
        },
        push(...values) {
            const len = context.length(objectId);
            this.splice(len, 0, ...values);
            return context.length(objectId);
        },
        shift() {
            if (context.length(objectId) == 0)
                return;
            const first = valueAt(target, 0);
            context.delete(objectId, 0);
            return first;
        },
        splice(index, del, ...vals) {
            index = parseListIndex(index);
            // if del is undefined, delete until the end of the list
            if (typeof del !== "number") {
                del = context.length(objectId) - index;
            }
            del = parseListIndex(del);
            for (const val of vals) {
                if (isSameDocument(val, context)) {
                    throw new RangeError("Cannot create a reference to an existing document object");
                }
            }
            const result = [];
            for (let i = 0; i < del; i++) {
                const value = valueAt(target, index);
                if (value !== undefined) {
                    result.push(value);
                }
                context.delete(objectId, index);
            }
            const values = vals.map((val, index) => {
                try {
                    return import_value(val, textV2, [...path], context);
                }
                catch (e) {
                    if (e instanceof RangeError) {
                        throw new RangeError(`${e.message} (at index ${index} in the input)`);
                    }
                    else {
                        throw e;
                    }
                }
            });
            for (const [value, datatype] of values) {
                switch (datatype) {
                    case "list": {
                        const list = context.insertObject(objectId, index, []);
                        const proxyList = listProxy(context, list, textV2, [...path, index]);
                        proxyList.splice(0, 0, ...value);
                        break;
                    }
                    case "text": {
                        if (textV2) {
                            assertString(value);
                            context.insertObject(objectId, index, value);
                        }
                        else {
                            const text = context.insertObject(objectId, index, "");
                            const proxyText = textProxy(context, text, [...path, index]);
                            proxyText.splice(0, 0, ...value);
                        }
                        break;
                    }
                    case "map": {
                        const map = context.insertObject(objectId, index, {});
                        const proxyMap = mapProxy(context, map, textV2, [...path, index]);
                        for (const key in value) {
                            proxyMap[key] = value[key];
                        }
                        break;
                    }
                    default:
                        context.insert(objectId, index, value, datatype);
                }
                index += 1;
            }
            return result;
        },
        unshift(...values) {
            this.splice(0, 0, ...values);
            return context.length(objectId);
        },
        entries() {
            let i = 0;
            const iterator = {
                next: () => {
                    const value = valueAt(target, i);
                    if (value === undefined) {
                        return { value: undefined, done: true };
                    }
                    else {
                        return { value: [i++, value], done: false };
                    }
                },
                [Symbol.iterator]() {
                    return this;
                },
            };
            return iterator;
        },
        keys() {
            let i = 0;
            const len = context.length(objectId);
            const iterator = {
                next: () => {
                    if (i < len) {
                        return { value: i++, done: false };
                    }
                    return { value: undefined, done: true };
                },
                [Symbol.iterator]() {
                    return this;
                },
            };
            return iterator;
        },
        values() {
            let i = 0;
            const iterator = {
                next: () => {
                    const value = valueAt(target, i++);
                    if (value === undefined) {
                        return { value: undefined, done: true };
                    }
                    else {
                        return { value, done: false };
                    }
                },
                [Symbol.iterator]() {
                    return this;
                },
            };
            return iterator;
        },
        toArray() {
            const list = [];
            let value;
            do {
                value = valueAt(target, list.length);
                if (value !== undefined) {
                    list.push(value);
                }
            } while (value !== undefined);
            return list;
        },
        map(f) {
            return this.toArray().map(f);
        },
        toString() {
            return this.toArray().toString();
        },
        toLocaleString() {
            return this.toArray().toLocaleString();
        },
        forEach(f) {
            return this.toArray().forEach(f);
        },
        // todo: real concat function is different
        concat(other) {
            return this.toArray().concat(other);
        },
        every(f) {
            return this.toArray().every(f);
        },
        filter(f) {
            return this.toArray().filter(f);
        },
        find(f) {
            let index = 0;
            for (const v of this) {
                if (f(v, index)) {
                    return v;
                }
                index += 1;
            }
        },
        findIndex(f) {
            let index = 0;
            for (const v of this) {
                if (f(v, index)) {
                    return index;
                }
                index += 1;
            }
            return -1;
        },
        includes(elem) {
            return this.find(e => e === elem) !== undefined;
        },
        join(sep) {
            return this.toArray().join(sep);
        },
        reduce(f, initialValue) {
            return this.toArray().reduce(f, initialValue);
        },
        reduceRight(f, initialValue) {
            return this.toArray().reduceRight(f, initialValue);
        },
        lastIndexOf(search, fromIndex = +Infinity) {
            // this can be faster
            return this.toArray().lastIndexOf(search, fromIndex);
        },
        slice(index, num) {
            return this.toArray().slice(index, num);
        },
        some(f) {
            let index = 0;
            for (const v of this) {
                if (f(v, index)) {
                    return true;
                }
                index += 1;
            }
            return false;
        },
        [Symbol.iterator]: function* () {
            let i = 0;
            let value = valueAt(target, i);
            while (value !== undefined) {
                yield value;
                i += 1;
                value = valueAt(target, i);
            }
        },
    };
    return methods;
}
function textMethods(target) {
    const { context, objectId } = target;
    const methods = {
        set(index, value) {
            return (this[index] = value);
        },
        get(index) {
            return this[index];
        },
        toString() {
            return context.text(objectId).replace(//g, "");
        },
        toSpans() {
            const spans = [];
            let chars = "";
            const length = context.length(objectId);
            for (let i = 0; i < length; i++) {
                const value = this[i];
                if (typeof value === "string") {
                    chars += value;
                }
                else {
                    if (chars.length > 0) {
                        spans.push(chars);
                        chars = "";
                    }
                    spans.push(value);
                }
            }
            if (chars.length > 0) {
                spans.push(chars);
            }
            return spans;
        },
        toJSON() {
            return this.toString();
        },
        indexOf(o, start = 0) {
            const text = context.text(objectId);
            return text.indexOf(o, start);
        },
        insertAt(index, ...values) {
            if (values.every(v => typeof v === "string")) {
                context.splice(objectId, index, 0, values.join(""));
            }
            else {
                listMethods(target).insertAt(index, ...values);
            }
        },
    };
    return methods;
}
function assertText(value) {
    if (!(value instanceof Text)) {
        throw new Error("value was not a Text instance");
    }
}
function assertString(value) {
    if (typeof value !== "string") {
        throw new Error("value was not a string");
    }
}
function printPath(path) {
    // print the path as a json pointer
    const jsonPointerComponents = path.map(component => {
        // if its a number just turn it into a string
        if (typeof component === "number") {
            return component.toString();
        }
        else if (typeof component === "string") {
            // otherwise we have to escape `/` and `~` characters
            return component.replace(/~/g, "~0").replace(/\//g, "~1");
        }
    });
    if (path.length === 0) {
        return "";
    }
    else {
        return "/" + jsonPointerComponents.join("/");
    }
}

// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}

const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

function validate(uuid) {
  return typeof uuid === 'string' && REGEX.test(uuid);
}

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).slice(1));
}

function unsafeStringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

function stringify(arr, offset = 0) {
  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!validate(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

function parse(uuid) {
  if (!validate(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const native = {
  randomUUID
};

function v4(options, buf, offset) {
  if (native.randomUUID && !buf && !options) {
    return native.randomUUID();
  }

  options = options || {};
  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return unsafeStringify(rnds);
}

let wasm$2;

const heap$1 = new Array(128).fill(undefined);

heap$1.push(undefined, null, true, false);

heap$1.length;

const cachedTextEncoder$1 = (typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : { encode: () => { throw Error('TextEncoder not available') } } );

(typeof cachedTextEncoder$1.encodeInto === 'function'
    ? function (arg, view) {
    return cachedTextEncoder$1.encodeInto(arg, view);
}
    : function (arg, view) {
    const buf = cachedTextEncoder$1.encode(arg);
    view.set(buf);
    return {
        read: arg.length,
        written: buf.length
    };
});

const cachedTextDecoder$1 = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );

if (typeof TextDecoder !== 'undefined') { cachedTextDecoder$1.decode(); }
(typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$2.__wbg_automerge_free(ptr >>> 0));

(typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$2.__wbg_syncstate_free(ptr >>> 0));

let _initializeListeners = [];
function UseApi(api) {
    for (const k in api) {
        ApiHandler[k] = api[k];
    }
    for (const listener of _initializeListeners) {
        listener();
    }
}
/* eslint-disable */
const ApiHandler = {
    create(options) {
        throw new RangeError("Automerge.use() not called");
    },
    load(data, options) {
        throw new RangeError("Automerge.use() not called (load)");
    },
    encodeChange(change) {
        throw new RangeError("Automerge.use() not called (encodeChange)");
    },
    decodeChange(change) {
        throw new RangeError("Automerge.use() not called (decodeChange)");
    },
    initSyncState() {
        throw new RangeError("Automerge.use() not called (initSyncState)");
    },
    encodeSyncMessage(message) {
        throw new RangeError("Automerge.use() not called (encodeSyncMessage)");
    },
    decodeSyncMessage(msg) {
        throw new RangeError("Automerge.use() not called (decodeSyncMessage)");
    },
    encodeSyncState(state) {
        throw new RangeError("Automerge.use() not called (encodeSyncState)");
    },
    decodeSyncState(data) {
        throw new RangeError("Automerge.use() not called (decodeSyncState)");
    },
    exportSyncState(state) {
        throw new RangeError("Automerge.use() not called (exportSyncState)");
    },
    importSyncState(state) {
        throw new RangeError("Automerge.use() not called (importSyncState)");
    },
};

function _state(doc, checkroot = true) {
    if (typeof doc !== "object") {
        throw new RangeError("must be the document root");
    }
    const state = Reflect.get(doc, STATE);
    if (state === undefined ||
        state == null ||
        (checkroot && _obj(doc) !== "_root")) {
        throw new RangeError("must be the document root");
    }
    return state;
}
function _trace(doc) {
    return Reflect.get(doc, TRACE);
}
function _obj(doc) {
    if (!(typeof doc === "object") || doc === null) {
        return null;
    }
    return Reflect.get(doc, OBJECT_ID);
}
function _is_proxy(doc) {
    return !!Reflect.get(doc, IS_PROXY);
}

var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
function importOpts$1(_actor) {
    if (typeof _actor === "object") {
        return _actor;
    }
    else {
        return { actor: _actor };
    }
}
/**
 * Create a new automerge document
 *
 * @typeParam T - The type of value contained in the document. This will be the
 *     type that is passed to the change closure in {@link change}
 * @param _opts - Either an actorId or an {@link InitOptions} (which may
 *     contain an actorId). If this is null the document will be initialised with a
 *     random actor ID
 */
function init$1(_opts) {
    const opts = importOpts$1(_opts);
    const freeze = !!opts.freeze;
    const patchCallback = opts.patchCallback;
    const text_v1 = !(opts.enableTextV2 || false);
    const actor = opts.actor;
    const handle = ApiHandler.create({ actor, text_v1 });
    handle.enableFreeze(!!opts.freeze);
    const textV2 = opts.enableTextV2 || false;
    registerDatatypes(handle, textV2);
    const doc = handle.materialize("/", undefined, {
        handle,
        heads: undefined,
        freeze,
        patchCallback,
        textV2,
    });
    return doc;
}
/**
 * Make a full writable copy of an automerge document
 *
 * @remarks
 * Unlike {@link view} this function makes a full copy of the memory backing
 * the document and can thus be passed to {@link change}. It also generates a
 * new actor ID so that changes made in the new document do not create duplicate
 * sequence numbers with respect to the old document. If you need control over
 * the actor ID which is generated you can pass the actor ID as the second
 * argument
 *
 * @typeParam T - The type of the value contained in the document
 * @param doc - The document to clone
 * @param _opts - Either an actor ID to use for the new doc or an {@link InitOptions}
 */
function clone$1(doc, _opts) {
    const state = _state(doc);
    const heads = state.heads;
    const opts = importOpts$1(_opts);
    const handle = state.handle.fork(opts.actor, heads);
    handle.updateDiffCursor();
    // `change` uses the presence of state.heads to determine if we are in a view
    // set it to undefined to indicate that this is a full fat document
    const stateSansHeads = __rest(state, ["heads"]);
    stateSansHeads.patchCallback = opts.patchCallback;
    return handle.applyPatches(doc, Object.assign(Object.assign({}, stateSansHeads), { handle }));
}
/**
 * Create an automerge document from a POJO
 *
 * @param initialState - The initial state which will be copied into the document
 * @typeParam T - The type of the value passed to `from` _and_ the type the resulting document will contain
 * @typeParam actor - The actor ID of the resulting document, if this is null a random actor ID will be used
 *
 * @example
 * ```
 * const doc = automerge.from({
 *     tasks: [
 *         {description: "feed dogs", done: false}
 *     ]
 * })
 * ```
 */
function from$1(initialState, _opts) {
    return _change(init$1(_opts), "from", {}, d => Object.assign(d, initialState))
        .newDoc;
}
/**
 * Update the contents of an automerge document
 * @typeParam T - The type of the value contained in the document
 * @param doc - The document to update
 * @param options - Either a message, an {@link ChangeOptions}, or a {@link ChangeFn}
 * @param callback - A `ChangeFn` to be used if `options` was a `string`
 *
 * Note that if the second argument is a function it will be used as the `ChangeFn` regardless of what the third argument is.
 *
 * @example A simple change
 * ```
 * let doc1 = automerge.init()
 * doc1 = automerge.change(doc1, d => {
 *     d.key = "value"
 * })
 * assert.equal(doc1.key, "value")
 * ```
 *
 * @example A change with a message
 *
 * ```
 * doc1 = automerge.change(doc1, "add another value", d => {
 *     d.key2 = "value2"
 * })
 * ```
 *
 * @example A change with a message and a timestamp
 *
 * ```
 * doc1 = automerge.change(doc1, {message: "add another value", time: 1640995200}, d => {
 *     d.key2 = "value2"
 * })
 * ```
 *
 * @example responding to a patch callback
 * ```
 * let patchedPath
 * let patchCallback = patch => {
 *    patchedPath = patch.path
 * }
 * doc1 = automerge.change(doc1, {message: "add another value", time: 1640995200, patchCallback}, d => {
 *     d.key2 = "value2"
 * })
 * assert.equal(patchedPath, ["key2"])
 * ```
 */
function change(doc, options, callback) {
    if (typeof options === "function") {
        return _change(doc, "change", {}, options).newDoc;
    }
    else if (typeof callback === "function") {
        if (typeof options === "string") {
            options = { message: options };
        }
        return _change(doc, "change", options, callback).newDoc;
    }
    else {
        throw RangeError("Invalid args for change");
    }
}
/**
 * Make a change to the document as it was at a particular point in history
 * @typeParam T - The type of the value contained in the document
 * @param doc - The document to update
 * @param scope - The heads representing the point in history to make the change
 * @param options - Either a message or a {@link ChangeOptions} for the new change
 * @param callback - A `ChangeFn` to be used if `options` was a `string`
 *
 * @remarks
 * This function is similar to {@link change} but allows you to make changes to
 * the document as if it were at a particular point in time. To understand this
 * imagine a document created with the following history:
 *
 * ```ts
 * let doc = automerge.from({..})
 * doc = automerge.change(doc, () => {...})
 *
 * const heads = automerge.getHeads(doc)
 *
 * // fork the document make a change
 * let fork = automerge.fork(doc)
 * fork = automerge.change(fork, () => {...})
 * const headsOnFork = automerge.getHeads(fork)
 *
 * // make a change on the original doc
 * doc = automerge.change(doc, () => {...})
 * const headsOnOriginal = automerge.getHeads(doc)
 *
 * // now merge the changes back to the original document
 * doc = automerge.merge(doc, fork)
 *
 * // The heads of the document will now be (headsOnFork, headsOnOriginal)
 * ```
 *
 * {@link ChangeAt} produces an equivalent history, but without having to
 * create a fork of the document. In particular the `newHeads` field of the
 * returned {@link ChangeAtResult} will be the same as `headsOnFork`.
 *
 * Why would you want this? It's typically used in conjunction with {@link diff}
 * to reconcile state which is managed concurrently with the document. For
 * example, if you have a text editor component which the user is modifying
 * and you can't send the changes to the document synchronously you might follow
 * a workflow like this:
 *
 * * On initialization save the current heads of the document in the text editor state
 * * Every time the user makes a change record the change in the text editor state
 *
 * Now from time to time reconcile the editor state and the document
 * * Load the last saved heads from the text editor state, call them `oldHeads`
 * * Apply all the unreconciled changes to the document using `changeAt(doc, oldHeads, ...)`
 * * Get the diff from the resulting document to the current document using {@link diff}
 *   passing the {@link ChangeAtResult.newHeads} as the `before` argument and the
 *   heads of the entire document as the `after` argument.
 * * Apply the diff to the text editor state
 * * Save the current heads of the document in the text editor state
 */
function changeAt(doc, scope, options, callback) {
    if (typeof options === "function") {
        return _change(doc, "changeAt", {}, options, scope);
    }
    else if (typeof callback === "function") {
        if (typeof options === "string") {
            options = { message: options };
        }
        return _change(doc, "changeAt", options, callback, scope);
    }
    else {
        throw RangeError("Invalid args for changeAt");
    }
}
function progressDocument(doc, source, heads, callback) {
    if (heads == null) {
        return doc;
    }
    const state = _state(doc);
    const nextState = Object.assign(Object.assign({}, state), { heads: undefined });
    const { value: nextDoc, patches } = state.handle.applyAndReturnPatches(doc, nextState);
    if (patches.length > 0) {
        if (callback != null) {
            callback(patches, { before: doc, after: nextDoc, source });
        }
        const newState = _state(nextDoc);
        newState.mostRecentPatch = {
            before: _state(doc).heads,
            after: newState.handle.getHeads(),
            patches,
        };
    }
    state.heads = heads;
    return nextDoc;
}
function _change(doc, source, options, callback, scope) {
    if (typeof callback !== "function") {
        throw new RangeError("invalid change function");
    }
    const state = _state(doc);
    if (doc === undefined || state === undefined) {
        throw new RangeError("must be the document root");
    }
    if (state.heads) {
        throw new RangeError("Attempting to change an outdated document.  Use Automerge.clone() if you wish to make a writable copy.");
    }
    if (_is_proxy(doc)) {
        throw new RangeError("Calls to Automerge.change cannot be nested");
    }
    let heads = state.handle.getHeads();
    if (scope && headsEqual(scope, heads)) {
        scope = undefined;
    }
    if (scope) {
        state.handle.isolate(scope);
        heads = scope;
    }
    if (!("time" in options)) {
        options.time = Math.floor(Date.now() / 1000);
    }
    try {
        state.heads = heads;
        const root = rootProxy(state.handle, state.textV2);
        callback(root);
        if (state.handle.pendingOps() === 0) {
            state.heads = undefined;
            if (scope) {
                state.handle.integrate();
            }
            return {
                newDoc: doc,
                newHeads: null,
            };
        }
        else {
            const newHead = state.handle.commit(options.message, options.time);
            state.handle.integrate();
            return {
                newDoc: progressDocument(doc, source, heads, options.patchCallback || state.patchCallback),
                newHeads: newHead != null ? [newHead] : null,
            };
        }
    }
    catch (e) {
        state.heads = undefined;
        state.handle.rollback();
        throw e;
    }
}
/**
 * Make a change to a document which does not modify the document
 *
 * @param doc - The doc to add the empty change to
 * @param options - Either a message or a {@link ChangeOptions} for the new change
 *
 * Why would you want to do this? One reason might be that you have merged
 * changes from some other peers and you want to generate a change which
 * depends on those merged changes so that you can sign the new change with all
 * of the merged changes as part of the new change.
 */
function emptyChange(doc, options) {
    if (options === undefined) {
        options = {};
    }
    if (typeof options === "string") {
        options = { message: options };
    }
    if (!("time" in options)) {
        options.time = Math.floor(Date.now() / 1000);
    }
    const state = _state(doc);
    if (state.heads) {
        throw new RangeError("Attempting to change an outdated document.  Use Automerge.clone() if you wish to make a writable copy.");
    }
    if (_is_proxy(doc)) {
        throw new RangeError("Calls to Automerge.change cannot be nested");
    }
    const heads = state.handle.getHeads();
    state.handle.emptyChange(options.message, options.time);
    return progressDocument(doc, "emptyChange", heads);
}
/**
 * Load an automerge document from a compressed document produce by {@link save}
 *
 * @typeParam T - The type of the value which is contained in the document.
 *                Note that no validation is done to make sure this type is in
 *                fact the type of the contained value so be a bit careful
 * @param data  - The compressed document
 * @param _opts - Either an actor ID or some {@link InitOptions}, if the actor
 *                ID is null a random actor ID will be created
 *
 * Note that `load` will throw an error if passed incomplete content (for
 * example if you are receiving content over the network and don't know if you
 * have the complete document yet). If you need to handle incomplete content use
 * {@link init} followed by {@link loadIncremental}.
 */
function load$3(data, _opts) {
    const opts = importOpts$1(_opts);
    const actor = opts.actor;
    const patchCallback = opts.patchCallback;
    const text_v1 = !(opts.enableTextV2 || false);
    const unchecked = opts.unchecked || false;
    const allowMissingDeps = opts.allowMissingChanges || false;
    const convertRawStringsToText = opts.convertRawStringsToText || false;
    const handle = ApiHandler.load(data, {
        text_v1,
        actor,
        unchecked,
        allowMissingDeps,
        convertRawStringsToText,
    });
    handle.enableFreeze(!!opts.freeze);
    const textV2 = opts.enableTextV2 || false;
    registerDatatypes(handle, textV2);
    const doc = handle.materialize("/", undefined, {
        handle,
        heads: undefined,
        patchCallback,
        textV2,
    });
    return doc;
}
/**
 * Load changes produced by {@link saveIncremental}, or partial changes
 *
 * @typeParam T - The type of the value which is contained in the document.
 *                Note that no validation is done to make sure this type is in
 *                fact the type of the contained value so be a bit careful
 * @param data  - The compressedchanges
 * @param opts  - an {@link ApplyOptions}
 *
 * This function is useful when staying up to date with a connected peer.
 * Perhaps the other end sent you a full compresed document which you loaded
 * with {@link load} and they're sending you the result of
 * {@link getLastLocalChange} every time they make a change.
 *
 * Note that this function will succesfully load the results of {@link save} as
 * well as {@link getLastLocalChange} or any other incremental change.
 */
function loadIncremental(doc, data, opts) {
    if (!opts) {
        opts = {};
    }
    const state = _state(doc);
    if (state.heads) {
        throw new RangeError("Attempting to change an out of date document - set at: " + _trace(doc));
    }
    if (_is_proxy(doc)) {
        throw new RangeError("Calls to Automerge.change cannot be nested");
    }
    const heads = state.handle.getHeads();
    state.handle.loadIncremental(data);
    return progressDocument(doc, "loadIncremental", heads, opts.patchCallback || state.patchCallback);
}
/**
 * Export the contents of a document to a compressed format
 *
 * @param doc - The doc to save
 *
 * The returned bytes can be passed to {@link load} or {@link loadIncremental}
 */
function save(doc) {
    return _state(doc).handle.save();
}
/**
 * Merge `remote` into `local`
 * @typeParam T - The type of values contained in each document
 * @param local - The document to merge changes into
 * @param remote - The document to merge changes from
 *
 * @returns - The merged document
 *
 * Often when you are merging documents you will also need to clone them. Both
 * arguments to `merge` are frozen after the call so you can no longer call
 * mutating methods (such as {@link change}) on them. The symtom of this will be
 * an error which says "Attempting to change an out of date document". To
 * overcome this call {@link clone} on the argument before passing it to {@link
 * merge}.
 */
function merge(local, remote) {
    const localState = _state(local);
    if (localState.heads) {
        throw new RangeError("Attempting to change an out of date document - set at: " + _trace(local));
    }
    const heads = localState.handle.getHeads();
    const remoteState = _state(remote);
    const changes = localState.handle.getChangesAdded(remoteState.handle);
    localState.handle.applyChanges(changes);
    return progressDocument(local, "merge", heads, localState.patchCallback);
}
/**
 * Create a set of patches representing the change from one set of heads to another
 *
 * If either of the heads are missing from the document the returned set of patches will be empty
 */
function diff(doc, before, after) {
    checkHeads(before, "before");
    checkHeads(after, "after");
    const state = _state(doc);
    if (state.mostRecentPatch &&
        equals(state.mostRecentPatch.before, before) &&
        equals(state.mostRecentPatch.after, after)) {
        return state.mostRecentPatch.patches;
    }
    return state.handle.diff(before, after);
}
function headsEqual(heads1, heads2) {
    if (heads1.length !== heads2.length) {
        return false;
    }
    for (let i = 0; i < heads1.length; i++) {
        if (heads1[i] !== heads2[i]) {
            return false;
        }
    }
    return true;
}
function checkHeads(heads, fieldname) {
    if (!Array.isArray(heads)) {
        throw new Error(`${fieldname} must be an array`);
    }
}
/** @hidden */
// FIXME : no tests
// FIXME can we just use deep equals now?
function equals(val1, val2) {
    if (!isObject(val1) || !isObject(val2))
        return val1 === val2;
    const keys1 = Object.keys(val1).sort(), keys2 = Object.keys(val2).sort();
    if (keys1.length !== keys2.length)
        return false;
    for (let i = 0; i < keys1.length; i++) {
        if (keys1[i] !== keys2[i])
            return false;
        if (!equals(val1[keys1[i]], val2[keys2[i]]))
            return false;
    }
    return true;
}
/**
 * encode a {@link SyncState} into binary to send over the network
 *
 * @group sync
 * */
function encodeSyncState$2(state) {
    const sync = ApiHandler.importSyncState(state);
    const result = ApiHandler.encodeSyncState(sync);
    sync.free();
    return result;
}
/**
 * Decode some binary data into a {@link SyncState}
 *
 * @group sync
 */
function decodeSyncState$2(state) {
    const sync = ApiHandler.decodeSyncState(state);
    const result = ApiHandler.exportSyncState(sync);
    sync.free();
    return result;
}
/**
 * Generate a sync message to send to the peer represented by `inState`
 * @param doc - The doc to generate messages about
 * @param inState - The {@link SyncState} representing the peer we are talking to
 *
 * @group sync
 *
 * @returns An array of `[newSyncState, syncMessage | null]` where
 * `newSyncState` should replace `inState` and `syncMessage` should be sent to
 * the peer if it is not null. If `syncMessage` is null then we are up to date.
 */
function generateSyncMessage(doc, inState) {
    const state = _state(doc);
    const syncState = ApiHandler.importSyncState(inState);
    const message = state.handle.generateSyncMessage(syncState);
    const outState = ApiHandler.exportSyncState(syncState);
    return [outState, message];
}
/**
 * Update a document and our sync state on receiving a sync message
 *
 * @group sync
 *
 * @param doc     - The doc the sync message is about
 * @param inState - The {@link SyncState} for the peer we are communicating with
 * @param message - The message which was received
 * @param opts    - Any {@link ApplyOption}s, used for passing a
 *                  {@link PatchCallback} which will be informed of any changes
 *                  in `doc` which occur because of the received sync message.
 *
 * @returns An array of `[newDoc, newSyncState, syncMessage | null]` where
 * `newDoc` is the updated state of `doc`, `newSyncState` should replace
 * `inState` and `syncMessage` should be sent to the peer if it is not null. If
 * `syncMessage` is null then we are up to date.
 */
function receiveSyncMessage(doc, inState, message, opts) {
    const syncState = ApiHandler.importSyncState(inState);
    if (!opts) {
        opts = {};
    }
    const state = _state(doc);
    if (state.heads) {
        throw new RangeError("Attempting to change an outdated document.  Use Automerge.clone() if you wish to make a writable copy.");
    }
    if (_is_proxy(doc)) {
        throw new RangeError("Calls to Automerge.change cannot be nested");
    }
    const heads = state.handle.getHeads();
    state.handle.receiveSyncMessage(syncState, message);
    const outSyncState = ApiHandler.exportSyncState(syncState);
    return [
        progressDocument(doc, "receiveSyncMessage", heads, opts.patchCallback || state.patchCallback),
        outSyncState,
        null,
    ];
}
/**
 * Create a new, blank {@link SyncState}
 *
 * When communicating with a peer for the first time use this to generate a new
 * {@link SyncState} for them
 *
 * @group sync
 */
function initSyncState$2() {
    return ApiHandler.exportSyncState(ApiHandler.initSyncState());
}
/** @hidden */
function decodeSyncMessage$2(message) {
    return ApiHandler.decodeSyncMessage(message);
}
/**
 * Get the hashes of the heads of this document
 */
function getHeads(doc) {
    const state = _state(doc);
    return state.heads || state.handle.getHeads();
}
function isObject(obj) {
    return typeof obj === "object" && obj !== null;
}
function saveSince(doc, heads) {
    const state = _state(doc);
    const result = state.handle.saveSince(heads);
    return result;
}
function registerDatatypes(handle, textV2) {
    handle.registerDatatype("counter", (n) => new Counter(n), n => {
        if (n instanceof Counter) {
            return n.value;
        }
    });
    if (textV2) {
        handle.registerDatatype("str", (n) => {
            return new RawString(n);
        }, s => {
            if (s instanceof RawString) {
                return s.val;
            }
        });
    }
    else {
        handle.registerDatatype("text", (n) => new Text(n), t => {
            if (t instanceof Text) {
                return t.join("");
            }
        });
    }
}

/**
 * # The next API
 *
 * This module contains new features we are working on which are backwards
 * incompatible with the current API of Automerge. This module will become the
 * API of the next major version of Automerge
 *
 * ## Differences from stable
 *
 * In the stable API text objects are represented using the {@link Text} class.
 * This means you must decide up front whether your string data might need
 * concurrent merges in the future and if you change your mind you have to
 * figure out how to migrate your data. In the unstable API the `Text` class is
 * gone and all `string`s are represented using the text CRDT, allowing for
 * concurrent changes. Modifying a string is done using the {@link splice}
 * function. You can still access the old behaviour of strings which do not
 * support merging behaviour via the {@link RawString} class.
 *
 * This leads to the following differences from `stable`:
 *
 * * There is no `unstable.Text` class, all strings are text objects
 * * Reading strings in an `unstable` document is the same as reading any other
 *   javascript string
 * * To modify strings in an `unstable` document use {@link splice}
 * * The {@link AutomergeValue} type does not include the {@link Text}
 *   class but the  {@link RawString} class is included in the {@link ScalarValue}
 *   type
 *
 * ## CHANGELOG
 * * Rename this module to `next` to reflect our increased confidence in it
 *   and stability commitment to it
 * * Introduce this module to expose the new API which has no `Text` class
 *
 *
 * @module
 */
/**
 * Create a new automerge document
 *
 * @typeParam T - The type of value contained in the document. This will be the
 *     type that is passed to the change closure in {@link change}
 * @param _opts - Either an actorId or an {@link InitOptions} (which may
 *     contain an actorId). If this is null the document will be initialised with a
 *     random actor ID
 */
function init(_opts) {
    const opts = importOpts(_opts);
    opts.enableTextV2 = true;
    return init$1(opts);
}
/**
 * Make a full writable copy of an automerge document
 *
 * @remarks
 * Unlike {@link view} this function makes a full copy of the memory backing
 * the document and can thus be passed to {@link change}. It also generates a
 * new actor ID so that changes made in the new document do not create duplicate
 * sequence numbers with respect to the old document. If you need control over
 * the actor ID which is generated you can pass the actor ID as the second
 * argument
 *
 * @typeParam T - The type of the value contained in the document
 * @param doc - The document to clone
 * @param _opts - Either an actor ID to use for the new doc or an {@link InitOptions}
 */
function clone(doc, _opts) {
    const opts = importOpts(_opts);
    opts.enableTextV2 = true;
    return clone$1(doc, opts);
}
/**
 * Create an automerge document from a POJO
 *
 * @param initialState - The initial state which will be copied into the document
 * @typeParam T - The type of the value passed to `from` _and_ the type the resulting document will contain
 * @typeParam actor - The actor ID of the resulting document, if this is null a random actor ID will be used
 *
 * @example
 * ```
 * const doc = automerge.from({
 *     tasks: [
 *         {description: "feed dogs", done: false}
 *     ]
 * })
 * ```
 */
function from(initialState, _opts) {
    const opts = importOpts(_opts);
    opts.enableTextV2 = true;
    return from$1(initialState, opts);
}
/**
 * Load an automerge document from a compressed document produce by {@link save}
 *
 * @typeParam T - The type of the value which is contained in the document.
 *                Note that no validation is done to make sure this type is in
 *                fact the type of the contained value so be a bit careful
 * @param data  - The compressed document
 * @param _opts - Either an actor ID or some {@link InitOptions}, if the actor
 *                ID is null a random actor ID will be created
 *
 * Note that `load` will throw an error if passed incomplete content (for
 * example if you are receiving content over the network and don't know if you
 * have the complete document yet). If you need to handle incomplete content use
 * {@link init} followed by {@link loadIncremental}.
 */
function load$2(data, _opts) {
    const opts = importOpts(_opts);
    opts.enableTextV2 = true;
    if (opts.patchCallback) {
        return loadIncremental(init$1(opts), data);
    }
    else {
        return load$3(data, opts);
    }
}
function importOpts(_actor) {
    {
        return { actor: _actor };
    }
}

var browser = {exports: {}};

/**
 * Helpers.
 */

var ms;
var hasRequiredMs;

function requireMs () {
	if (hasRequiredMs) return ms;
	hasRequiredMs = 1;
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var w = d * 7;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */

	ms = function (val, options) {
	  options = options || {};
	  var type = typeof val;
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isFinite(val)) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error(
	    'val is not a non-empty string or a valid number. val=' +
	      JSON.stringify(val)
	  );
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = String(str);
	  if (str.length > 100) {
	    return;
	  }
	  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
	    str
	  );
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'weeks':
	    case 'week':
	    case 'w':
	      return n * w;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtShort(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (msAbs >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (msAbs >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (msAbs >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtLong(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return plural(ms, msAbs, d, 'day');
	  }
	  if (msAbs >= h) {
	    return plural(ms, msAbs, h, 'hour');
	  }
	  if (msAbs >= m) {
	    return plural(ms, msAbs, m, 'minute');
	  }
	  if (msAbs >= s) {
	    return plural(ms, msAbs, s, 'second');
	  }
	  return ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, msAbs, n, name) {
	  var isPlural = msAbs >= n * 1.5;
	  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
	}
	return ms;
}

var common;
var hasRequiredCommon;

function requireCommon () {
	if (hasRequiredCommon) return common;
	hasRequiredCommon = 1;
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 */

	function setup(env) {
		createDebug.debug = createDebug;
		createDebug.default = createDebug;
		createDebug.coerce = coerce;
		createDebug.disable = disable;
		createDebug.enable = enable;
		createDebug.enabled = enabled;
		createDebug.humanize = requireMs();
		createDebug.destroy = destroy;

		Object.keys(env).forEach(key => {
			createDebug[key] = env[key];
		});

		/**
		* The currently active debug mode names, and names to skip.
		*/

		createDebug.names = [];
		createDebug.skips = [];

		/**
		* Map of special "%n" handling functions, for the debug "format" argument.
		*
		* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
		*/
		createDebug.formatters = {};

		/**
		* Selects a color for a debug namespace
		* @param {String} namespace The namespace string for the debug instance to be colored
		* @return {Number|String} An ANSI color code for the given namespace
		* @api private
		*/
		function selectColor(namespace) {
			let hash = 0;

			for (let i = 0; i < namespace.length; i++) {
				hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
				hash |= 0; // Convert to 32bit integer
			}

			return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
		}
		createDebug.selectColor = selectColor;

		/**
		* Create a debugger with the given `namespace`.
		*
		* @param {String} namespace
		* @return {Function}
		* @api public
		*/
		function createDebug(namespace) {
			let prevTime;
			let enableOverride = null;
			let namespacesCache;
			let enabledCache;

			function debug(...args) {
				// Disabled?
				if (!debug.enabled) {
					return;
				}

				const self = debug;

				// Set `diff` timestamp
				const curr = Number(new Date());
				const ms = curr - (prevTime || curr);
				self.diff = ms;
				self.prev = prevTime;
				self.curr = curr;
				prevTime = curr;

				args[0] = createDebug.coerce(args[0]);

				if (typeof args[0] !== 'string') {
					// Anything else let's inspect with %O
					args.unshift('%O');
				}

				// Apply any `formatters` transformations
				let index = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
					// If we encounter an escaped % then don't increase the array index
					if (match === '%%') {
						return '%';
					}
					index++;
					const formatter = createDebug.formatters[format];
					if (typeof formatter === 'function') {
						const val = args[index];
						match = formatter.call(self, val);

						// Now we need to remove `args[index]` since it's inlined in the `format`
						args.splice(index, 1);
						index--;
					}
					return match;
				});

				// Apply env-specific formatting (colors, etc.)
				createDebug.formatArgs.call(self, args);

				const logFn = self.log || createDebug.log;
				logFn.apply(self, args);
			}

			debug.namespace = namespace;
			debug.useColors = createDebug.useColors();
			debug.color = createDebug.selectColor(namespace);
			debug.extend = extend;
			debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

			Object.defineProperty(debug, 'enabled', {
				enumerable: true,
				configurable: false,
				get: () => {
					if (enableOverride !== null) {
						return enableOverride;
					}
					if (namespacesCache !== createDebug.namespaces) {
						namespacesCache = createDebug.namespaces;
						enabledCache = createDebug.enabled(namespace);
					}

					return enabledCache;
				},
				set: v => {
					enableOverride = v;
				}
			});

			// Env-specific initialization logic for debug instances
			if (typeof createDebug.init === 'function') {
				createDebug.init(debug);
			}

			return debug;
		}

		function extend(namespace, delimiter) {
			const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}

		/**
		* Enables a debug mode by namespaces. This can include modes
		* separated by a colon and wildcards.
		*
		* @param {String} namespaces
		* @api public
		*/
		function enable(namespaces) {
			createDebug.save(namespaces);
			createDebug.namespaces = namespaces;

			createDebug.names = [];
			createDebug.skips = [];

			const split = (typeof namespaces === 'string' ? namespaces : '')
				.trim()
				.replace(' ', ',')
				.split(',')
				.filter(Boolean);

			for (const ns of split) {
				if (ns[0] === '-') {
					createDebug.skips.push(ns.slice(1));
				} else {
					createDebug.names.push(ns);
				}
			}
		}

		/**
		 * Checks if the given string matches a namespace template, honoring
		 * asterisks as wildcards.
		 *
		 * @param {String} search
		 * @param {String} template
		 * @return {Boolean}
		 */
		function matchesTemplate(search, template) {
			let searchIndex = 0;
			let templateIndex = 0;
			let starIndex = -1;
			let matchIndex = 0;

			while (searchIndex < search.length) {
				if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
					// Match character or proceed with wildcard
					if (template[templateIndex] === '*') {
						starIndex = templateIndex;
						matchIndex = searchIndex;
						templateIndex++; // Skip the '*'
					} else {
						searchIndex++;
						templateIndex++;
					}
				} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition
					// Backtrack to the last '*' and try to match more characters
					templateIndex = starIndex + 1;
					matchIndex++;
					searchIndex = matchIndex;
				} else {
					return false; // No match
				}
			}

			// Handle trailing '*' in template
			while (templateIndex < template.length && template[templateIndex] === '*') {
				templateIndex++;
			}

			return templateIndex === template.length;
		}

		/**
		* Disable debug output.
		*
		* @return {String} namespaces
		* @api public
		*/
		function disable() {
			const namespaces = [
				...createDebug.names,
				...createDebug.skips.map(namespace => '-' + namespace)
			].join(',');
			createDebug.enable('');
			return namespaces;
		}

		/**
		* Returns true if the given mode name is enabled, false otherwise.
		*
		* @param {String} name
		* @return {Boolean}
		* @api public
		*/
		function enabled(name) {
			for (const skip of createDebug.skips) {
				if (matchesTemplate(name, skip)) {
					return false;
				}
			}

			for (const ns of createDebug.names) {
				if (matchesTemplate(name, ns)) {
					return true;
				}
			}

			return false;
		}

		/**
		* Coerce `val`.
		*
		* @param {Mixed} val
		* @return {Mixed}
		* @api private
		*/
		function coerce(val) {
			if (val instanceof Error) {
				return val.stack || val.message;
			}
			return val;
		}

		/**
		* XXX DO NOT USE. This is a temporary stub function.
		* XXX It WILL be removed in the next major release.
		*/
		function destroy() {
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}

		createDebug.enable(createDebug.load());

		return createDebug;
	}

	common = setup;
	return common;
}

var hasRequiredBrowser;

function requireBrowser () {
	if (hasRequiredBrowser) return browser.exports;
	hasRequiredBrowser = 1;
	(function (module, exports) {
		var define_process_env_default = {};
		exports.formatArgs = formatArgs;
		exports.save = save;
		exports.load = load;
		exports.useColors = useColors;
		exports.storage = localstorage();
		exports.destroy = /* @__PURE__ */ (() => {
		  let warned = false;
		  return () => {
		    if (!warned) {
		      warned = true;
		      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
		    }
		  };
		})();
		exports.colors = [
		  "#0000CC",
		  "#0000FF",
		  "#0033CC",
		  "#0033FF",
		  "#0066CC",
		  "#0066FF",
		  "#0099CC",
		  "#0099FF",
		  "#00CC00",
		  "#00CC33",
		  "#00CC66",
		  "#00CC99",
		  "#00CCCC",
		  "#00CCFF",
		  "#3300CC",
		  "#3300FF",
		  "#3333CC",
		  "#3333FF",
		  "#3366CC",
		  "#3366FF",
		  "#3399CC",
		  "#3399FF",
		  "#33CC00",
		  "#33CC33",
		  "#33CC66",
		  "#33CC99",
		  "#33CCCC",
		  "#33CCFF",
		  "#6600CC",
		  "#6600FF",
		  "#6633CC",
		  "#6633FF",
		  "#66CC00",
		  "#66CC33",
		  "#9900CC",
		  "#9900FF",
		  "#9933CC",
		  "#9933FF",
		  "#99CC00",
		  "#99CC33",
		  "#CC0000",
		  "#CC0033",
		  "#CC0066",
		  "#CC0099",
		  "#CC00CC",
		  "#CC00FF",
		  "#CC3300",
		  "#CC3333",
		  "#CC3366",
		  "#CC3399",
		  "#CC33CC",
		  "#CC33FF",
		  "#CC6600",
		  "#CC6633",
		  "#CC9900",
		  "#CC9933",
		  "#CCCC00",
		  "#CCCC33",
		  "#FF0000",
		  "#FF0033",
		  "#FF0066",
		  "#FF0099",
		  "#FF00CC",
		  "#FF00FF",
		  "#FF3300",
		  "#FF3333",
		  "#FF3366",
		  "#FF3399",
		  "#FF33CC",
		  "#FF33FF",
		  "#FF6600",
		  "#FF6633",
		  "#FF9900",
		  "#FF9933",
		  "#FFCC00",
		  "#FFCC33"
		];
		function useColors() {
		  if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
		    return true;
		  }
		  if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		    return false;
		  }
		  let m;
		  return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
		  typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
		  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		  typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
		  typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
		}
		function formatArgs(args) {
		  args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
		  if (!this.useColors) {
		    return;
		  }
		  const c = "color: " + this.color;
		  args.splice(1, 0, c, "color: inherit");
		  let index = 0;
		  let lastC = 0;
		  args[0].replace(/%[a-zA-Z%]/g, (match) => {
		    if (match === "%%") {
		      return;
		    }
		    index++;
		    if (match === "%c") {
		      lastC = index;
		    }
		  });
		  args.splice(lastC, 0, c);
		}
		exports.log = console.debug || console.log || (() => {
		});
		function save(namespaces) {
		  try {
		    if (namespaces) {
		      exports.storage.setItem("debug", namespaces);
		    } else {
		      exports.storage.removeItem("debug");
		    }
		  } catch (error) {
		  }
		}
		function load() {
		  let r;
		  try {
		    r = exports.storage.getItem("debug");
		  } catch (error) {
		  }
		  if (!r && typeof process !== "undefined" && "env" in process) {
		    r = define_process_env_default.DEBUG;
		  }
		  return r;
		}
		function localstorage() {
		  try {
		    return localStorage;
		  } catch (error) {
		  }
		}
		module.exports = requireCommon()(exports);
		const { formatters } = module.exports;
		formatters.j = function(v) {
		  try {
		    return JSON.stringify(v);
		  } catch (error) {
		    return "[UnexpectedJSONParseError]: " + error.message;
		  }
		}; 
	} (browser, browser.exports));
	return browser.exports;
}

var browserExports = requireBrowser();
const debug = /*@__PURE__*/getDefaultExportFromCjs(browserExports);

var eventemitter3 = {exports: {}};

var hasRequiredEventemitter3;

function requireEventemitter3 () {
	if (hasRequiredEventemitter3) return eventemitter3.exports;
	hasRequiredEventemitter3 = 1;
	(function (module) {

		var has = Object.prototype.hasOwnProperty
		  , prefix = '~';

		/**
		 * Constructor to create a storage for our `EE` objects.
		 * An `Events` instance is a plain object whose properties are event names.
		 *
		 * @constructor
		 * @private
		 */
		function Events() {}

		//
		// We try to not inherit from `Object.prototype`. In some engines creating an
		// instance in this way is faster than calling `Object.create(null)` directly.
		// If `Object.create(null)` is not supported we prefix the event names with a
		// character to make sure that the built-in object properties are not
		// overridden or used as an attack vector.
		//
		if (Object.create) {
		  Events.prototype = Object.create(null);

		  //
		  // This hack is needed because the `__proto__` property is still inherited in
		  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
		  //
		  if (!new Events().__proto__) prefix = false;
		}

		/**
		 * Representation of a single event listener.
		 *
		 * @param {Function} fn The listener function.
		 * @param {*} context The context to invoke the listener with.
		 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
		 * @constructor
		 * @private
		 */
		function EE(fn, context, once) {
		  this.fn = fn;
		  this.context = context;
		  this.once = once || false;
		}

		/**
		 * Add a listener for a given event.
		 *
		 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
		 * @param {(String|Symbol)} event The event name.
		 * @param {Function} fn The listener function.
		 * @param {*} context The context to invoke the listener with.
		 * @param {Boolean} once Specify if the listener is a one-time listener.
		 * @returns {EventEmitter}
		 * @private
		 */
		function addListener(emitter, event, fn, context, once) {
		  if (typeof fn !== 'function') {
		    throw new TypeError('The listener must be a function');
		  }

		  var listener = new EE(fn, context || emitter, once)
		    , evt = prefix ? prefix + event : event;

		  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
		  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
		  else emitter._events[evt] = [emitter._events[evt], listener];

		  return emitter;
		}

		/**
		 * Clear event by name.
		 *
		 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
		 * @param {(String|Symbol)} evt The Event name.
		 * @private
		 */
		function clearEvent(emitter, evt) {
		  if (--emitter._eventsCount === 0) emitter._events = new Events();
		  else delete emitter._events[evt];
		}

		/**
		 * Minimal `EventEmitter` interface that is molded against the Node.js
		 * `EventEmitter` interface.
		 *
		 * @constructor
		 * @public
		 */
		function EventEmitter() {
		  this._events = new Events();
		  this._eventsCount = 0;
		}

		/**
		 * Return an array listing the events for which the emitter has registered
		 * listeners.
		 *
		 * @returns {Array}
		 * @public
		 */
		EventEmitter.prototype.eventNames = function eventNames() {
		  var names = []
		    , events
		    , name;

		  if (this._eventsCount === 0) return names;

		  for (name in (events = this._events)) {
		    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
		  }

		  if (Object.getOwnPropertySymbols) {
		    return names.concat(Object.getOwnPropertySymbols(events));
		  }

		  return names;
		};

		/**
		 * Return the listeners registered for a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @returns {Array} The registered listeners.
		 * @public
		 */
		EventEmitter.prototype.listeners = function listeners(event) {
		  var evt = prefix ? prefix + event : event
		    , handlers = this._events[evt];

		  if (!handlers) return [];
		  if (handlers.fn) return [handlers.fn];

		  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
		    ee[i] = handlers[i].fn;
		  }

		  return ee;
		};

		/**
		 * Return the number of listeners listening to a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @returns {Number} The number of listeners.
		 * @public
		 */
		EventEmitter.prototype.listenerCount = function listenerCount(event) {
		  var evt = prefix ? prefix + event : event
		    , listeners = this._events[evt];

		  if (!listeners) return 0;
		  if (listeners.fn) return 1;
		  return listeners.length;
		};

		/**
		 * Calls each of the listeners registered for a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @returns {Boolean} `true` if the event had listeners, else `false`.
		 * @public
		 */
		EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
		  var evt = prefix ? prefix + event : event;

		  if (!this._events[evt]) return false;

		  var listeners = this._events[evt]
		    , len = arguments.length
		    , args
		    , i;

		  if (listeners.fn) {
		    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

		    switch (len) {
		      case 1: return listeners.fn.call(listeners.context), true;
		      case 2: return listeners.fn.call(listeners.context, a1), true;
		      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
		      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
		      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
		      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
		    }

		    for (i = 1, args = new Array(len -1); i < len; i++) {
		      args[i - 1] = arguments[i];
		    }

		    listeners.fn.apply(listeners.context, args);
		  } else {
		    var length = listeners.length
		      , j;

		    for (i = 0; i < length; i++) {
		      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

		      switch (len) {
		        case 1: listeners[i].fn.call(listeners[i].context); break;
		        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
		        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
		        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
		        default:
		          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
		            args[j - 1] = arguments[j];
		          }

		          listeners[i].fn.apply(listeners[i].context, args);
		      }
		    }
		  }

		  return true;
		};

		/**
		 * Add a listener for a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @param {Function} fn The listener function.
		 * @param {*} [context=this] The context to invoke the listener with.
		 * @returns {EventEmitter} `this`.
		 * @public
		 */
		EventEmitter.prototype.on = function on(event, fn, context) {
		  return addListener(this, event, fn, context, false);
		};

		/**
		 * Add a one-time listener for a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @param {Function} fn The listener function.
		 * @param {*} [context=this] The context to invoke the listener with.
		 * @returns {EventEmitter} `this`.
		 * @public
		 */
		EventEmitter.prototype.once = function once(event, fn, context) {
		  return addListener(this, event, fn, context, true);
		};

		/**
		 * Remove the listeners of a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @param {Function} fn Only remove the listeners that match this function.
		 * @param {*} context Only remove the listeners that have this context.
		 * @param {Boolean} once Only remove one-time listeners.
		 * @returns {EventEmitter} `this`.
		 * @public
		 */
		EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
		  var evt = prefix ? prefix + event : event;

		  if (!this._events[evt]) return this;
		  if (!fn) {
		    clearEvent(this, evt);
		    return this;
		  }

		  var listeners = this._events[evt];

		  if (listeners.fn) {
		    if (
		      listeners.fn === fn &&
		      (!once || listeners.once) &&
		      (!context || listeners.context === context)
		    ) {
		      clearEvent(this, evt);
		    }
		  } else {
		    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
		      if (
		        listeners[i].fn !== fn ||
		        (once && !listeners[i].once) ||
		        (context && listeners[i].context !== context)
		      ) {
		        events.push(listeners[i]);
		      }
		    }

		    //
		    // Reset the array, or remove it completely if we have no more listeners.
		    //
		    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
		    else clearEvent(this, evt);
		  }

		  return this;
		};

		/**
		 * Remove all listeners, or those of the specified event.
		 *
		 * @param {(String|Symbol)} [event] The event name.
		 * @returns {EventEmitter} `this`.
		 * @public
		 */
		EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
		  var evt;

		  if (event) {
		    evt = prefix ? prefix + event : event;
		    if (this._events[evt]) clearEvent(this, evt);
		  } else {
		    this._events = new Events();
		    this._eventsCount = 0;
		  }

		  return this;
		};

		//
		// Alias methods names because people roll like that.
		//
		EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
		EventEmitter.prototype.addListener = EventEmitter.prototype.on;

		//
		// Expose the prefix.
		//
		EventEmitter.prefixed = prefix;

		//
		// Allow `EventEmitter` to be imported as module namespace.
		//
		EventEmitter.EventEmitter = EventEmitter;

		//
		// Expose the module.
		//
		{
		  module.exports = EventEmitter;
		} 
	} (eventemitter3));
	return eventemitter3.exports;
}

var eventemitter3Exports = requireEventemitter3();
const EventEmitter$1 = /*@__PURE__*/getDefaultExportFromCjs(eventemitter3Exports);

// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis
function getGlobal() {
  if (typeof globalThis !== 'undefined') {
    return globalThis;
  }
  if (typeof self !== 'undefined') {
    return self;
  }
  if (typeof window !== 'undefined') {
    return window;
  }
  if (typeof global !== 'undefined') {
    return global;
  }
}
function getDevTools() {
  const w = getGlobal();
  if (w.__xstate__) {
    return w.__xstate__;
  }
  return undefined;
}
const devToolsAdapter = service => {
  if (typeof window === 'undefined') {
    return;
  }
  const devTools = getDevTools();
  if (devTools) {
    devTools.register(service);
  }
};

class Mailbox {
  constructor(_process) {
    this._process = _process;
    this._active = false;
    this._current = null;
    this._last = null;
  }
  start() {
    this._active = true;
    this.flush();
  }
  clear() {
    // we can't set _current to null because we might be currently processing
    // and enqueue following clear shouldnt start processing the enqueued item immediately
    if (this._current) {
      this._current.next = null;
      this._last = this._current;
    }
  }
  enqueue(event) {
    const enqueued = {
      value: event,
      next: null
    };
    if (this._current) {
      this._last.next = enqueued;
      this._last = enqueued;
      return;
    }
    this._current = enqueued;
    this._last = enqueued;
    if (this._active) {
      this.flush();
    }
  }
  flush() {
    while (this._current) {
      // atm the given _process is responsible for implementing proper try/catch handling
      // we assume here that this won't throw in a way that can affect this mailbox
      const consumed = this._current;
      this._process(consumed.value);
      this._current = consumed.next;
    }
    this._last = null;
  }
}

const STATE_DELIMITER = '.';
const TARGETLESS_KEY = '';
const NULL_EVENT = '';
const STATE_IDENTIFIER$1 = '#';
const WILDCARD = '*';
const XSTATE_INIT = 'xstate.init';
const XSTATE_STOP = 'xstate.stop';

/**
 * Returns an event that represents an implicit event that is sent after the
 * specified `delay`.
 *
 * @param delayRef The delay in milliseconds
 * @param id The state node ID where this event is handled
 */
function createAfterEvent(delayRef, id) {
  return {
    type: `xstate.after.${delayRef}.${id}`
  };
}

/**
 * Returns an event that represents that a final state node has been reached in
 * the parent state node.
 *
 * @param id The final state node's parent state node `id`
 * @param output The data to pass into the event
 */
function createDoneStateEvent(id, output) {
  return {
    type: `xstate.done.state.${id}`,
    output
  };
}

/**
 * Returns an event that represents that an invoked service has terminated.
 *
 * An invoked service is terminated when it has reached a top-level final state
 * node, but not when it is canceled.
 *
 * @param invokeId The invoked service ID
 * @param output The data to pass into the event
 */
function createDoneActorEvent(invokeId, output) {
  return {
    type: `xstate.done.actor.${invokeId}`,
    output,
    actorId: invokeId
  };
}
function createErrorActorEvent(id, error) {
  return {
    type: `xstate.error.actor.${id}`,
    error,
    actorId: id
  };
}
function createInitEvent(input) {
  return {
    type: XSTATE_INIT,
    input
  };
}

/**
 * This function makes sure that unhandled errors are thrown in a separate
 * macrotask. It allows those errors to be detected by global error handlers and
 * reported to bug tracking services without interrupting our own stack of
 * execution.
 *
 * @param err Error to be thrown
 */
function reportUnhandledError(err) {
  setTimeout(() => {
    throw err;
  });
}

const symbolObservable = (() => typeof Symbol === 'function' && Symbol.observable || '@@observable')();

function matchesState(parentStateId, childStateId) {
  const parentStateValue = toStateValue(parentStateId);
  const childStateValue = toStateValue(childStateId);
  if (typeof childStateValue === 'string') {
    if (typeof parentStateValue === 'string') {
      return childStateValue === parentStateValue;
    }

    // Parent more specific than child
    return false;
  }
  if (typeof parentStateValue === 'string') {
    return parentStateValue in childStateValue;
  }
  return Object.keys(parentStateValue).every(key => {
    if (!(key in childStateValue)) {
      return false;
    }
    return matchesState(parentStateValue[key], childStateValue[key]);
  });
}
function toStatePath(stateId) {
  if (isArray(stateId)) {
    return stateId;
  }
  const result = [];
  let segment = '';
  for (let i = 0; i < stateId.length; i++) {
    const char = stateId.charCodeAt(i);
    switch (char) {
      // \
      case 92:
        // consume the next character
        segment += stateId[i + 1];
        // and skip over it
        i++;
        continue;
      // .
      case 46:
        result.push(segment);
        segment = '';
        continue;
    }
    segment += stateId[i];
  }
  result.push(segment);
  return result;
}
function toStateValue(stateValue) {
  if (isMachineSnapshot(stateValue)) {
    return stateValue.value;
  }
  if (typeof stateValue !== 'string') {
    return stateValue;
  }
  const statePath = toStatePath(stateValue);
  return pathToStateValue(statePath);
}
function pathToStateValue(statePath) {
  if (statePath.length === 1) {
    return statePath[0];
  }
  const value = {};
  let marker = value;
  for (let i = 0; i < statePath.length - 1; i++) {
    if (i === statePath.length - 2) {
      marker[statePath[i]] = statePath[i + 1];
    } else {
      const previous = marker;
      marker = {};
      previous[statePath[i]] = marker;
    }
  }
  return value;
}
function mapValues(collection, iteratee) {
  const result = {};
  const collectionKeys = Object.keys(collection);
  for (let i = 0; i < collectionKeys.length; i++) {
    const key = collectionKeys[i];
    result[key] = iteratee(collection[key], key, collection, i);
  }
  return result;
}
function toArrayStrict(value) {
  if (isArray(value)) {
    return value;
  }
  return [value];
}
function toArray(value) {
  if (value === undefined) {
    return [];
  }
  return toArrayStrict(value);
}
function resolveOutput(mapper, context, event, self) {
  if (typeof mapper === 'function') {
    return mapper({
      context,
      event,
      self
    });
  }
  return mapper;
}
function isArray(value) {
  return Array.isArray(value);
}
function isErrorActorEvent(event) {
  return event.type.startsWith('xstate.error.actor');
}
function toTransitionConfigArray(configLike) {
  return toArrayStrict(configLike).map(transitionLike => {
    if (typeof transitionLike === 'undefined' || typeof transitionLike === 'string') {
      return {
        target: transitionLike
      };
    }
    return transitionLike;
  });
}
function normalizeTarget(target) {
  if (target === undefined || target === TARGETLESS_KEY) {
    return undefined;
  }
  return toArray(target);
}
function toObserver(nextHandler, errorHandler, completionHandler) {
  const isObserver = typeof nextHandler === 'object';
  const self = isObserver ? nextHandler : undefined;
  return {
    next: (isObserver ? nextHandler.next : nextHandler)?.bind(self),
    error: (isObserver ? nextHandler.error : errorHandler)?.bind(self),
    complete: (isObserver ? nextHandler.complete : completionHandler)?.bind(self)
  };
}
function createInvokeId(stateNodeId, index) {
  return `${index}.${stateNodeId}`;
}
function resolveReferencedActor(machine, src) {
  const match = src.match(/^xstate\.invoke\.(\d+)\.(.*)/);
  if (!match) {
    return machine.implementations.actors[src];
  }
  const [, indexStr, nodeId] = match;
  const node = machine.getStateNodeById(nodeId);
  const invokeConfig = node.config.invoke;
  return (Array.isArray(invokeConfig) ? invokeConfig[indexStr] : invokeConfig).src;
}

function createScheduledEventId(actorRef, id) {
  return `${actorRef.sessionId}.${id}`;
}
let idCounter = 0;
function createSystem(rootActor, options) {
  const children = new Map();
  const keyedActors = new Map();
  const reverseKeyedActors = new WeakMap();
  const inspectionObservers = new Set();
  const timerMap = {};
  const {
    clock,
    logger
  } = options;
  const scheduler = {
    schedule: (source, target, event, delay, id = Math.random().toString(36).slice(2)) => {
      const scheduledEvent = {
        source,
        target,
        event,
        delay,
        id,
        startedAt: Date.now()
      };
      const scheduledEventId = createScheduledEventId(source, id);
      system._snapshot._scheduledEvents[scheduledEventId] = scheduledEvent;
      const timeout = clock.setTimeout(() => {
        delete timerMap[scheduledEventId];
        delete system._snapshot._scheduledEvents[scheduledEventId];
        system._relay(source, target, event);
      }, delay);
      timerMap[scheduledEventId] = timeout;
    },
    cancel: (source, id) => {
      const scheduledEventId = createScheduledEventId(source, id);
      const timeout = timerMap[scheduledEventId];
      delete timerMap[scheduledEventId];
      delete system._snapshot._scheduledEvents[scheduledEventId];
      if (timeout !== undefined) {
        clock.clearTimeout(timeout);
      }
    },
    cancelAll: actorRef => {
      for (const scheduledEventId in system._snapshot._scheduledEvents) {
        const scheduledEvent = system._snapshot._scheduledEvents[scheduledEventId];
        if (scheduledEvent.source === actorRef) {
          scheduler.cancel(actorRef, scheduledEvent.id);
        }
      }
    }
  };
  const sendInspectionEvent = event => {
    if (!inspectionObservers.size) {
      return;
    }
    const resolvedInspectionEvent = {
      ...event,
      rootId: rootActor.sessionId
    };
    inspectionObservers.forEach(observer => observer.next?.(resolvedInspectionEvent));
  };
  const system = {
    _snapshot: {
      _scheduledEvents: (options?.snapshot && options.snapshot.scheduler) ?? {}
    },
    _bookId: () => `x:${idCounter++}`,
    _register: (sessionId, actorRef) => {
      children.set(sessionId, actorRef);
      return sessionId;
    },
    _unregister: actorRef => {
      children.delete(actorRef.sessionId);
      const systemId = reverseKeyedActors.get(actorRef);
      if (systemId !== undefined) {
        keyedActors.delete(systemId);
        reverseKeyedActors.delete(actorRef);
      }
    },
    get: systemId => {
      return keyedActors.get(systemId);
    },
    _set: (systemId, actorRef) => {
      const existing = keyedActors.get(systemId);
      if (existing && existing !== actorRef) {
        throw new Error(`Actor with system ID '${systemId}' already exists.`);
      }
      keyedActors.set(systemId, actorRef);
      reverseKeyedActors.set(actorRef, systemId);
    },
    inspect: observerOrFn => {
      const observer = toObserver(observerOrFn);
      inspectionObservers.add(observer);
      return {
        unsubscribe() {
          inspectionObservers.delete(observer);
        }
      };
    },
    _sendInspectionEvent: sendInspectionEvent,
    _relay: (source, target, event) => {
      system._sendInspectionEvent({
        type: '@xstate.event',
        sourceRef: source,
        actorRef: target,
        event
      });
      target._send(event);
    },
    scheduler,
    getSnapshot: () => {
      return {
        _scheduledEvents: {
          ...system._snapshot._scheduledEvents
        }
      };
    },
    start: () => {
      const scheduledEvents = system._snapshot._scheduledEvents;
      system._snapshot._scheduledEvents = {};
      for (const scheduledId in scheduledEvents) {
        const {
          source,
          target,
          event,
          delay,
          id
        } = scheduledEvents[scheduledId];
        scheduler.schedule(source, target, event, delay, id);
      }
    },
    _clock: clock,
    _logger: logger
  };
  return system;
}

let executingCustomAction = false;
const $$ACTOR_TYPE = 1;

// those values are currently used by @xstate/react directly so it's important to keep the assigned values in sync
let ProcessingStatus = /*#__PURE__*/function (ProcessingStatus) {
  ProcessingStatus[ProcessingStatus["NotStarted"] = 0] = "NotStarted";
  ProcessingStatus[ProcessingStatus["Running"] = 1] = "Running";
  ProcessingStatus[ProcessingStatus["Stopped"] = 2] = "Stopped";
  return ProcessingStatus;
}({});
const defaultOptions$1 = {
  clock: {
    setTimeout: (fn, ms) => {
      return setTimeout(fn, ms);
    },
    clearTimeout: id => {
      return clearTimeout(id);
    }
  },
  logger: console.log.bind(console),
  devTools: false
};

/**
 * An Actor is a running process that can receive events, send events and change
 * its behavior based on the events it receives, which can cause effects outside
 * of the actor. When you run a state machine, it becomes an actor.
 */
class Actor {
  /**
   * Creates a new actor instance for the given logic with the provided options,
   * if any.
   *
   * @param logic The logic to create an actor from
   * @param options Actor options
   */
  constructor(logic, options) {
    this.logic = logic;
    /** The current internal state of the actor. */
    this._snapshot = void 0;
    /**
     * The clock that is responsible for setting and clearing timeouts, such as
     * delayed events and transitions.
     */
    this.clock = void 0;
    this.options = void 0;
    /** The unique identifier for this actor relative to its parent. */
    this.id = void 0;
    this.mailbox = new Mailbox(this._process.bind(this));
    this.observers = new Set();
    this.eventListeners = new Map();
    this.logger = void 0;
    /** @internal */
    this._processingStatus = ProcessingStatus.NotStarted;
    // Actor Ref
    this._parent = void 0;
    /** @internal */
    this._syncSnapshot = void 0;
    this.ref = void 0;
    // TODO: add typings for system
    this._actorScope = void 0;
    this._systemId = void 0;
    /** The globally unique process ID for this invocation. */
    this.sessionId = void 0;
    /** The system to which this actor belongs. */
    this.system = void 0;
    this._doneEvent = void 0;
    this.src = void 0;
    // array of functions to defer
    this._deferred = [];
    const resolvedOptions = {
      ...defaultOptions$1,
      ...options
    };
    const {
      clock,
      logger,
      parent,
      syncSnapshot,
      id,
      systemId,
      inspect
    } = resolvedOptions;
    this.system = parent ? parent.system : createSystem(this, {
      clock,
      logger
    });
    if (inspect && !parent) {
      // Always inspect at the system-level
      this.system.inspect(toObserver(inspect));
    }
    this.sessionId = this.system._bookId();
    this.id = id ?? this.sessionId;
    this.logger = options?.logger ?? this.system._logger;
    this.clock = options?.clock ?? this.system._clock;
    this._parent = parent;
    this._syncSnapshot = syncSnapshot;
    this.options = resolvedOptions;
    this.src = resolvedOptions.src ?? logic;
    this.ref = this;
    this._actorScope = {
      self: this,
      id: this.id,
      sessionId: this.sessionId,
      logger: this.logger,
      defer: fn => {
        this._deferred.push(fn);
      },
      system: this.system,
      stopChild: child => {
        if (child._parent !== this) {
          throw new Error(`Cannot stop child actor ${child.id} of ${this.id} because it is not a child`);
        }
        child._stop();
      },
      emit: emittedEvent => {
        const listeners = this.eventListeners.get(emittedEvent.type);
        const wildcardListener = this.eventListeners.get('*');
        if (!listeners && !wildcardListener) {
          return;
        }
        const allListeners = [...(listeners ? listeners.values() : []), ...(wildcardListener ? wildcardListener.values() : [])];
        for (const handler of allListeners) {
          handler(emittedEvent);
        }
      },
      actionExecutor: action => {
        const exec = () => {
          this._actorScope.system._sendInspectionEvent({
            type: '@xstate.action',
            actorRef: this,
            action: {
              type: action.type,
              params: action.params
            }
          });
          if (!action.exec) {
            return;
          }
          const saveExecutingCustomAction = executingCustomAction;
          try {
            executingCustomAction = true;
            action.exec(action.info, action.params);
          } finally {
            executingCustomAction = saveExecutingCustomAction;
          }
        };
        if (this._processingStatus === ProcessingStatus.Running) {
          exec();
        } else {
          this._deferred.push(exec);
        }
      }
    };

    // Ensure that the send method is bound to this Actor instance
    // if destructured
    this.send = this.send.bind(this);
    this.system._sendInspectionEvent({
      type: '@xstate.actor',
      actorRef: this
    });
    if (systemId) {
      this._systemId = systemId;
      this.system._set(systemId, this);
    }
    this._initState(options?.snapshot ?? options?.state);
    if (systemId && this._snapshot.status !== 'active') {
      this.system._unregister(this);
    }
  }
  _initState(persistedState) {
    try {
      this._snapshot = persistedState ? this.logic.restoreSnapshot ? this.logic.restoreSnapshot(persistedState, this._actorScope) : persistedState : this.logic.getInitialSnapshot(this._actorScope, this.options?.input);
    } catch (err) {
      // if we get here then it means that we assign a value to this._snapshot that is not of the correct type
      // we can't get the true `TSnapshot & { status: 'error'; }`, it's impossible
      // so right now this is a lie of sorts
      this._snapshot = {
        status: 'error',
        output: undefined,
        error: err
      };
    }
  }
  update(snapshot, event) {
    // Update state
    this._snapshot = snapshot;

    // Execute deferred effects
    let deferredFn;
    while (deferredFn = this._deferred.shift()) {
      try {
        deferredFn();
      } catch (err) {
        // this error can only be caught when executing *initial* actions
        // it's the only time when we call actions provided by the user through those deferreds
        // when the actor is already running we always execute them synchronously while transitioning
        // no "builtin deferred" should actually throw an error since they are either safe
        // or the control flow is passed through the mailbox and errors should be caught by the `_process` used by the mailbox
        this._deferred.length = 0;
        this._snapshot = {
          ...snapshot,
          status: 'error',
          error: err
        };
      }
    }
    switch (this._snapshot.status) {
      case 'active':
        for (const observer of this.observers) {
          try {
            observer.next?.(snapshot);
          } catch (err) {
            reportUnhandledError(err);
          }
        }
        break;
      case 'done':
        // next observers are meant to be notified about done snapshots
        // this can be seen as something that is different from how observable work
        // but with observables `complete` callback is called without any arguments
        // it's more ergonomic for XState to treat a done snapshot as a "next" value
        // and the completion event as something that is separate,
        // something that merely follows emitting that done snapshot
        for (const observer of this.observers) {
          try {
            observer.next?.(snapshot);
          } catch (err) {
            reportUnhandledError(err);
          }
        }
        this._stopProcedure();
        this._complete();
        this._doneEvent = createDoneActorEvent(this.id, this._snapshot.output);
        if (this._parent) {
          this.system._relay(this, this._parent, this._doneEvent);
        }
        break;
      case 'error':
        this._error(this._snapshot.error);
        break;
    }
    this.system._sendInspectionEvent({
      type: '@xstate.snapshot',
      actorRef: this,
      event,
      snapshot
    });
  }

  /**
   * Subscribe an observer to an actors snapshot values.
   *
   * @remarks
   * The observer will receive the actors snapshot value when it is emitted.
   * The observer can be:
   *
   * - A plain function that receives the latest snapshot, or
   * - An observer object whose `.next(snapshot)` method receives the latest
   *   snapshot
   *
   * @example
   *
   * ```ts
   * // Observer as a plain function
   * const subscription = actor.subscribe((snapshot) => {
   *   console.log(snapshot);
   * });
   * ```
   *
   * @example
   *
   * ```ts
   * // Observer as an object
   * const subscription = actor.subscribe({
   *   next(snapshot) {
   *     console.log(snapshot);
   *   },
   *   error(err) {
   *     // ...
   *   },
   *   complete() {
   *     // ...
   *   }
   * });
   * ```
   *
   * The return value of `actor.subscribe(observer)` is a subscription object
   * that has an `.unsubscribe()` method. You can call
   * `subscription.unsubscribe()` to unsubscribe the observer:
   *
   * @example
   *
   * ```ts
   * const subscription = actor.subscribe((snapshot) => {
   *   // ...
   * });
   *
   * // Unsubscribe the observer
   * subscription.unsubscribe();
   * ```
   *
   * When the actor is stopped, all of its observers will automatically be
   * unsubscribed.
   *
   * @param observer - Either a plain function that receives the latest
   *   snapshot, or an observer object whose `.next(snapshot)` method receives
   *   the latest snapshot
   */

  subscribe(nextListenerOrObserver, errorListener, completeListener) {
    const observer = toObserver(nextListenerOrObserver, errorListener, completeListener);
    if (this._processingStatus !== ProcessingStatus.Stopped) {
      this.observers.add(observer);
    } else {
      switch (this._snapshot.status) {
        case 'done':
          try {
            observer.complete?.();
          } catch (err) {
            reportUnhandledError(err);
          }
          break;
        case 'error':
          {
            const err = this._snapshot.error;
            if (!observer.error) {
              reportUnhandledError(err);
            } else {
              try {
                observer.error(err);
              } catch (err) {
                reportUnhandledError(err);
              }
            }
            break;
          }
      }
    }
    return {
      unsubscribe: () => {
        this.observers.delete(observer);
      }
    };
  }
  on(type, handler) {
    let listeners = this.eventListeners.get(type);
    if (!listeners) {
      listeners = new Set();
      this.eventListeners.set(type, listeners);
    }
    const wrappedHandler = handler.bind(undefined);
    listeners.add(wrappedHandler);
    return {
      unsubscribe: () => {
        listeners.delete(wrappedHandler);
      }
    };
  }

  /** Starts the Actor from the initial state */
  start() {
    if (this._processingStatus === ProcessingStatus.Running) {
      // Do not restart the service if it is already started
      return this;
    }
    if (this._syncSnapshot) {
      this.subscribe({
        next: snapshot => {
          if (snapshot.status === 'active') {
            this.system._relay(this, this._parent, {
              type: `xstate.snapshot.${this.id}`,
              snapshot
            });
          }
        },
        error: () => {}
      });
    }
    this.system._register(this.sessionId, this);
    if (this._systemId) {
      this.system._set(this._systemId, this);
    }
    this._processingStatus = ProcessingStatus.Running;

    // TODO: this isn't correct when rehydrating
    const initEvent = createInitEvent(this.options.input);
    this.system._sendInspectionEvent({
      type: '@xstate.event',
      sourceRef: this._parent,
      actorRef: this,
      event: initEvent
    });
    const status = this._snapshot.status;
    switch (status) {
      case 'done':
        // a state machine can be "done" upon initialization (it could reach a final state using initial microsteps)
        // we still need to complete observers, flush deferreds etc
        this.update(this._snapshot, initEvent);
        // TODO: rethink cleanup of observers, mailbox, etc
        return this;
      case 'error':
        this._error(this._snapshot.error);
        return this;
    }
    if (!this._parent) {
      this.system.start();
    }
    if (this.logic.start) {
      try {
        this.logic.start(this._snapshot, this._actorScope);
      } catch (err) {
        this._snapshot = {
          ...this._snapshot,
          status: 'error',
          error: err
        };
        this._error(err);
        return this;
      }
    }

    // TODO: this notifies all subscribers but usually this is redundant
    // there is no real change happening here
    // we need to rethink if this needs to be refactored
    this.update(this._snapshot, initEvent);
    if (this.options.devTools) {
      this.attachDevTools();
    }
    this.mailbox.start();
    return this;
  }
  _process(event) {
    let nextState;
    let caughtError;
    try {
      nextState = this.logic.transition(this._snapshot, event, this._actorScope);
    } catch (err) {
      // we wrap it in a box so we can rethrow it later even if falsy value gets caught here
      caughtError = {
        err
      };
    }
    if (caughtError) {
      const {
        err
      } = caughtError;
      this._snapshot = {
        ...this._snapshot,
        status: 'error',
        error: err
      };
      this._error(err);
      return;
    }
    this.update(nextState, event);
    if (event.type === XSTATE_STOP) {
      this._stopProcedure();
      this._complete();
    }
  }
  _stop() {
    if (this._processingStatus === ProcessingStatus.Stopped) {
      return this;
    }
    this.mailbox.clear();
    if (this._processingStatus === ProcessingStatus.NotStarted) {
      this._processingStatus = ProcessingStatus.Stopped;
      return this;
    }
    this.mailbox.enqueue({
      type: XSTATE_STOP
    });
    return this;
  }

  /** Stops the Actor and unsubscribe all listeners. */
  stop() {
    if (this._parent) {
      throw new Error('A non-root actor cannot be stopped directly.');
    }
    return this._stop();
  }
  _complete() {
    for (const observer of this.observers) {
      try {
        observer.complete?.();
      } catch (err) {
        reportUnhandledError(err);
      }
    }
    this.observers.clear();
  }
  _reportError(err) {
    if (!this.observers.size) {
      if (!this._parent) {
        reportUnhandledError(err);
      }
      return;
    }
    let reportError = false;
    for (const observer of this.observers) {
      const errorListener = observer.error;
      reportError ||= !errorListener;
      try {
        errorListener?.(err);
      } catch (err2) {
        reportUnhandledError(err2);
      }
    }
    this.observers.clear();
    if (reportError) {
      reportUnhandledError(err);
    }
  }
  _error(err) {
    this._stopProcedure();
    this._reportError(err);
    if (this._parent) {
      this.system._relay(this, this._parent, createErrorActorEvent(this.id, err));
    }
  }
  // TODO: atm children don't belong entirely to the actor so
  // in a way - it's not even super aware of them
  // so we can't stop them from here but we really should!
  // right now, they are being stopped within the machine's transition
  // but that could throw and leave us with "orphaned" active actors
  _stopProcedure() {
    if (this._processingStatus !== ProcessingStatus.Running) {
      // Actor already stopped; do nothing
      return this;
    }

    // Cancel all delayed events
    this.system.scheduler.cancelAll(this);

    // TODO: mailbox.reset
    this.mailbox.clear();
    // TODO: after `stop` we must prepare ourselves for receiving events again
    // events sent *after* stop signal must be queued
    // it seems like this should be the common behavior for all of our consumers
    // so perhaps this should be unified somehow for all of them
    this.mailbox = new Mailbox(this._process.bind(this));
    this._processingStatus = ProcessingStatus.Stopped;
    this.system._unregister(this);
    return this;
  }

  /** @internal */
  _send(event) {
    if (this._processingStatus === ProcessingStatus.Stopped) {
      return;
    }
    this.mailbox.enqueue(event);
  }

  /**
   * Sends an event to the running Actor to trigger a transition.
   *
   * @param event The event to send
   */
  send(event) {
    this.system._relay(undefined, this, event);
  }
  attachDevTools() {
    const {
      devTools
    } = this.options;
    if (devTools) {
      const resolvedDevToolsAdapter = typeof devTools === 'function' ? devTools : devToolsAdapter;
      resolvedDevToolsAdapter(this);
    }
  }
  toJSON() {
    return {
      xstate$$type: $$ACTOR_TYPE,
      id: this.id
    };
  }

  /**
   * Obtain the internal state of the actor, which can be persisted.
   *
   * @remarks
   * The internal state can be persisted from any actor, not only machines.
   *
   * Note that the persisted state is not the same as the snapshot from
   * {@link Actor.getSnapshot}. Persisted state represents the internal state of
   * the actor, while snapshots represent the actor's last emitted value.
   *
   * Can be restored with {@link ActorOptions.state}
   * @see https://stately.ai/docs/persistence
   */

  getPersistedSnapshot(options) {
    return this.logic.getPersistedSnapshot(this._snapshot, options);
  }
  [symbolObservable]() {
    return this;
  }

  /**
   * Read an actors snapshot synchronously.
   *
   * @remarks
   * The snapshot represent an actor's last emitted value.
   *
   * When an actor receives an event, its internal state may change. An actor
   * may emit a snapshot when a state transition occurs.
   *
   * Note that some actors, such as callback actors generated with
   * `fromCallback`, will not emit snapshots.
   * @see {@link Actor.subscribe} to subscribe to an actors snapshot values.
   * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).
   */
  getSnapshot() {
    return this._snapshot;
  }
}
/**
 * Creates a new actor instance for the given actor logic with the provided
 * options, if any.
 *
 * @remarks
 * When you create an actor from actor logic via `createActor(logic)`, you
 * implicitly create an actor system where the created actor is the root actor.
 * Any actors spawned from this root actor and its descendants are part of that
 * actor system.
 * @example
 *
 * ```ts
 * import { createActor } from 'xstate';
 * import { someActorLogic } from './someActorLogic.ts';
 *
 * // Creating the actor, which implicitly creates an actor system with itself as the root actor
 * const actor = createActor(someActorLogic);
 *
 * actor.subscribe((snapshot) => {
 *   console.log(snapshot);
 * });
 *
 * // Actors must be started by calling `actor.start()`, which will also start the actor system.
 * actor.start();
 *
 * // Actors can receive events
 * actor.send({ type: 'someEvent' });
 *
 * // You can stop root actors by calling `actor.stop()`, which will also stop the actor system and all actors in that system.
 * actor.stop();
 * ```
 *
 * @param logic - The actor logic to create an actor from. For a state machine
 *   actor logic creator, see {@link createMachine}. Other actor logic creators
 *   include {@link fromCallback}, {@link fromEventObservable},
 *   {@link fromObservable}, {@link fromPromise}, and {@link fromTransition}.
 * @param options - Actor options
 */
function createActor(logic, ...[options]) {
  return new Actor(logic, options);
}

/**
 * @deprecated Use `Actor` instead.
 * @alias
 */

function resolveCancel(_, snapshot, actionArgs, actionParams, {
  sendId
}) {
  const resolvedSendId = typeof sendId === 'function' ? sendId(actionArgs, actionParams) : sendId;
  return [snapshot, {
    sendId: resolvedSendId
  }, undefined];
}
function executeCancel(actorScope, params) {
  actorScope.defer(() => {
    actorScope.system.scheduler.cancel(actorScope.self, params.sendId);
  });
}
/**
 * Cancels a delayed `sendTo(...)` action that is waiting to be executed. The
 * canceled `sendTo(...)` action will not send its event or execute, unless the
 * `delay` has already elapsed before `cancel(...)` is called.
 *
 * @example
 *
 * ```ts
 * import { createMachine, sendTo, cancel } from 'xstate';
 *
 * const machine = createMachine({
 *   // ...
 *   on: {
 *     sendEvent: {
 *       actions: sendTo(
 *         'some-actor',
 *         { type: 'someEvent' },
 *         {
 *           id: 'some-id',
 *           delay: 1000
 *         }
 *       )
 *     },
 *     cancelEvent: {
 *       actions: cancel('some-id')
 *     }
 *   }
 * });
 * ```
 *
 * @param sendId The `id` of the `sendTo(...)` action to cancel.
 */
function cancel(sendId) {
  function cancel(_args, _params) {
  }
  cancel.type = 'xstate.cancel';
  cancel.sendId = sendId;
  cancel.resolve = resolveCancel;
  cancel.execute = executeCancel;
  return cancel;
}

function resolveSpawn(actorScope, snapshot, actionArgs, _actionParams, {
  id,
  systemId,
  src,
  input,
  syncSnapshot
}) {
  const logic = typeof src === 'string' ? resolveReferencedActor(snapshot.machine, src) : src;
  const resolvedId = typeof id === 'function' ? id(actionArgs) : id;
  let actorRef;
  let resolvedInput = undefined;
  if (logic) {
    resolvedInput = typeof input === 'function' ? input({
      context: snapshot.context,
      event: actionArgs.event,
      self: actorScope.self
    }) : input;
    actorRef = createActor(logic, {
      id: resolvedId,
      src,
      parent: actorScope.self,
      syncSnapshot,
      systemId,
      input: resolvedInput
    });
  }
  return [cloneMachineSnapshot(snapshot, {
    children: {
      ...snapshot.children,
      [resolvedId]: actorRef
    }
  }), {
    id,
    systemId,
    actorRef,
    src,
    input: resolvedInput
  }, undefined];
}
function executeSpawn(actorScope, {
  actorRef
}) {
  if (!actorRef) {
    return;
  }
  actorScope.defer(() => {
    if (actorRef._processingStatus === ProcessingStatus.Stopped) {
      return;
    }
    actorRef.start();
  });
}
function spawnChild(...[src, {
  id,
  systemId,
  input,
  syncSnapshot = false
} = {}]) {
  function spawnChild(_args, _params) {
  }
  spawnChild.type = 'xstate.spawnChild';
  spawnChild.id = id;
  spawnChild.systemId = systemId;
  spawnChild.src = src;
  spawnChild.input = input;
  spawnChild.syncSnapshot = syncSnapshot;
  spawnChild.resolve = resolveSpawn;
  spawnChild.execute = executeSpawn;
  return spawnChild;
}

function resolveStop(_, snapshot, args, actionParams, {
  actorRef
}) {
  const actorRefOrString = typeof actorRef === 'function' ? actorRef(args, actionParams) : actorRef;
  const resolvedActorRef = typeof actorRefOrString === 'string' ? snapshot.children[actorRefOrString] : actorRefOrString;
  let children = snapshot.children;
  if (resolvedActorRef) {
    children = {
      ...children
    };
    delete children[resolvedActorRef.id];
  }
  return [cloneMachineSnapshot(snapshot, {
    children
  }), resolvedActorRef, undefined];
}
function executeStop(actorScope, actorRef) {
  if (!actorRef) {
    return;
  }

  // we need to eagerly unregister it here so a new actor with the same systemId can be registered immediately
  // since we defer actual stopping of the actor but we don't defer actor creations (and we can't do that)
  // this could throw on `systemId` collision, for example, when dealing with reentering transitions
  actorScope.system._unregister(actorRef);

  // this allows us to prevent an actor from being started if it gets stopped within the same macrostep
  // this can happen, for example, when the invoking state is being exited immediately by an always transition
  if (actorRef._processingStatus !== ProcessingStatus.Running) {
    actorScope.stopChild(actorRef);
    return;
  }
  // stopping a child enqueues a stop event in the child actor's mailbox
  // we need for all of the already enqueued events to be processed before we stop the child
  // the parent itself might want to send some events to a child (for example from exit actions on the invoking state)
  // and we don't want to ignore those events
  actorScope.defer(() => {
    actorScope.stopChild(actorRef);
  });
}
/**
 * Stops a child actor.
 *
 * @param actorRef The actor to stop.
 */
function stopChild(actorRef) {
  function stop(_args, _params) {
  }
  stop.type = 'xstate.stopChild';
  stop.actorRef = actorRef;
  stop.resolve = resolveStop;
  stop.execute = executeStop;
  return stop;
}

// TODO: throw on cycles (depth check should be enough)
function evaluateGuard(guard, context, event, snapshot) {
  const {
    machine
  } = snapshot;
  const isInline = typeof guard === 'function';
  const resolved = isInline ? guard : machine.implementations.guards[typeof guard === 'string' ? guard : guard.type];
  if (!isInline && !resolved) {
    throw new Error(`Guard '${typeof guard === 'string' ? guard : guard.type}' is not implemented.'.`);
  }
  if (typeof resolved !== 'function') {
    return evaluateGuard(resolved, context, event, snapshot);
  }
  const guardArgs = {
    context,
    event
  };
  const guardParams = isInline || typeof guard === 'string' ? undefined : 'params' in guard ? typeof guard.params === 'function' ? guard.params({
    context,
    event
  }) : guard.params : undefined;
  if (!('check' in resolved)) {
    // the existing type of `.guards` assumes non-nullable `TExpressionGuard`
    // inline guards expect `TExpressionGuard` to be set to `undefined`
    // it's fine to cast this here, our logic makes sure that we call those 2 "variants" correctly
    return resolved(guardArgs, guardParams);
  }
  const builtinGuard = resolved;
  return builtinGuard.check(snapshot, guardArgs, resolved // this holds all params
  );
}

const isAtomicStateNode = stateNode => stateNode.type === 'atomic' || stateNode.type === 'final';
function getChildren(stateNode) {
  return Object.values(stateNode.states).filter(sn => sn.type !== 'history');
}
function getProperAncestors(stateNode, toStateNode) {
  const ancestors = [];
  if (toStateNode === stateNode) {
    return ancestors;
  }

  // add all ancestors
  let m = stateNode.parent;
  while (m && m !== toStateNode) {
    ancestors.push(m);
    m = m.parent;
  }
  return ancestors;
}
function getAllStateNodes(stateNodes) {
  const nodeSet = new Set(stateNodes);
  const adjList = getAdjList(nodeSet);

  // add descendants
  for (const s of nodeSet) {
    // if previously active, add existing child nodes
    if (s.type === 'compound' && (!adjList.get(s) || !adjList.get(s).length)) {
      getInitialStateNodesWithTheirAncestors(s).forEach(sn => nodeSet.add(sn));
    } else {
      if (s.type === 'parallel') {
        for (const child of getChildren(s)) {
          if (child.type === 'history') {
            continue;
          }
          if (!nodeSet.has(child)) {
            const initialStates = getInitialStateNodesWithTheirAncestors(child);
            for (const initialStateNode of initialStates) {
              nodeSet.add(initialStateNode);
            }
          }
        }
      }
    }
  }

  // add all ancestors
  for (const s of nodeSet) {
    let m = s.parent;
    while (m) {
      nodeSet.add(m);
      m = m.parent;
    }
  }
  return nodeSet;
}
function getValueFromAdj(baseNode, adjList) {
  const childStateNodes = adjList.get(baseNode);
  if (!childStateNodes) {
    return {}; // todo: fix?
  }
  if (baseNode.type === 'compound') {
    const childStateNode = childStateNodes[0];
    if (childStateNode) {
      if (isAtomicStateNode(childStateNode)) {
        return childStateNode.key;
      }
    } else {
      return {};
    }
  }
  const stateValue = {};
  for (const childStateNode of childStateNodes) {
    stateValue[childStateNode.key] = getValueFromAdj(childStateNode, adjList);
  }
  return stateValue;
}
function getAdjList(stateNodes) {
  const adjList = new Map();
  for (const s of stateNodes) {
    if (!adjList.has(s)) {
      adjList.set(s, []);
    }
    if (s.parent) {
      if (!adjList.has(s.parent)) {
        adjList.set(s.parent, []);
      }
      adjList.get(s.parent).push(s);
    }
  }
  return adjList;
}
function getStateValue(rootNode, stateNodes) {
  const config = getAllStateNodes(stateNodes);
  return getValueFromAdj(rootNode, getAdjList(config));
}
function isInFinalState(stateNodeSet, stateNode) {
  if (stateNode.type === 'compound') {
    return getChildren(stateNode).some(s => s.type === 'final' && stateNodeSet.has(s));
  }
  if (stateNode.type === 'parallel') {
    return getChildren(stateNode).every(sn => isInFinalState(stateNodeSet, sn));
  }
  return stateNode.type === 'final';
}
const isStateId = str => str[0] === STATE_IDENTIFIER$1;
function getCandidates(stateNode, receivedEventType) {
  const candidates = stateNode.transitions.get(receivedEventType) || [...stateNode.transitions.keys()].filter(eventDescriptor => {
    // check if transition is a wildcard transition,
    // which matches any non-transient events
    if (eventDescriptor === WILDCARD) {
      return true;
    }
    if (!eventDescriptor.endsWith('.*')) {
      return false;
    }
    const partialEventTokens = eventDescriptor.split('.');
    const eventTokens = receivedEventType.split('.');
    for (let tokenIndex = 0; tokenIndex < partialEventTokens.length; tokenIndex++) {
      const partialEventToken = partialEventTokens[tokenIndex];
      const eventToken = eventTokens[tokenIndex];
      if (partialEventToken === '*') {
        const isLastToken = tokenIndex === partialEventTokens.length - 1;
        return isLastToken;
      }
      if (partialEventToken !== eventToken) {
        return false;
      }
    }
    return true;
  }).sort((a, b) => b.length - a.length).flatMap(key => stateNode.transitions.get(key));
  return candidates;
}

/** All delayed transitions from the config. */
function getDelayedTransitions(stateNode) {
  const afterConfig = stateNode.config.after;
  if (!afterConfig) {
    return [];
  }
  const mutateEntryExit = delay => {
    const afterEvent = createAfterEvent(delay, stateNode.id);
    const eventType = afterEvent.type;
    stateNode.entry.push(raise(afterEvent, {
      id: eventType,
      delay
    }));
    stateNode.exit.push(cancel(eventType));
    return eventType;
  };
  const delayedTransitions = Object.keys(afterConfig).flatMap(delay => {
    const configTransition = afterConfig[delay];
    const resolvedTransition = typeof configTransition === 'string' ? {
      target: configTransition
    } : configTransition;
    const resolvedDelay = Number.isNaN(+delay) ? delay : +delay;
    const eventType = mutateEntryExit(resolvedDelay);
    return toArray(resolvedTransition).map(transition => ({
      ...transition,
      event: eventType,
      delay: resolvedDelay
    }));
  });
  return delayedTransitions.map(delayedTransition => {
    const {
      delay
    } = delayedTransition;
    return {
      ...formatTransition(stateNode, delayedTransition.event, delayedTransition),
      delay
    };
  });
}
function formatTransition(stateNode, descriptor, transitionConfig) {
  const normalizedTarget = normalizeTarget(transitionConfig.target);
  const reenter = transitionConfig.reenter ?? false;
  const target = resolveTarget(stateNode, normalizedTarget);
  const transition = {
    ...transitionConfig,
    actions: toArray(transitionConfig.actions),
    guard: transitionConfig.guard,
    target,
    source: stateNode,
    reenter,
    eventType: descriptor,
    toJSON: () => ({
      ...transition,
      source: `#${stateNode.id}`,
      target: target ? target.map(t => `#${t.id}`) : undefined
    })
  };
  return transition;
}
function formatTransitions(stateNode) {
  const transitions = new Map();
  if (stateNode.config.on) {
    for (const descriptor of Object.keys(stateNode.config.on)) {
      if (descriptor === NULL_EVENT) {
        throw new Error('Null events ("") cannot be specified as a transition key. Use `always: { ... }` instead.');
      }
      const transitionsConfig = stateNode.config.on[descriptor];
      transitions.set(descriptor, toTransitionConfigArray(transitionsConfig).map(t => formatTransition(stateNode, descriptor, t)));
    }
  }
  if (stateNode.config.onDone) {
    const descriptor = `xstate.done.state.${stateNode.id}`;
    transitions.set(descriptor, toTransitionConfigArray(stateNode.config.onDone).map(t => formatTransition(stateNode, descriptor, t)));
  }
  for (const invokeDef of stateNode.invoke) {
    if (invokeDef.onDone) {
      const descriptor = `xstate.done.actor.${invokeDef.id}`;
      transitions.set(descriptor, toTransitionConfigArray(invokeDef.onDone).map(t => formatTransition(stateNode, descriptor, t)));
    }
    if (invokeDef.onError) {
      const descriptor = `xstate.error.actor.${invokeDef.id}`;
      transitions.set(descriptor, toTransitionConfigArray(invokeDef.onError).map(t => formatTransition(stateNode, descriptor, t)));
    }
    if (invokeDef.onSnapshot) {
      const descriptor = `xstate.snapshot.${invokeDef.id}`;
      transitions.set(descriptor, toTransitionConfigArray(invokeDef.onSnapshot).map(t => formatTransition(stateNode, descriptor, t)));
    }
  }
  for (const delayedTransition of stateNode.after) {
    let existing = transitions.get(delayedTransition.eventType);
    if (!existing) {
      existing = [];
      transitions.set(delayedTransition.eventType, existing);
    }
    existing.push(delayedTransition);
  }
  return transitions;
}
function formatInitialTransition(stateNode, _target) {
  const resolvedTarget = typeof _target === 'string' ? stateNode.states[_target] : _target ? stateNode.states[_target.target] : undefined;
  if (!resolvedTarget && _target) {
    throw new Error(
    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-base-to-string
    `Initial state node "${_target}" not found on parent state node #${stateNode.id}`);
  }
  const transition = {
    source: stateNode,
    actions: !_target || typeof _target === 'string' ? [] : toArray(_target.actions),
    eventType: null,
    reenter: false,
    target: resolvedTarget ? [resolvedTarget] : [],
    toJSON: () => ({
      ...transition,
      source: `#${stateNode.id}`,
      target: resolvedTarget ? [`#${resolvedTarget.id}`] : []
    })
  };
  return transition;
}
function resolveTarget(stateNode, targets) {
  if (targets === undefined) {
    // an undefined target signals that the state node should not transition from that state when receiving that event
    return undefined;
  }
  return targets.map(target => {
    if (typeof target !== 'string') {
      return target;
    }
    if (isStateId(target)) {
      return stateNode.machine.getStateNodeById(target);
    }
    const isInternalTarget = target[0] === STATE_DELIMITER;
    // If internal target is defined on machine,
    // do not include machine key on target
    if (isInternalTarget && !stateNode.parent) {
      return getStateNodeByPath(stateNode, target.slice(1));
    }
    const resolvedTarget = isInternalTarget ? stateNode.key + target : target;
    if (stateNode.parent) {
      try {
        const targetStateNode = getStateNodeByPath(stateNode.parent, resolvedTarget);
        return targetStateNode;
      } catch (err) {
        throw new Error(`Invalid transition definition for state node '${stateNode.id}':\n${err.message}`);
      }
    } else {
      throw new Error(`Invalid target: "${target}" is not a valid target from the root node. Did you mean ".${target}"?`);
    }
  });
}
function resolveHistoryDefaultTransition(stateNode) {
  const normalizedTarget = normalizeTarget(stateNode.config.target);
  if (!normalizedTarget) {
    return stateNode.parent.initial;
  }
  return {
    target: normalizedTarget.map(t => typeof t === 'string' ? getStateNodeByPath(stateNode.parent, t) : t)
  };
}
function isHistoryNode(stateNode) {
  return stateNode.type === 'history';
}
function getInitialStateNodesWithTheirAncestors(stateNode) {
  const states = getInitialStateNodes(stateNode);
  for (const initialState of states) {
    for (const ancestor of getProperAncestors(initialState, stateNode)) {
      states.add(ancestor);
    }
  }
  return states;
}
function getInitialStateNodes(stateNode) {
  const set = new Set();
  function iter(descStateNode) {
    if (set.has(descStateNode)) {
      return;
    }
    set.add(descStateNode);
    if (descStateNode.type === 'compound') {
      iter(descStateNode.initial.target[0]);
    } else if (descStateNode.type === 'parallel') {
      for (const child of getChildren(descStateNode)) {
        iter(child);
      }
    }
  }
  iter(stateNode);
  return set;
}
/** Returns the child state node from its relative `stateKey`, or throws. */
function getStateNode(stateNode, stateKey) {
  if (isStateId(stateKey)) {
    return stateNode.machine.getStateNodeById(stateKey);
  }
  if (!stateNode.states) {
    throw new Error(`Unable to retrieve child state '${stateKey}' from '${stateNode.id}'; no child states exist.`);
  }
  const result = stateNode.states[stateKey];
  if (!result) {
    throw new Error(`Child state '${stateKey}' does not exist on '${stateNode.id}'`);
  }
  return result;
}

/**
 * Returns the relative state node from the given `statePath`, or throws.
 *
 * @param statePath The string or string array relative path to the state node.
 */
function getStateNodeByPath(stateNode, statePath) {
  if (typeof statePath === 'string' && isStateId(statePath)) {
    try {
      return stateNode.machine.getStateNodeById(statePath);
    } catch {
      // try individual paths
      // throw e;
    }
  }
  const arrayStatePath = toStatePath(statePath).slice();
  let currentStateNode = stateNode;
  while (arrayStatePath.length) {
    const key = arrayStatePath.shift();
    if (!key.length) {
      break;
    }
    currentStateNode = getStateNode(currentStateNode, key);
  }
  return currentStateNode;
}

/**
 * Returns the state nodes represented by the current state value.
 *
 * @param stateValue The state value or State instance
 */
function getStateNodes(stateNode, stateValue) {
  if (typeof stateValue === 'string') {
    const childStateNode = stateNode.states[stateValue];
    if (!childStateNode) {
      throw new Error(`State '${stateValue}' does not exist on '${stateNode.id}'`);
    }
    return [stateNode, childStateNode];
  }
  const childStateKeys = Object.keys(stateValue);
  const childStateNodes = childStateKeys.map(subStateKey => getStateNode(stateNode, subStateKey)).filter(Boolean);
  return [stateNode.machine.root, stateNode].concat(childStateNodes, childStateKeys.reduce((allSubStateNodes, subStateKey) => {
    const subStateNode = getStateNode(stateNode, subStateKey);
    if (!subStateNode) {
      return allSubStateNodes;
    }
    const subStateNodes = getStateNodes(subStateNode, stateValue[subStateKey]);
    return allSubStateNodes.concat(subStateNodes);
  }, []));
}
function transitionAtomicNode(stateNode, stateValue, snapshot, event) {
  const childStateNode = getStateNode(stateNode, stateValue);
  const next = childStateNode.next(snapshot, event);
  if (!next || !next.length) {
    return stateNode.next(snapshot, event);
  }
  return next;
}
function transitionCompoundNode(stateNode, stateValue, snapshot, event) {
  const subStateKeys = Object.keys(stateValue);
  const childStateNode = getStateNode(stateNode, subStateKeys[0]);
  const next = transitionNode(childStateNode, stateValue[subStateKeys[0]], snapshot, event);
  if (!next || !next.length) {
    return stateNode.next(snapshot, event);
  }
  return next;
}
function transitionParallelNode(stateNode, stateValue, snapshot, event) {
  const allInnerTransitions = [];
  for (const subStateKey of Object.keys(stateValue)) {
    const subStateValue = stateValue[subStateKey];
    if (!subStateValue) {
      continue;
    }
    const subStateNode = getStateNode(stateNode, subStateKey);
    const innerTransitions = transitionNode(subStateNode, subStateValue, snapshot, event);
    if (innerTransitions) {
      allInnerTransitions.push(...innerTransitions);
    }
  }
  if (!allInnerTransitions.length) {
    return stateNode.next(snapshot, event);
  }
  return allInnerTransitions;
}
function transitionNode(stateNode, stateValue, snapshot, event) {
  // leaf node
  if (typeof stateValue === 'string') {
    return transitionAtomicNode(stateNode, stateValue, snapshot, event);
  }

  // compound node
  if (Object.keys(stateValue).length === 1) {
    return transitionCompoundNode(stateNode, stateValue, snapshot, event);
  }

  // parallel node
  return transitionParallelNode(stateNode, stateValue, snapshot, event);
}
function getHistoryNodes(stateNode) {
  return Object.keys(stateNode.states).map(key => stateNode.states[key]).filter(sn => sn.type === 'history');
}
function isDescendant(childStateNode, parentStateNode) {
  let marker = childStateNode;
  while (marker.parent && marker.parent !== parentStateNode) {
    marker = marker.parent;
  }
  return marker.parent === parentStateNode;
}
function hasIntersection(s1, s2) {
  const set1 = new Set(s1);
  const set2 = new Set(s2);
  for (const item of set1) {
    if (set2.has(item)) {
      return true;
    }
  }
  for (const item of set2) {
    if (set1.has(item)) {
      return true;
    }
  }
  return false;
}
function removeConflictingTransitions(enabledTransitions, stateNodeSet, historyValue) {
  const filteredTransitions = new Set();
  for (const t1 of enabledTransitions) {
    let t1Preempted = false;
    const transitionsToRemove = new Set();
    for (const t2 of filteredTransitions) {
      if (hasIntersection(computeExitSet([t1], stateNodeSet, historyValue), computeExitSet([t2], stateNodeSet, historyValue))) {
        if (isDescendant(t1.source, t2.source)) {
          transitionsToRemove.add(t2);
        } else {
          t1Preempted = true;
          break;
        }
      }
    }
    if (!t1Preempted) {
      for (const t3 of transitionsToRemove) {
        filteredTransitions.delete(t3);
      }
      filteredTransitions.add(t1);
    }
  }
  return Array.from(filteredTransitions);
}
function findLeastCommonAncestor(stateNodes) {
  const [head, ...tail] = stateNodes;
  for (const ancestor of getProperAncestors(head, undefined)) {
    if (tail.every(sn => isDescendant(sn, ancestor))) {
      return ancestor;
    }
  }
}
function getEffectiveTargetStates(transition, historyValue) {
  if (!transition.target) {
    return [];
  }
  const targets = new Set();
  for (const targetNode of transition.target) {
    if (isHistoryNode(targetNode)) {
      if (historyValue[targetNode.id]) {
        for (const node of historyValue[targetNode.id]) {
          targets.add(node);
        }
      } else {
        for (const node of getEffectiveTargetStates(resolveHistoryDefaultTransition(targetNode), historyValue)) {
          targets.add(node);
        }
      }
    } else {
      targets.add(targetNode);
    }
  }
  return [...targets];
}
function getTransitionDomain(transition, historyValue) {
  const targetStates = getEffectiveTargetStates(transition, historyValue);
  if (!targetStates) {
    return;
  }
  if (!transition.reenter && targetStates.every(target => target === transition.source || isDescendant(target, transition.source))) {
    return transition.source;
  }
  const lca = findLeastCommonAncestor(targetStates.concat(transition.source));
  if (lca) {
    return lca;
  }

  // at this point we know that it's a root transition since LCA couldn't be found
  if (transition.reenter) {
    return;
  }
  return transition.source.machine.root;
}
function computeExitSet(transitions, stateNodeSet, historyValue) {
  const statesToExit = new Set();
  for (const t of transitions) {
    if (t.target?.length) {
      const domain = getTransitionDomain(t, historyValue);
      if (t.reenter && t.source === domain) {
        statesToExit.add(domain);
      }
      for (const stateNode of stateNodeSet) {
        if (isDescendant(stateNode, domain)) {
          statesToExit.add(stateNode);
        }
      }
    }
  }
  return [...statesToExit];
}
function areStateNodeCollectionsEqual(prevStateNodes, nextStateNodeSet) {
  if (prevStateNodes.length !== nextStateNodeSet.size) {
    return false;
  }
  for (const node of prevStateNodes) {
    if (!nextStateNodeSet.has(node)) {
      return false;
    }
  }
  return true;
}

/** https://www.w3.org/TR/scxml/#microstepProcedure */
function microstep(transitions, currentSnapshot, actorScope, event, isInitial, internalQueue) {
  if (!transitions.length) {
    return currentSnapshot;
  }
  const mutStateNodeSet = new Set(currentSnapshot._nodes);
  let historyValue = currentSnapshot.historyValue;
  const filteredTransitions = removeConflictingTransitions(transitions, mutStateNodeSet, historyValue);
  let nextState = currentSnapshot;

  // Exit states
  if (!isInitial) {
    [nextState, historyValue] = exitStates(nextState, event, actorScope, filteredTransitions, mutStateNodeSet, historyValue, internalQueue, actorScope.actionExecutor);
  }

  // Execute transition content
  nextState = resolveActionsAndContext(nextState, event, actorScope, filteredTransitions.flatMap(t => t.actions), internalQueue, undefined);

  // Enter states
  nextState = enterStates(nextState, event, actorScope, filteredTransitions, mutStateNodeSet, internalQueue, historyValue, isInitial);
  const nextStateNodes = [...mutStateNodeSet];
  if (nextState.status === 'done') {
    nextState = resolveActionsAndContext(nextState, event, actorScope, nextStateNodes.sort((a, b) => b.order - a.order).flatMap(state => state.exit), internalQueue, undefined);
  }

  // eslint-disable-next-line no-useless-catch
  try {
    if (historyValue === currentSnapshot.historyValue && areStateNodeCollectionsEqual(currentSnapshot._nodes, mutStateNodeSet)) {
      return nextState;
    }
    return cloneMachineSnapshot(nextState, {
      _nodes: nextStateNodes,
      historyValue
    });
  } catch (e) {
    // TODO: Refactor this once proper error handling is implemented.
    // See https://github.com/statelyai/rfcs/pull/4
    throw e;
  }
}
function getMachineOutput(snapshot, event, actorScope, rootNode, rootCompletionNode) {
  if (rootNode.output === undefined) {
    return;
  }
  const doneStateEvent = createDoneStateEvent(rootCompletionNode.id, rootCompletionNode.output !== undefined && rootCompletionNode.parent ? resolveOutput(rootCompletionNode.output, snapshot.context, event, actorScope.self) : undefined);
  return resolveOutput(rootNode.output, snapshot.context, doneStateEvent, actorScope.self);
}
function enterStates(currentSnapshot, event, actorScope, filteredTransitions, mutStateNodeSet, internalQueue, historyValue, isInitial) {
  let nextSnapshot = currentSnapshot;
  const statesToEnter = new Set();
  // those are states that were directly targeted or indirectly targeted by the explicit target
  // in other words, those are states for which initial actions should be executed
  // when we target `#deep_child` initial actions of its ancestors shouldn't be executed
  const statesForDefaultEntry = new Set();
  computeEntrySet(filteredTransitions, historyValue, statesForDefaultEntry, statesToEnter);

  // In the initial state, the root state node is "entered".
  if (isInitial) {
    statesForDefaultEntry.add(currentSnapshot.machine.root);
  }
  const completedNodes = new Set();
  for (const stateNodeToEnter of [...statesToEnter].sort((a, b) => a.order - b.order)) {
    mutStateNodeSet.add(stateNodeToEnter);
    const actions = [];

    // Add entry actions
    actions.push(...stateNodeToEnter.entry);
    for (const invokeDef of stateNodeToEnter.invoke) {
      actions.push(spawnChild(invokeDef.src, {
        ...invokeDef,
        syncSnapshot: !!invokeDef.onSnapshot
      }));
    }
    if (statesForDefaultEntry.has(stateNodeToEnter)) {
      const initialActions = stateNodeToEnter.initial.actions;
      actions.push(...initialActions);
    }
    nextSnapshot = resolveActionsAndContext(nextSnapshot, event, actorScope, actions, internalQueue, stateNodeToEnter.invoke.map(invokeDef => invokeDef.id));
    if (stateNodeToEnter.type === 'final') {
      const parent = stateNodeToEnter.parent;
      let ancestorMarker = parent?.type === 'parallel' ? parent : parent?.parent;
      let rootCompletionNode = ancestorMarker || stateNodeToEnter;
      if (parent?.type === 'compound') {
        internalQueue.push(createDoneStateEvent(parent.id, stateNodeToEnter.output !== undefined ? resolveOutput(stateNodeToEnter.output, nextSnapshot.context, event, actorScope.self) : undefined));
      }
      while (ancestorMarker?.type === 'parallel' && !completedNodes.has(ancestorMarker) && isInFinalState(mutStateNodeSet, ancestorMarker)) {
        completedNodes.add(ancestorMarker);
        internalQueue.push(createDoneStateEvent(ancestorMarker.id));
        rootCompletionNode = ancestorMarker;
        ancestorMarker = ancestorMarker.parent;
      }
      if (ancestorMarker) {
        continue;
      }
      nextSnapshot = cloneMachineSnapshot(nextSnapshot, {
        status: 'done',
        output: getMachineOutput(nextSnapshot, event, actorScope, nextSnapshot.machine.root, rootCompletionNode)
      });
    }
  }
  return nextSnapshot;
}
function computeEntrySet(transitions, historyValue, statesForDefaultEntry, statesToEnter) {
  for (const t of transitions) {
    const domain = getTransitionDomain(t, historyValue);
    for (const s of t.target || []) {
      if (!isHistoryNode(s) && (
      // if the target is different than the source then it will *definitely* be entered
      t.source !== s ||
      // we know that the domain can't lie within the source
      // if it's different than the source then it's outside of it and it means that the target has to be entered as well
      t.source !== domain ||
      // reentering transitions always enter the target, even if it's the source itself
      t.reenter)) {
        statesToEnter.add(s);
        statesForDefaultEntry.add(s);
      }
      addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);
    }
    const targetStates = getEffectiveTargetStates(t, historyValue);
    for (const s of targetStates) {
      const ancestors = getProperAncestors(s, domain);
      if (domain?.type === 'parallel') {
        ancestors.push(domain);
      }
      addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, ancestors, !t.source.parent && t.reenter ? undefined : domain);
    }
  }
}
function addDescendantStatesToEnter(stateNode, historyValue, statesForDefaultEntry, statesToEnter) {
  if (isHistoryNode(stateNode)) {
    if (historyValue[stateNode.id]) {
      const historyStateNodes = historyValue[stateNode.id];
      for (const s of historyStateNodes) {
        statesToEnter.add(s);
        addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);
      }
      for (const s of historyStateNodes) {
        addProperAncestorStatesToEnter(s, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);
      }
    } else {
      const historyDefaultTransition = resolveHistoryDefaultTransition(stateNode);
      for (const s of historyDefaultTransition.target) {
        statesToEnter.add(s);
        if (historyDefaultTransition === stateNode.parent?.initial) {
          statesForDefaultEntry.add(stateNode.parent);
        }
        addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);
      }
      for (const s of historyDefaultTransition.target) {
        addProperAncestorStatesToEnter(s, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);
      }
    }
  } else {
    if (stateNode.type === 'compound') {
      const [initialState] = stateNode.initial.target;
      if (!isHistoryNode(initialState)) {
        statesToEnter.add(initialState);
        statesForDefaultEntry.add(initialState);
      }
      addDescendantStatesToEnter(initialState, historyValue, statesForDefaultEntry, statesToEnter);
      addProperAncestorStatesToEnter(initialState, stateNode, statesToEnter, historyValue, statesForDefaultEntry);
    } else {
      if (stateNode.type === 'parallel') {
        for (const child of getChildren(stateNode).filter(sn => !isHistoryNode(sn))) {
          if (![...statesToEnter].some(s => isDescendant(s, child))) {
            if (!isHistoryNode(child)) {
              statesToEnter.add(child);
              statesForDefaultEntry.add(child);
            }
            addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter);
          }
        }
      }
    }
  }
}
function addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, ancestors, reentrancyDomain) {
  for (const anc of ancestors) {
    if (!reentrancyDomain || isDescendant(anc, reentrancyDomain)) {
      statesToEnter.add(anc);
    }
    if (anc.type === 'parallel') {
      for (const child of getChildren(anc).filter(sn => !isHistoryNode(sn))) {
        if (![...statesToEnter].some(s => isDescendant(s, child))) {
          statesToEnter.add(child);
          addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter);
        }
      }
    }
  }
}
function addProperAncestorStatesToEnter(stateNode, toStateNode, statesToEnter, historyValue, statesForDefaultEntry) {
  addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, getProperAncestors(stateNode, toStateNode));
}
function exitStates(currentSnapshot, event, actorScope, transitions, mutStateNodeSet, historyValue, internalQueue, _actionExecutor) {
  let nextSnapshot = currentSnapshot;
  const statesToExit = computeExitSet(transitions, mutStateNodeSet, historyValue);
  statesToExit.sort((a, b) => b.order - a.order);
  let changedHistory;

  // From SCXML algorithm: https://www.w3.org/TR/scxml/#exitStates
  for (const exitStateNode of statesToExit) {
    for (const historyNode of getHistoryNodes(exitStateNode)) {
      let predicate;
      if (historyNode.history === 'deep') {
        predicate = sn => isAtomicStateNode(sn) && isDescendant(sn, exitStateNode);
      } else {
        predicate = sn => {
          return sn.parent === exitStateNode;
        };
      }
      changedHistory ??= {
        ...historyValue
      };
      changedHistory[historyNode.id] = Array.from(mutStateNodeSet).filter(predicate);
    }
  }
  for (const s of statesToExit) {
    nextSnapshot = resolveActionsAndContext(nextSnapshot, event, actorScope, [...s.exit, ...s.invoke.map(def => stopChild(def.id))], internalQueue, undefined);
    mutStateNodeSet.delete(s);
  }
  return [nextSnapshot, changedHistory || historyValue];
}
function getAction(machine, actionType) {
  return machine.implementations.actions[actionType];
}
function resolveAndExecuteActionsWithContext(currentSnapshot, event, actorScope, actions, extra, retries) {
  const {
    machine
  } = currentSnapshot;
  let intermediateSnapshot = currentSnapshot;
  for (const action of actions) {
    const isInline = typeof action === 'function';
    const resolvedAction = isInline ? action :
    // the existing type of `.actions` assumes non-nullable `TExpressionAction`
    // it's fine to cast this here to get a common type and lack of errors in the rest of the code
    // our logic below makes sure that we call those 2 "variants" correctly

    getAction(machine, typeof action === 'string' ? action : action.type);
    const actionArgs = {
      context: intermediateSnapshot.context,
      event,
      self: actorScope.self,
      system: actorScope.system
    };
    const actionParams = isInline || typeof action === 'string' ? undefined : 'params' in action ? typeof action.params === 'function' ? action.params({
      context: intermediateSnapshot.context,
      event
    }) : action.params : undefined;
    if (!resolvedAction || !('resolve' in resolvedAction)) {
      actorScope.actionExecutor({
        type: typeof action === 'string' ? action : typeof action === 'object' ? action.type : action.name || '(anonymous)',
        info: actionArgs,
        params: actionParams,
        exec: resolvedAction
      });
      continue;
    }
    const builtinAction = resolvedAction;
    const [nextState, params, actions] = builtinAction.resolve(actorScope, intermediateSnapshot, actionArgs, actionParams, resolvedAction,
    // this holds all params
    extra);
    intermediateSnapshot = nextState;
    if ('retryResolve' in builtinAction) {
      retries?.push([builtinAction, params]);
    }
    if ('execute' in builtinAction) {
      actorScope.actionExecutor({
        type: builtinAction.type,
        info: actionArgs,
        params,
        exec: builtinAction.execute.bind(null, actorScope, params)
      });
    }
    if (actions) {
      intermediateSnapshot = resolveAndExecuteActionsWithContext(intermediateSnapshot, event, actorScope, actions, extra, retries);
    }
  }
  return intermediateSnapshot;
}
function resolveActionsAndContext(currentSnapshot, event, actorScope, actions, internalQueue, deferredActorIds) {
  const retries = deferredActorIds ? [] : undefined;
  const nextState = resolveAndExecuteActionsWithContext(currentSnapshot, event, actorScope, actions, {
    internalQueue,
    deferredActorIds
  }, retries);
  retries?.forEach(([builtinAction, params]) => {
    builtinAction.retryResolve(actorScope, nextState, params);
  });
  return nextState;
}
function macrostep(snapshot, event, actorScope, internalQueue) {
  let nextSnapshot = snapshot;
  const microstates = [];
  function addMicrostate(microstate, event, transitions) {
    actorScope.system._sendInspectionEvent({
      type: '@xstate.microstep',
      actorRef: actorScope.self,
      event,
      snapshot: microstate,
      _transitions: transitions
    });
    microstates.push(microstate);
  }

  // Handle stop event
  if (event.type === XSTATE_STOP) {
    nextSnapshot = cloneMachineSnapshot(stopChildren(nextSnapshot, event, actorScope), {
      status: 'stopped'
    });
    addMicrostate(nextSnapshot, event, []);
    return {
      snapshot: nextSnapshot,
      microstates
    };
  }
  let nextEvent = event;

  // Assume the state is at rest (no raised events)
  // Determine the next state based on the next microstep
  if (nextEvent.type !== XSTATE_INIT) {
    const currentEvent = nextEvent;
    const isErr = isErrorActorEvent(currentEvent);
    const transitions = selectTransitions(currentEvent, nextSnapshot);
    if (isErr && !transitions.length) {
      // TODO: we should likely only allow transitions selected by very explicit descriptors
      // `*` shouldn't be matched, likely `xstate.error.*` shouldnt be either
      // similarly `xstate.error.actor.*` and `xstate.error.actor.todo.*` have to be considered too
      nextSnapshot = cloneMachineSnapshot(snapshot, {
        status: 'error',
        error: currentEvent.error
      });
      addMicrostate(nextSnapshot, currentEvent, []);
      return {
        snapshot: nextSnapshot,
        microstates
      };
    }
    nextSnapshot = microstep(transitions, snapshot, actorScope, nextEvent, false,
    // isInitial
    internalQueue);
    addMicrostate(nextSnapshot, currentEvent, transitions);
  }
  let shouldSelectEventlessTransitions = true;
  while (nextSnapshot.status === 'active') {
    let enabledTransitions = shouldSelectEventlessTransitions ? selectEventlessTransitions(nextSnapshot, nextEvent) : [];

    // eventless transitions should always be selected after selecting *regular* transitions
    // by assigning `undefined` to `previousState` we ensure that `shouldSelectEventlessTransitions` gets always computed to true in such a case
    const previousState = enabledTransitions.length ? nextSnapshot : undefined;
    if (!enabledTransitions.length) {
      if (!internalQueue.length) {
        break;
      }
      nextEvent = internalQueue.shift();
      enabledTransitions = selectTransitions(nextEvent, nextSnapshot);
    }
    nextSnapshot = microstep(enabledTransitions, nextSnapshot, actorScope, nextEvent, false, internalQueue);
    shouldSelectEventlessTransitions = nextSnapshot !== previousState;
    addMicrostate(nextSnapshot, nextEvent, enabledTransitions);
  }
  if (nextSnapshot.status !== 'active') {
    stopChildren(nextSnapshot, nextEvent, actorScope);
  }
  return {
    snapshot: nextSnapshot,
    microstates
  };
}
function stopChildren(nextState, event, actorScope) {
  return resolveActionsAndContext(nextState, event, actorScope, Object.values(nextState.children).map(child => stopChild(child)), [], undefined);
}
function selectTransitions(event, nextState) {
  return nextState.machine.getTransitionData(nextState, event);
}
function selectEventlessTransitions(nextState, event) {
  const enabledTransitionSet = new Set();
  const atomicStates = nextState._nodes.filter(isAtomicStateNode);
  for (const stateNode of atomicStates) {
    loop: for (const s of [stateNode].concat(getProperAncestors(stateNode, undefined))) {
      if (!s.always) {
        continue;
      }
      for (const transition of s.always) {
        if (transition.guard === undefined || evaluateGuard(transition.guard, nextState.context, event, nextState)) {
          enabledTransitionSet.add(transition);
          break loop;
        }
      }
    }
  }
  return removeConflictingTransitions(Array.from(enabledTransitionSet), new Set(nextState._nodes), nextState.historyValue);
}

/**
 * Resolves a partial state value with its full representation in the state
 * node's machine.
 *
 * @param stateValue The partial state value to resolve.
 */
function resolveStateValue(rootNode, stateValue) {
  const allStateNodes = getAllStateNodes(getStateNodes(rootNode, stateValue));
  return getStateValue(rootNode, [...allStateNodes]);
}

function isMachineSnapshot(value) {
  return !!value && typeof value === 'object' && 'machine' in value && 'value' in value;
}
const machineSnapshotMatches = function matches(testValue) {
  return matchesState(testValue, this.value);
};
const machineSnapshotHasTag = function hasTag(tag) {
  return this.tags.has(tag);
};
const machineSnapshotCan = function can(event) {
  const transitionData = this.machine.getTransitionData(this, event);
  return !!transitionData?.length &&
  // Check that at least one transition is not forbidden
  transitionData.some(t => t.target !== undefined || t.actions.length);
};
const machineSnapshotToJSON = function toJSON() {
  const {
    _nodes: nodes,
    tags,
    machine,
    getMeta,
    toJSON,
    can,
    hasTag,
    matches,
    ...jsonValues
  } = this;
  return {
    ...jsonValues,
    tags: Array.from(tags)
  };
};
const machineSnapshotGetMeta = function getMeta() {
  return this._nodes.reduce((acc, stateNode) => {
    if (stateNode.meta !== undefined) {
      acc[stateNode.id] = stateNode.meta;
    }
    return acc;
  }, {});
};
function createMachineSnapshot(config, machine) {
  return {
    status: config.status,
    output: config.output,
    error: config.error,
    machine,
    context: config.context,
    _nodes: config._nodes,
    value: getStateValue(machine.root, config._nodes),
    tags: new Set(config._nodes.flatMap(sn => sn.tags)),
    children: config.children,
    historyValue: config.historyValue || {},
    matches: machineSnapshotMatches,
    hasTag: machineSnapshotHasTag,
    can: machineSnapshotCan,
    getMeta: machineSnapshotGetMeta,
    toJSON: machineSnapshotToJSON
  };
}
function cloneMachineSnapshot(snapshot, config = {}) {
  return createMachineSnapshot({
    ...snapshot,
    ...config
  }, snapshot.machine);
}
function getPersistedSnapshot(snapshot, options) {
  const {
    _nodes: nodes,
    tags,
    machine,
    children,
    context,
    can,
    hasTag,
    matches,
    getMeta,
    toJSON,
    ...jsonValues
  } = snapshot;
  const childrenJson = {};
  for (const id in children) {
    const child = children[id];
    childrenJson[id] = {
      snapshot: child.getPersistedSnapshot(options),
      src: child.src,
      systemId: child._systemId,
      syncSnapshot: child._syncSnapshot
    };
  }
  const persisted = {
    ...jsonValues,
    context: persistContext(context),
    children: childrenJson
  };
  return persisted;
}
function persistContext(contextPart) {
  let copy;
  for (const key in contextPart) {
    const value = contextPart[key];
    if (value && typeof value === 'object') {
      if ('sessionId' in value && 'send' in value && 'ref' in value) {
        copy ??= Array.isArray(contextPart) ? contextPart.slice() : {
          ...contextPart
        };
        copy[key] = {
          xstate$$type: $$ACTOR_TYPE,
          id: value.id
        };
      } else {
        const result = persistContext(value);
        if (result !== value) {
          copy ??= Array.isArray(contextPart) ? contextPart.slice() : {
            ...contextPart
          };
          copy[key] = result;
        }
      }
    }
  }
  return copy ?? contextPart;
}

function resolveRaise(_, snapshot, args, actionParams, {
  event: eventOrExpr,
  id,
  delay
}, {
  internalQueue
}) {
  const delaysMap = snapshot.machine.implementations.delays;
  if (typeof eventOrExpr === 'string') {
    throw new Error(
    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
    `Only event objects may be used with raise; use raise({ type: "${eventOrExpr}" }) instead`);
  }
  const resolvedEvent = typeof eventOrExpr === 'function' ? eventOrExpr(args, actionParams) : eventOrExpr;
  let resolvedDelay;
  if (typeof delay === 'string') {
    const configDelay = delaysMap && delaysMap[delay];
    resolvedDelay = typeof configDelay === 'function' ? configDelay(args, actionParams) : configDelay;
  } else {
    resolvedDelay = typeof delay === 'function' ? delay(args, actionParams) : delay;
  }
  if (typeof resolvedDelay !== 'number') {
    internalQueue.push(resolvedEvent);
  }
  return [snapshot, {
    event: resolvedEvent,
    id,
    delay: resolvedDelay
  }, undefined];
}
function executeRaise(actorScope, params) {
  const {
    event,
    delay,
    id
  } = params;
  if (typeof delay === 'number') {
    actorScope.defer(() => {
      const self = actorScope.self;
      actorScope.system.scheduler.schedule(self, self, event, delay, id);
    });
    return;
  }
}
/**
 * Raises an event. This places the event in the internal event queue, so that
 * the event is immediately consumed by the machine in the current step.
 *
 * @param eventType The event to raise.
 */
function raise(eventOrExpr, options) {
  function raise(_args, _params) {
  }
  raise.type = 'xstate.raise';
  raise.event = eventOrExpr;
  raise.id = options?.id;
  raise.delay = options?.delay;
  raise.resolve = resolveRaise;
  raise.execute = executeRaise;
  return raise;
}

function createSpawner(actorScope, {
  machine,
  context
}, event, spawnedChildren) {
  const spawn = (src, options) => {
    if (typeof src === 'string') {
      const logic = resolveReferencedActor(machine, src);
      if (!logic) {
        throw new Error(`Actor logic '${src}' not implemented in machine '${machine.id}'`);
      }
      const actorRef = createActor(logic, {
        id: options?.id,
        parent: actorScope.self,
        syncSnapshot: options?.syncSnapshot,
        input: typeof options?.input === 'function' ? options.input({
          context,
          event,
          self: actorScope.self
        }) : options?.input,
        src,
        systemId: options?.systemId
      });
      spawnedChildren[actorRef.id] = actorRef;
      return actorRef;
    } else {
      const actorRef = createActor(src, {
        id: options?.id,
        parent: actorScope.self,
        syncSnapshot: options?.syncSnapshot,
        input: options?.input,
        src,
        systemId: options?.systemId
      });
      return actorRef;
    }
  };
  return (src, options) => {
    const actorRef = spawn(src, options); // TODO: fix types
    spawnedChildren[actorRef.id] = actorRef;
    actorScope.defer(() => {
      if (actorRef._processingStatus === ProcessingStatus.Stopped) {
        return;
      }
      actorRef.start();
    });
    return actorRef;
  };
}

function resolveAssign(actorScope, snapshot, actionArgs, actionParams, {
  assignment
}) {
  if (!snapshot.context) {
    throw new Error('Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.');
  }
  const spawnedChildren = {};
  const assignArgs = {
    context: snapshot.context,
    event: actionArgs.event,
    spawn: createSpawner(actorScope, snapshot, actionArgs.event, spawnedChildren),
    self: actorScope.self,
    system: actorScope.system
  };
  let partialUpdate = {};
  if (typeof assignment === 'function') {
    partialUpdate = assignment(assignArgs, actionParams);
  } else {
    for (const key of Object.keys(assignment)) {
      const propAssignment = assignment[key];
      partialUpdate[key] = typeof propAssignment === 'function' ? propAssignment(assignArgs, actionParams) : propAssignment;
    }
  }
  const updatedContext = Object.assign({}, snapshot.context, partialUpdate);
  return [cloneMachineSnapshot(snapshot, {
    context: updatedContext,
    children: Object.keys(spawnedChildren).length ? {
      ...snapshot.children,
      ...spawnedChildren
    } : snapshot.children
  }), undefined, undefined];
}
/**
 * Updates the current context of the machine.
 *
 * @example
 *
 * ```ts
 * import { createMachine, assign } from 'xstate';
 *
 * const countMachine = createMachine({
 *   context: {
 *     count: 0,
 *     message: ''
 *   },
 *   on: {
 *     inc: {
 *       actions: assign({
 *         count: ({ context }) => context.count + 1
 *       })
 *     },
 *     updateMessage: {
 *       actions: assign(({ context, event }) => {
 *         return {
 *           message: event.message.trim()
 *         };
 *       })
 *     }
 *   }
 * });
 * ```
 *
 * @param assignment An object that represents the partial context to update, or
 *   a function that returns an object that represents the partial context to
 *   update.
 */
function assign(assignment) {
  function assign(_args, _params) {
  }
  assign.type = 'xstate.assign';
  assign.assignment = assignment;
  assign.resolve = resolveAssign;
  return assign;
}

/**
 * Asserts that the given event object is of the specified type or types. Throws
 * an error if the event object is not of the specified types.
 *
 * @example
 *
 * ```ts
 * // ...
 * entry: ({ event }) => {
 *   assertEvent(event, 'doNothing');
 *   // event is { type: 'doNothing' }
 * },
 * // ...
 * exit: ({ event }) => {
 *   assertEvent(event, 'greet');
 *   // event is { type: 'greet'; message: string }
 *
 *   assertEvent(event, ['greet', 'notify']);
 *   // event is { type: 'greet'; message: string }
 *   // or { type: 'notify'; message: string; level: 'info' | 'error' }
 * },
 * ```
 */
function assertEvent(event, type) {
  const types = toArray(type);
  if (!types.includes(event.type)) {
    const typesText = types.length === 1 ? `type "${types[0]}"` : `one of types "${types.join('", "')}"`;
    throw new Error(`Expected event ${JSON.stringify(event)} to have ${typesText}`);
  }
}

const cache = new WeakMap();
function memo(object, key, fn) {
  let memoizedData = cache.get(object);
  if (!memoizedData) {
    memoizedData = {
      [key]: fn()
    };
    cache.set(object, memoizedData);
  } else if (!(key in memoizedData)) {
    memoizedData[key] = fn();
  }
  return memoizedData[key];
}

const EMPTY_OBJECT = {};
const toSerializableAction = action => {
  if (typeof action === 'string') {
    return {
      type: action
    };
  }
  if (typeof action === 'function') {
    if ('resolve' in action) {
      return {
        type: action.type
      };
    }
    return {
      type: action.name
    };
  }
  return action;
};
class StateNode {
  constructor(/** The raw config used to create the machine. */
  config, options) {
    this.config = config;
    /**
     * The relative key of the state node, which represents its location in the
     * overall state value.
     */
    this.key = void 0;
    /** The unique ID of the state node. */
    this.id = void 0;
    /**
     * The type of this state node:
     *
     * - `'atomic'` - no child state nodes
     * - `'compound'` - nested child state nodes (XOR)
     * - `'parallel'` - orthogonal nested child state nodes (AND)
     * - `'history'` - history state node
     * - `'final'` - final state node
     */
    this.type = void 0;
    /** The string path from the root machine node to this node. */
    this.path = void 0;
    /** The child state nodes. */
    this.states = void 0;
    /**
     * The type of history on this state node. Can be:
     *
     * - `'shallow'` - recalls only top-level historical state value
     * - `'deep'` - recalls historical state value at all levels
     */
    this.history = void 0;
    /** The action(s) to be executed upon entering the state node. */
    this.entry = void 0;
    /** The action(s) to be executed upon exiting the state node. */
    this.exit = void 0;
    /** The parent state node. */
    this.parent = void 0;
    /** The root machine node. */
    this.machine = void 0;
    /**
     * The meta data associated with this state node, which will be returned in
     * State instances.
     */
    this.meta = void 0;
    /**
     * The output data sent with the "xstate.done.state._id_" event if this is a
     * final state node.
     */
    this.output = void 0;
    /**
     * The order this state node appears. Corresponds to the implicit document
     * order.
     */
    this.order = -1;
    this.description = void 0;
    this.tags = [];
    this.transitions = void 0;
    this.always = void 0;
    this.parent = options._parent;
    this.key = options._key;
    this.machine = options._machine;
    this.path = this.parent ? this.parent.path.concat(this.key) : [];
    this.id = this.config.id || [this.machine.id, ...this.path].join(STATE_DELIMITER);
    this.type = this.config.type || (this.config.states && Object.keys(this.config.states).length ? 'compound' : this.config.history ? 'history' : 'atomic');
    this.description = this.config.description;
    this.order = this.machine.idMap.size;
    this.machine.idMap.set(this.id, this);
    this.states = this.config.states ? mapValues(this.config.states, (stateConfig, key) => {
      const stateNode = new StateNode(stateConfig, {
        _parent: this,
        _key: key,
        _machine: this.machine
      });
      return stateNode;
    }) : EMPTY_OBJECT;
    if (this.type === 'compound' && !this.config.initial) {
      throw new Error(`No initial state specified for compound state node "#${this.id}". Try adding { initial: "${Object.keys(this.states)[0]}" } to the state config.`);
    }

    // History config
    this.history = this.config.history === true ? 'shallow' : this.config.history || false;
    this.entry = toArray(this.config.entry).slice();
    this.exit = toArray(this.config.exit).slice();
    this.meta = this.config.meta;
    this.output = this.type === 'final' || !this.parent ? this.config.output : undefined;
    this.tags = toArray(config.tags).slice();
  }

  /** @internal */
  _initialize() {
    this.transitions = formatTransitions(this);
    if (this.config.always) {
      this.always = toTransitionConfigArray(this.config.always).map(t => formatTransition(this, NULL_EVENT, t));
    }
    Object.keys(this.states).forEach(key => {
      this.states[key]._initialize();
    });
  }

  /** The well-structured state node definition. */
  get definition() {
    return {
      id: this.id,
      key: this.key,
      version: this.machine.version,
      type: this.type,
      initial: this.initial ? {
        target: this.initial.target,
        source: this,
        actions: this.initial.actions.map(toSerializableAction),
        eventType: null,
        reenter: false,
        toJSON: () => ({
          target: this.initial.target.map(t => `#${t.id}`),
          source: `#${this.id}`,
          actions: this.initial.actions.map(toSerializableAction),
          eventType: null
        })
      } : undefined,
      history: this.history,
      states: mapValues(this.states, state => {
        return state.definition;
      }),
      on: this.on,
      transitions: [...this.transitions.values()].flat().map(t => ({
        ...t,
        actions: t.actions.map(toSerializableAction)
      })),
      entry: this.entry.map(toSerializableAction),
      exit: this.exit.map(toSerializableAction),
      meta: this.meta,
      order: this.order || -1,
      output: this.output,
      invoke: this.invoke,
      description: this.description,
      tags: this.tags
    };
  }

  /** @internal */
  toJSON() {
    return this.definition;
  }

  /** The logic invoked as actors by this state node. */
  get invoke() {
    return memo(this, 'invoke', () => toArray(this.config.invoke).map((invokeConfig, i) => {
      const {
        src,
        systemId
      } = invokeConfig;
      const resolvedId = invokeConfig.id ?? createInvokeId(this.id, i);
      const sourceName = typeof src === 'string' ? src : `xstate.invoke.${createInvokeId(this.id, i)}`;
      return {
        ...invokeConfig,
        src: sourceName,
        id: resolvedId,
        systemId: systemId,
        toJSON() {
          const {
            onDone,
            onError,
            ...invokeDefValues
          } = invokeConfig;
          return {
            ...invokeDefValues,
            type: 'xstate.invoke',
            src: sourceName,
            id: resolvedId
          };
        }
      };
    }));
  }

  /** The mapping of events to transitions. */
  get on() {
    return memo(this, 'on', () => {
      const transitions = this.transitions;
      return [...transitions].flatMap(([descriptor, t]) => t.map(t => [descriptor, t])).reduce((map, [descriptor, transition]) => {
        map[descriptor] = map[descriptor] || [];
        map[descriptor].push(transition);
        return map;
      }, {});
    });
  }
  get after() {
    return memo(this, 'delayedTransitions', () => getDelayedTransitions(this));
  }
  get initial() {
    return memo(this, 'initial', () => formatInitialTransition(this, this.config.initial));
  }

  /** @internal */
  next(snapshot, event) {
    const eventType = event.type;
    const actions = [];
    let selectedTransition;
    const candidates = memo(this, `candidates-${eventType}`, () => getCandidates(this, eventType));
    for (const candidate of candidates) {
      const {
        guard
      } = candidate;
      const resolvedContext = snapshot.context;
      let guardPassed = false;
      try {
        guardPassed = !guard || evaluateGuard(guard, resolvedContext, event, snapshot);
      } catch (err) {
        const guardType = typeof guard === 'string' ? guard : typeof guard === 'object' ? guard.type : undefined;
        throw new Error(`Unable to evaluate guard ${guardType ? `'${guardType}' ` : ''}in transition for event '${eventType}' in state node '${this.id}':\n${err.message}`);
      }
      if (guardPassed) {
        actions.push(...candidate.actions);
        selectedTransition = candidate;
        break;
      }
    }
    return selectedTransition ? [selectedTransition] : undefined;
  }

  /** All the event types accepted by this state node and its descendants. */
  get events() {
    return memo(this, 'events', () => {
      const {
        states
      } = this;
      const events = new Set(this.ownEvents);
      if (states) {
        for (const stateId of Object.keys(states)) {
          const state = states[stateId];
          if (state.states) {
            for (const event of state.events) {
              events.add(`${event}`);
            }
          }
        }
      }
      return Array.from(events);
    });
  }

  /**
   * All the events that have transitions directly from this state node.
   *
   * Excludes any inert events.
   */
  get ownEvents() {
    const events = new Set([...this.transitions.keys()].filter(descriptor => {
      return this.transitions.get(descriptor).some(transition => !(!transition.target && !transition.actions.length && !transition.reenter));
    }));
    return Array.from(events);
  }
}

const STATE_IDENTIFIER = '#';
class StateMachine {
  constructor(/** The raw config used to create the machine. */
  config, implementations) {
    this.config = config;
    /** The machine's own version. */
    this.version = void 0;
    this.schemas = void 0;
    this.implementations = void 0;
    /** @internal */
    this.__xstatenode = true;
    /** @internal */
    this.idMap = new Map();
    this.root = void 0;
    this.id = void 0;
    this.states = void 0;
    this.events = void 0;
    this.id = config.id || '(machine)';
    this.implementations = {
      actors: implementations?.actors ?? {},
      actions: implementations?.actions ?? {},
      delays: implementations?.delays ?? {},
      guards: implementations?.guards ?? {}
    };
    this.version = this.config.version;
    this.schemas = this.config.schemas;
    this.transition = this.transition.bind(this);
    this.getInitialSnapshot = this.getInitialSnapshot.bind(this);
    this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this);
    this.restoreSnapshot = this.restoreSnapshot.bind(this);
    this.start = this.start.bind(this);
    this.root = new StateNode(config, {
      _key: this.id,
      _machine: this
    });
    this.root._initialize();
    this.states = this.root.states; // TODO: remove!
    this.events = this.root.events;
  }

  /**
   * Clones this state machine with the provided implementations and merges the
   * `context` (if provided).
   *
   * @param implementations Options (`actions`, `guards`, `actors`, `delays`,
   *   `context`) to recursively merge with the existing options.
   * @returns A new `StateMachine` instance with the provided implementations.
   */
  provide(implementations) {
    const {
      actions,
      guards,
      actors,
      delays
    } = this.implementations;
    return new StateMachine(this.config, {
      actions: {
        ...actions,
        ...implementations.actions
      },
      guards: {
        ...guards,
        ...implementations.guards
      },
      actors: {
        ...actors,
        ...implementations.actors
      },
      delays: {
        ...delays,
        ...implementations.delays
      }
    });
  }
  resolveState(config) {
    const resolvedStateValue = resolveStateValue(this.root, config.value);
    const nodeSet = getAllStateNodes(getStateNodes(this.root, resolvedStateValue));
    return createMachineSnapshot({
      _nodes: [...nodeSet],
      context: config.context || {},
      children: {},
      status: isInFinalState(nodeSet, this.root) ? 'done' : config.status || 'active',
      output: config.output,
      error: config.error,
      historyValue: config.historyValue
    }, this);
  }

  /**
   * Determines the next snapshot given the current `snapshot` and received
   * `event`. Calculates a full macrostep from all microsteps.
   *
   * @param snapshot The current snapshot
   * @param event The received event
   */
  transition(snapshot, event, actorScope) {
    return macrostep(snapshot, event, actorScope, []).snapshot;
  }

  /**
   * Determines the next state given the current `state` and `event`. Calculates
   * a microstep.
   *
   * @param state The current state
   * @param event The received event
   */
  microstep(snapshot, event, actorScope) {
    return macrostep(snapshot, event, actorScope, []).microstates;
  }
  getTransitionData(snapshot, event) {
    return transitionNode(this.root, snapshot.value, snapshot, event) || [];
  }

  /**
   * The initial state _before_ evaluating any microsteps. This "pre-initial"
   * state is provided to initial actions executed in the initial state.
   */
  getPreInitialState(actorScope, initEvent, internalQueue) {
    const {
      context
    } = this.config;
    const preInitial = createMachineSnapshot({
      context: typeof context !== 'function' && context ? context : {},
      _nodes: [this.root],
      children: {},
      status: 'active'
    }, this);
    if (typeof context === 'function') {
      const assignment = ({
        spawn,
        event,
        self
      }) => context({
        spawn,
        input: event.input,
        self
      });
      return resolveActionsAndContext(preInitial, initEvent, actorScope, [assign(assignment)], internalQueue, undefined);
    }
    return preInitial;
  }

  /**
   * Returns the initial `State` instance, with reference to `self` as an
   * `ActorRef`.
   */
  getInitialSnapshot(actorScope, input) {
    const initEvent = createInitEvent(input); // TODO: fix;
    const internalQueue = [];
    const preInitialState = this.getPreInitialState(actorScope, initEvent, internalQueue);
    const nextState = microstep([{
      target: [...getInitialStateNodes(this.root)],
      source: this.root,
      reenter: true,
      actions: [],
      eventType: null,
      toJSON: null // TODO: fix
    }], preInitialState, actorScope, initEvent, true, internalQueue);
    const {
      snapshot: macroState
    } = macrostep(nextState, initEvent, actorScope, internalQueue);
    return macroState;
  }
  start(snapshot) {
    Object.values(snapshot.children).forEach(child => {
      if (child.getSnapshot().status === 'active') {
        child.start();
      }
    });
  }
  getStateNodeById(stateId) {
    const fullPath = toStatePath(stateId);
    const relativePath = fullPath.slice(1);
    const resolvedStateId = isStateId(fullPath[0]) ? fullPath[0].slice(STATE_IDENTIFIER.length) : fullPath[0];
    const stateNode = this.idMap.get(resolvedStateId);
    if (!stateNode) {
      throw new Error(`Child state node '#${resolvedStateId}' does not exist on machine '${this.id}'`);
    }
    return getStateNodeByPath(stateNode, relativePath);
  }
  get definition() {
    return this.root.definition;
  }
  toJSON() {
    return this.definition;
  }
  getPersistedSnapshot(snapshot, options) {
    return getPersistedSnapshot(snapshot, options);
  }
  restoreSnapshot(snapshot, _actorScope) {
    const children = {};
    const snapshotChildren = snapshot.children;
    Object.keys(snapshotChildren).forEach(actorId => {
      const actorData = snapshotChildren[actorId];
      const childState = actorData.snapshot;
      const src = actorData.src;
      const logic = typeof src === 'string' ? resolveReferencedActor(this, src) : src;
      if (!logic) {
        return;
      }
      const actorRef = createActor(logic, {
        id: actorId,
        parent: _actorScope.self,
        syncSnapshot: actorData.syncSnapshot,
        snapshot: childState,
        src,
        systemId: actorData.systemId
      });
      children[actorId] = actorRef;
    });
    const restoredSnapshot = createMachineSnapshot({
      ...snapshot,
      children,
      _nodes: Array.from(getAllStateNodes(getStateNodes(this.root, snapshot.value)))
    }, this);
    const seen = new Set();
    function reviveContext(contextPart, children) {
      if (seen.has(contextPart)) {
        return;
      }
      seen.add(contextPart);
      for (const key in contextPart) {
        const value = contextPart[key];
        if (value && typeof value === 'object') {
          if ('xstate$$type' in value && value.xstate$$type === $$ACTOR_TYPE) {
            contextPart[key] = children[value.id];
            continue;
          }
          reviveContext(value, children);
        }
      }
    }
    reviveContext(restoredSnapshot.context, children);
    return restoredSnapshot;
  }
}

/**
 * Creates a state machine (statechart) with the given configuration.
 *
 * The state machine represents the pure logic of a state machine actor.
 *
 * @example
 *
 * ```ts
 * import { createMachine } from 'xstate';
 *
 * const lightMachine = createMachine({
 *   id: 'light',
 *   initial: 'green',
 *   states: {
 *     green: {
 *       on: {
 *         TIMER: { target: 'yellow' }
 *       }
 *     },
 *     yellow: {
 *       on: {
 *         TIMER: { target: 'red' }
 *       }
 *     },
 *     red: {
 *       on: {
 *         TIMER: { target: 'green' }
 *       }
 *     }
 *   }
 * });
 *
 * const lightActor = createActor(lightMachine);
 * lightActor.start();
 *
 * lightActor.send({ type: 'TIMER' });
 * ```
 *
 * @param config The state machine configuration.
 * @param options DEPRECATED: use `setup({ ... })` or `machine.provide({ ... })`
 *   to provide machine implementations instead.
 */
function createMachine(config, implementations) {
  return new StateMachine(config, implementations);
}

// at the moment we allow extra actors - ones that are not specified by `children`
// this could be reconsidered in the future

function setup({
  schemas,
  actors,
  actions,
  guards,
  delays
}) {
  return {
    createMachine: config => createMachine({
      ...config,
      schemas
    }, {
      actors,
      actions,
      guards,
      delays
    })
  };
}

const defaultWaitForOptions = {
  timeout: Infinity // much more than 10 seconds
};

/**
 * Subscribes to an actor ref and waits for its emitted value to satisfy a
 * predicate, and then resolves with that value. Will throw if the desired state
 * is not reached after an optional timeout. (defaults to Infinity).
 *
 * @example
 *
 * ```js
 * const state = await waitFor(someService, (state) => {
 *   return state.hasTag('loaded');
 * });
 *
 * state.hasTag('loaded'); // true
 * ```
 *
 * @param actorRef The actor ref to subscribe to
 * @param predicate Determines if a value matches the condition to wait for
 * @param options
 * @returns A promise that eventually resolves to the emitted value that matches
 *   the condition
 */
function waitFor(actorRef, predicate, options) {
  const resolvedOptions = {
    ...defaultWaitForOptions,
    ...options
  };
  return new Promise((res, rej) => {
    const {
      signal
    } = resolvedOptions;
    if (signal?.aborted) {
      // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
      rej(signal.reason);
      return;
    }
    let done = false;
    const handle = resolvedOptions.timeout === Infinity ? undefined : setTimeout(() => {
      dispose();
      rej(new Error(`Timeout of ${resolvedOptions.timeout} ms exceeded`));
    }, resolvedOptions.timeout);
    const dispose = () => {
      clearTimeout(handle);
      done = true;
      sub?.unsubscribe();
      if (abortListener) {
        signal.removeEventListener('abort', abortListener);
      }
    };
    function checkEmitted(emitted) {
      if (predicate(emitted)) {
        dispose();
        res(emitted);
      }
    }

    /**
     * If the `signal` option is provided, this will be the listener for its
     * `abort` event
     */
    let abortListener;
    // eslint-disable-next-line prefer-const
    let sub; // avoid TDZ when disposing synchronously

    // See if the current snapshot already matches the predicate
    checkEmitted(actorRef.getSnapshot());
    if (done) {
      return;
    }

    // only define the `abortListener` if the `signal` option is provided
    if (signal) {
      abortListener = () => {
        dispose();
        // XState does not "own" the signal, so we should reject with its reason (if any)
        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
        rej(signal.reason);
      };
      signal.addEventListener('abort', abortListener);
    }
    sub = actorRef.subscribe({
      next: checkEmitted,
      error: err => {
        dispose();
        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
        rej(err);
      },
      complete: () => {
        dispose();
        rej(new Error(`Actor terminated without satisfying predicate`));
      }
    });
    if (done) {
      sub.unsubscribe();
    }
  });
}

var sha256$2 = {};

var _md = {};

var _assert = {};

var hasRequired_assert;

function require_assert () {
	if (hasRequired_assert) return _assert;
	hasRequired_assert = 1;
	Object.defineProperty(_assert, "__esModule", { value: true });
	_assert.anumber = anumber;
	_assert.number = anumber;
	_assert.abytes = abytes;
	_assert.bytes = abytes;
	_assert.ahash = ahash;
	_assert.aexists = aexists;
	_assert.aoutput = aoutput;
	function anumber(n) {
	    if (!Number.isSafeInteger(n) || n < 0)
	        throw new Error('positive integer expected, got ' + n);
	}
	// copied from utils
	function isBytes(a) {
	    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');
	}
	function abytes(b, ...lengths) {
	    if (!isBytes(b))
	        throw new Error('Uint8Array expected');
	    if (lengths.length > 0 && !lengths.includes(b.length))
	        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
	}
	function ahash(h) {
	    if (typeof h !== 'function' || typeof h.create !== 'function')
	        throw new Error('Hash should be wrapped by utils.wrapConstructor');
	    anumber(h.outputLen);
	    anumber(h.blockLen);
	}
	function aexists(instance, checkFinished = true) {
	    if (instance.destroyed)
	        throw new Error('Hash instance has been destroyed');
	    if (checkFinished && instance.finished)
	        throw new Error('Hash#digest() has already been called');
	}
	function aoutput(out, instance) {
	    abytes(out);
	    const min = instance.outputLen;
	    if (out.length < min) {
	        throw new Error('digestInto() expects output buffer of length at least ' + min);
	    }
	}
	const assert = {
	    number: anumber,
	    bytes: abytes,
	    hash: ahash,
	    exists: aexists,
	    output: aoutput,
	};
	_assert.default = assert;
	
	return _assert;
}

var utils = {};

var crypto$1 = {};

var hasRequiredCrypto;

function requireCrypto () {
	if (hasRequiredCrypto) return crypto$1;
	hasRequiredCrypto = 1;
	Object.defineProperty(crypto$1, "__esModule", { value: true });
	crypto$1.crypto = void 0;
	crypto$1.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;
	
	return crypto$1;
}

var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;
	(function (exports) {
		/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Hash = exports.nextTick = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
		exports.isBytes = isBytes;
		exports.byteSwap32 = byteSwap32;
		exports.bytesToHex = bytesToHex;
		exports.hexToBytes = hexToBytes;
		exports.asyncLoop = asyncLoop;
		exports.utf8ToBytes = utf8ToBytes;
		exports.toBytes = toBytes;
		exports.concatBytes = concatBytes;
		exports.checkOpts = checkOpts;
		exports.wrapConstructor = wrapConstructor;
		exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
		exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
		exports.randomBytes = randomBytes;
		// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
		// node.js versions earlier than v19 don't declare it in global scope.
		// For node.js, package.json#exports field mapping rewrites import
		// from `crypto` to `cryptoNode`, which imports native module.
		// Makes the utils un-importable in browsers without a bundler.
		// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
		const crypto_1 = /*@__PURE__*/ requireCrypto();
		const _assert_js_1 = /*@__PURE__*/ require_assert();
		// export { isBytes } from './_assert.js';
		// We can't reuse isBytes from _assert, because somehow this causes huge perf issues
		function isBytes(a) {
		    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');
		}
		// Cast array to different type
		const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
		exports.u8 = u8;
		const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
		exports.u32 = u32;
		// Cast array to view
		const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
		exports.createView = createView;
		// The rotate right (circular right shift) operation for uint32
		const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
		exports.rotr = rotr;
		// The rotate left (circular left shift) operation for uint32
		const rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);
		exports.rotl = rotl;
		exports.isLE = (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();
		// The byte swap operation for uint32
		const byteSwap = (word) => ((word << 24) & 0xff000000) |
		    ((word << 8) & 0xff0000) |
		    ((word >>> 8) & 0xff00) |
		    ((word >>> 24) & 0xff);
		exports.byteSwap = byteSwap;
		// Conditionally byte swap if on a big-endian platform
		exports.byteSwapIfBE = exports.isLE ? (n) => n : (n) => (0, exports.byteSwap)(n);
		// In place byte swap for Uint32Array
		function byteSwap32(arr) {
		    for (let i = 0; i < arr.length; i++) {
		        arr[i] = (0, exports.byteSwap)(arr[i]);
		    }
		}
		// Array where index 0xf0 (240) is mapped to string 'f0'
		const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
		/**
		 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
		 */
		function bytesToHex(bytes) {
		    (0, _assert_js_1.abytes)(bytes);
		    // pre-caching improves the speed 6x
		    let hex = '';
		    for (let i = 0; i < bytes.length; i++) {
		        hex += hexes[bytes[i]];
		    }
		    return hex;
		}
		// We use optimized technique to convert hex string to byte array
		const asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
		function asciiToBase16(ch) {
		    if (ch >= asciis._0 && ch <= asciis._9)
		        return ch - asciis._0; // '2' => 50-48
		    if (ch >= asciis.A && ch <= asciis.F)
		        return ch - (asciis.A - 10); // 'B' => 66-(65-10)
		    if (ch >= asciis.a && ch <= asciis.f)
		        return ch - (asciis.a - 10); // 'b' => 98-(97-10)
		    return;
		}
		/**
		 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
		 */
		function hexToBytes(hex) {
		    if (typeof hex !== 'string')
		        throw new Error('hex string expected, got ' + typeof hex);
		    const hl = hex.length;
		    const al = hl / 2;
		    if (hl % 2)
		        throw new Error('hex string expected, got unpadded hex of length ' + hl);
		    const array = new Uint8Array(al);
		    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
		        const n1 = asciiToBase16(hex.charCodeAt(hi));
		        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
		        if (n1 === undefined || n2 === undefined) {
		            const char = hex[hi] + hex[hi + 1];
		            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
		        }
		        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
		    }
		    return array;
		}
		// There is no setImmediate in browser and setTimeout is slow.
		// call of async fn will return Promise, which will be fullfiled only on
		// next scheduler queue processing step and this is exactly what we need.
		const nextTick = async () => { };
		exports.nextTick = nextTick;
		// Returns control to thread each 'tick' ms to avoid blocking
		async function asyncLoop(iters, tick, cb) {
		    let ts = Date.now();
		    for (let i = 0; i < iters; i++) {
		        cb(i);
		        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
		        const diff = Date.now() - ts;
		        if (diff >= 0 && diff < tick)
		            continue;
		        await (0, exports.nextTick)();
		        ts += diff;
		    }
		}
		/**
		 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
		 */
		function utf8ToBytes(str) {
		    if (typeof str !== 'string')
		        throw new Error('utf8ToBytes expected string, got ' + typeof str);
		    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
		}
		/**
		 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
		 * Warning: when Uint8Array is passed, it would NOT get copied.
		 * Keep in mind for future mutable operations.
		 */
		function toBytes(data) {
		    if (typeof data === 'string')
		        data = utf8ToBytes(data);
		    (0, _assert_js_1.abytes)(data);
		    return data;
		}
		/**
		 * Copies several Uint8Arrays into one.
		 */
		function concatBytes(...arrays) {
		    let sum = 0;
		    for (let i = 0; i < arrays.length; i++) {
		        const a = arrays[i];
		        (0, _assert_js_1.abytes)(a);
		        sum += a.length;
		    }
		    const res = new Uint8Array(sum);
		    for (let i = 0, pad = 0; i < arrays.length; i++) {
		        const a = arrays[i];
		        res.set(a, pad);
		        pad += a.length;
		    }
		    return res;
		}
		// For runtime check if class implements interface
		class Hash {
		    // Safe version that clones internal state
		    clone() {
		        return this._cloneInto();
		    }
		}
		exports.Hash = Hash;
		function checkOpts(defaults, opts) {
		    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')
		        throw new Error('Options should be object or undefined');
		    const merged = Object.assign(defaults, opts);
		    return merged;
		}
		function wrapConstructor(hashCons) {
		    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
		    const tmp = hashCons();
		    hashC.outputLen = tmp.outputLen;
		    hashC.blockLen = tmp.blockLen;
		    hashC.create = () => hashCons();
		    return hashC;
		}
		function wrapConstructorWithOpts(hashCons) {
		    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
		    const tmp = hashCons({});
		    hashC.outputLen = tmp.outputLen;
		    hashC.blockLen = tmp.blockLen;
		    hashC.create = (opts) => hashCons(opts);
		    return hashC;
		}
		function wrapXOFConstructorWithOpts(hashCons) {
		    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
		    const tmp = hashCons({});
		    hashC.outputLen = tmp.outputLen;
		    hashC.blockLen = tmp.blockLen;
		    hashC.create = (opts) => hashCons(opts);
		    return hashC;
		}
		/**
		 * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
		 */
		function randomBytes(bytesLength = 32) {
		    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
		        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
		    }
		    // Legacy Node.js compatibility
		    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') {
		        return crypto_1.crypto.randomBytes(bytesLength);
		    }
		    throw new Error('crypto.getRandomValues must be defined');
		}
		
	} (utils));
	return utils;
}

var hasRequired_md;

function require_md () {
	if (hasRequired_md) return _md;
	hasRequired_md = 1;
	Object.defineProperty(_md, "__esModule", { value: true });
	_md.HashMD = _md.Maj = _md.Chi = void 0;
	const _assert_js_1 = /*@__PURE__*/ require_assert();
	const utils_js_1 = /*@__PURE__*/ requireUtils();
	/**
	 * Polyfill for Safari 14
	 */
	function setBigUint64(view, byteOffset, value, isLE) {
	    if (typeof view.setBigUint64 === 'function')
	        return view.setBigUint64(byteOffset, value, isLE);
	    const _32n = BigInt(32);
	    const _u32_max = BigInt(0xffffffff);
	    const wh = Number((value >> _32n) & _u32_max);
	    const wl = Number(value & _u32_max);
	    const h = isLE ? 4 : 0;
	    const l = isLE ? 0 : 4;
	    view.setUint32(byteOffset + h, wh, isLE);
	    view.setUint32(byteOffset + l, wl, isLE);
	}
	/**
	 * Choice: a ? b : c
	 */
	const Chi = (a, b, c) => (a & b) ^ (~a & c);
	_md.Chi = Chi;
	/**
	 * Majority function, true if any two inputs is true
	 */
	const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
	_md.Maj = Maj;
	/**
	 * Merkle-Damgard hash construction base class.
	 * Could be used to create MD5, RIPEMD, SHA1, SHA2.
	 */
	class HashMD extends utils_js_1.Hash {
	    constructor(blockLen, outputLen, padOffset, isLE) {
	        super();
	        this.blockLen = blockLen;
	        this.outputLen = outputLen;
	        this.padOffset = padOffset;
	        this.isLE = isLE;
	        this.finished = false;
	        this.length = 0;
	        this.pos = 0;
	        this.destroyed = false;
	        this.buffer = new Uint8Array(blockLen);
	        this.view = (0, utils_js_1.createView)(this.buffer);
	    }
	    update(data) {
	        (0, _assert_js_1.aexists)(this);
	        const { view, buffer, blockLen } = this;
	        data = (0, utils_js_1.toBytes)(data);
	        const len = data.length;
	        for (let pos = 0; pos < len;) {
	            const take = Math.min(blockLen - this.pos, len - pos);
	            // Fast path: we have at least one block in input, cast it to view and process
	            if (take === blockLen) {
	                const dataView = (0, utils_js_1.createView)(data);
	                for (; blockLen <= len - pos; pos += blockLen)
	                    this.process(dataView, pos);
	                continue;
	            }
	            buffer.set(data.subarray(pos, pos + take), this.pos);
	            this.pos += take;
	            pos += take;
	            if (this.pos === blockLen) {
	                this.process(view, 0);
	                this.pos = 0;
	            }
	        }
	        this.length += data.length;
	        this.roundClean();
	        return this;
	    }
	    digestInto(out) {
	        (0, _assert_js_1.aexists)(this);
	        (0, _assert_js_1.aoutput)(out, this);
	        this.finished = true;
	        // Padding
	        // We can avoid allocation of buffer for padding completely if it
	        // was previously not allocated here. But it won't change performance.
	        const { buffer, view, blockLen, isLE } = this;
	        let { pos } = this;
	        // append the bit '1' to the message
	        buffer[pos++] = 0b10000000;
	        this.buffer.subarray(pos).fill(0);
	        // we have less than padOffset left in buffer, so we cannot put length in
	        // current block, need process it and pad again
	        if (this.padOffset > blockLen - pos) {
	            this.process(view, 0);
	            pos = 0;
	        }
	        // Pad until full block byte with zeros
	        for (let i = pos; i < blockLen; i++)
	            buffer[i] = 0;
	        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
	        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
	        // So we just write lowest 64 bits of that value.
	        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
	        this.process(view, 0);
	        const oview = (0, utils_js_1.createView)(out);
	        const len = this.outputLen;
	        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
	        if (len % 4)
	            throw new Error('_sha2: outputLen should be aligned to 32bit');
	        const outLen = len / 4;
	        const state = this.get();
	        if (outLen > state.length)
	            throw new Error('_sha2: outputLen bigger than state');
	        for (let i = 0; i < outLen; i++)
	            oview.setUint32(4 * i, state[i], isLE);
	    }
	    digest() {
	        const { buffer, outputLen } = this;
	        this.digestInto(buffer);
	        const res = buffer.slice(0, outputLen);
	        this.destroy();
	        return res;
	    }
	    _cloneInto(to) {
	        to || (to = new this.constructor());
	        to.set(...this.get());
	        const { blockLen, buffer, length, finished, destroyed, pos } = this;
	        to.length = length;
	        to.pos = pos;
	        to.finished = finished;
	        to.destroyed = destroyed;
	        if (length % blockLen)
	            to.buffer.set(buffer);
	        return to;
	    }
	}
	_md.HashMD = HashMD;
	
	return _md;
}

var hasRequiredSha256$1;

function requireSha256$1 () {
	if (hasRequiredSha256$1) return sha256$2;
	hasRequiredSha256$1 = 1;
	Object.defineProperty(sha256$2, "__esModule", { value: true });
	sha256$2.sha224 = sha256$2.sha256 = sha256$2.SHA256 = void 0;
	const _md_js_1 = /*@__PURE__*/ require_md();
	const utils_js_1 = /*@__PURE__*/ requireUtils();
	// SHA2-256 need to try 2^128 hashes to execute birthday attack.
	// BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per late 2024.
	// Round constants:
	// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
	// prettier-ignore
	const SHA256_K = /* @__PURE__ */ new Uint32Array([
	    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
	    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
	    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
	    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
	    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
	    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
	    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
	    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
	]);
	// Initial state:
	// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19
	// prettier-ignore
	const SHA256_IV = /* @__PURE__ */ new Uint32Array([
	    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
	]);
	// Temporary buffer, not used to store anything between runs
	// Named this way because it matches specification.
	const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
	class SHA256 extends _md_js_1.HashMD {
	    constructor() {
	        super(64, 32, 8, false);
	        // We cannot use array here since array allows indexing by variable
	        // which means optimizer/compiler cannot use registers.
	        this.A = SHA256_IV[0] | 0;
	        this.B = SHA256_IV[1] | 0;
	        this.C = SHA256_IV[2] | 0;
	        this.D = SHA256_IV[3] | 0;
	        this.E = SHA256_IV[4] | 0;
	        this.F = SHA256_IV[5] | 0;
	        this.G = SHA256_IV[6] | 0;
	        this.H = SHA256_IV[7] | 0;
	    }
	    get() {
	        const { A, B, C, D, E, F, G, H } = this;
	        return [A, B, C, D, E, F, G, H];
	    }
	    // prettier-ignore
	    set(A, B, C, D, E, F, G, H) {
	        this.A = A | 0;
	        this.B = B | 0;
	        this.C = C | 0;
	        this.D = D | 0;
	        this.E = E | 0;
	        this.F = F | 0;
	        this.G = G | 0;
	        this.H = H | 0;
	    }
	    process(view, offset) {
	        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
	        for (let i = 0; i < 16; i++, offset += 4)
	            SHA256_W[i] = view.getUint32(offset, false);
	        for (let i = 16; i < 64; i++) {
	            const W15 = SHA256_W[i - 15];
	            const W2 = SHA256_W[i - 2];
	            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);
	            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);
	            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
	        }
	        // Compression function main loop, 64 rounds
	        let { A, B, C, D, E, F, G, H } = this;
	        for (let i = 0; i < 64; i++) {
	            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
	            const T1 = (H + sigma1 + (0, _md_js_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
	            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
	            const T2 = (sigma0 + (0, _md_js_1.Maj)(A, B, C)) | 0;
	            H = G;
	            G = F;
	            F = E;
	            E = (D + T1) | 0;
	            D = C;
	            C = B;
	            B = A;
	            A = (T1 + T2) | 0;
	        }
	        // Add the compressed chunk to the current hash value
	        A = (A + this.A) | 0;
	        B = (B + this.B) | 0;
	        C = (C + this.C) | 0;
	        D = (D + this.D) | 0;
	        E = (E + this.E) | 0;
	        F = (F + this.F) | 0;
	        G = (G + this.G) | 0;
	        H = (H + this.H) | 0;
	        this.set(A, B, C, D, E, F, G, H);
	    }
	    roundClean() {
	        SHA256_W.fill(0);
	    }
	    destroy() {
	        this.set(0, 0, 0, 0, 0, 0, 0, 0);
	        this.buffer.fill(0);
	    }
	}
	sha256$2.SHA256 = SHA256;
	// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
	class SHA224 extends SHA256 {
	    constructor() {
	        super();
	        this.A = 0xc1059ed8 | 0;
	        this.B = 0x367cd507 | 0;
	        this.C = 0x3070dd17 | 0;
	        this.D = 0xf70e5939 | 0;
	        this.E = 0xffc00b31 | 0;
	        this.F = 0x68581511 | 0;
	        this.G = 0x64f98fa7 | 0;
	        this.H = 0xbefa4fa4 | 0;
	        this.outputLen = 28;
	    }
	}
	/**
	 * SHA2-256 hash function
	 * @param message - data that would be hashed
	 */
	sha256$2.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
	/**
	 * SHA2-224 hash function
	 */
	sha256$2.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
	
	return sha256$2;
}

var src$1;
var hasRequiredSrc;

function requireSrc () {
	if (hasRequiredSrc) return src$1;
	hasRequiredSrc = 1;
	// base-x encoding / decoding
	// Copyright (c) 2018 base-x contributors
	// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
	// Distributed under the MIT software license, see the accompanying
	// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
	function base (ALPHABET) {
	  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
	  var BASE_MAP = new Uint8Array(256);
	  for (var j = 0; j < BASE_MAP.length; j++) {
	    BASE_MAP[j] = 255;
	  }
	  for (var i = 0; i < ALPHABET.length; i++) {
	    var x = ALPHABET.charAt(i);
	    var xc = x.charCodeAt(0);
	    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
	    BASE_MAP[xc] = i;
	  }
	  var BASE = ALPHABET.length;
	  var LEADER = ALPHABET.charAt(0);
	  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
	  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up
	  function encode (source) {
	    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {
	      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
	    } else if (Array.isArray(source)) {
	      source = Uint8Array.from(source);
	    }
	    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }
	    if (source.length === 0) { return '' }
	        // Skip & count leading zeroes.
	    var zeroes = 0;
	    var length = 0;
	    var pbegin = 0;
	    var pend = source.length;
	    while (pbegin !== pend && source[pbegin] === 0) {
	      pbegin++;
	      zeroes++;
	    }
	        // Allocate enough space in big-endian base58 representation.
	    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;
	    var b58 = new Uint8Array(size);
	        // Process the bytes.
	    while (pbegin !== pend) {
	      var carry = source[pbegin];
	            // Apply "b58 = b58 * 256 + ch".
	      var i = 0;
	      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
	        carry += (256 * b58[it1]) >>> 0;
	        b58[it1] = (carry % BASE) >>> 0;
	        carry = (carry / BASE) >>> 0;
	      }
	      if (carry !== 0) { throw new Error('Non-zero carry') }
	      length = i;
	      pbegin++;
	    }
	        // Skip leading zeroes in base58 result.
	    var it2 = size - length;
	    while (it2 !== size && b58[it2] === 0) {
	      it2++;
	    }
	        // Translate the result into a string.
	    var str = LEADER.repeat(zeroes);
	    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }
	    return str
	  }
	  function decodeUnsafe (source) {
	    if (typeof source !== 'string') { throw new TypeError('Expected String') }
	    if (source.length === 0) { return new Uint8Array() }
	    var psz = 0;
	        // Skip and count leading '1's.
	    var zeroes = 0;
	    var length = 0;
	    while (source[psz] === LEADER) {
	      zeroes++;
	      psz++;
	    }
	        // Allocate enough space in big-endian base256 representation.
	    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.
	    var b256 = new Uint8Array(size);
	        // Process the characters.
	    while (source[psz]) {
	            // Decode character
	      var carry = BASE_MAP[source.charCodeAt(psz)];
	            // Invalid character
	      if (carry === 255) { return }
	      var i = 0;
	      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
	        carry += (BASE * b256[it3]) >>> 0;
	        b256[it3] = (carry % 256) >>> 0;
	        carry = (carry / 256) >>> 0;
	      }
	      if (carry !== 0) { throw new Error('Non-zero carry') }
	      length = i;
	      psz++;
	    }
	        // Skip leading zeroes in b256.
	    var it4 = size - length;
	    while (it4 !== size && b256[it4] === 0) {
	      it4++;
	    }
	    var vch = new Uint8Array(zeroes + (size - it4));
	    var j = zeroes;
	    while (it4 !== size) {
	      vch[j++] = b256[it4++];
	    }
	    return vch
	  }
	  function decode (string) {
	    var buffer = decodeUnsafe(string);
	    if (buffer) { return buffer }
	    throw new Error('Non-base' + BASE + ' character')
	  }
	  return {
	    encode: encode,
	    decodeUnsafe: decodeUnsafe,
	    decode: decode
	  }
	}
	src$1 = base;
	return src$1;
}

var bs58;
var hasRequiredBs58;

function requireBs58 () {
	if (hasRequiredBs58) return bs58;
	hasRequiredBs58 = 1;
	const basex = requireSrc();
	const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';

	bs58 = basex(ALPHABET);
	return bs58;
}

var base;
var hasRequiredBase;

function requireBase () {
	if (hasRequiredBase) return base;
	hasRequiredBase = 1;

	var base58 = requireBs58();

	base = function (checksumFn) {
	  // Encode a buffer as a base58-check encoded string
	  function encode (payload) {
	    var payloadU8 = Uint8Array.from(payload);
	    var checksum = checksumFn(payloadU8);
	    var length = payloadU8.length + 4;
	    var both = new Uint8Array(length);
	    both.set(payloadU8, 0);
	    both.set(checksum.subarray(0, 4), payloadU8.length);
	    return base58.encode(both, length)
	  }

	  function decodeRaw (buffer) {
	    var payload = buffer.slice(0, -4);
	    var checksum = buffer.slice(-4);
	    var newChecksum = checksumFn(payload);

	    if (checksum[0] ^ newChecksum[0] |
	        checksum[1] ^ newChecksum[1] |
	        checksum[2] ^ newChecksum[2] |
	        checksum[3] ^ newChecksum[3]) return

	    return payload
	  }

	  // Decode a base58-check encoded string to a buffer, no result if checksum is wrong
	  function decodeUnsafe (string) {
	    var buffer = base58.decodeUnsafe(string);
	    if (!buffer) return

	    return decodeRaw(buffer)
	  }

	  function decode (string) {
	    var buffer = base58.decode(string);
	    var payload = decodeRaw(buffer);
	    if (!payload) throw new Error('Invalid checksum')
	    return payload
	  }

	  return {
	    encode: encode,
	    decode: decode,
	    decodeUnsafe: decodeUnsafe
	  }
	};
	return base;
}

var bs58check$1;
var hasRequiredBs58check;

function requireBs58check () {
	if (hasRequiredBs58check) return bs58check$1;
	hasRequiredBs58check = 1;

	var { sha256 } = /*@__PURE__*/ requireSha256$1();
	var bs58checkBase = requireBase();

	// SHA256(SHA256(buffer))
	function sha256x2 (buffer) {
	  return sha256(sha256(buffer))
	}

	bs58check$1 = bs58checkBase(sha256x2);
	return bs58check$1;
}

var bs58checkExports = requireBs58check();
const bs58check = /*@__PURE__*/getDefaultExportFromCjs(bs58checkExports);

const urlPrefix = "automerge:";
/** Given an Automerge URL, returns the DocumentId in both base58check-encoded form and binary form */
const parseAutomergeUrl = (url) => {
    const regex = new RegExp(`^${urlPrefix}(\\w+)$`);
    const [, docMatch] = url.match(regex) || [];
    const documentId = docMatch;
    const binaryDocumentId = documentIdToBinary(documentId);
    if (!binaryDocumentId)
        throw new Error("Invalid document URL: " + url);
    return {
        /** unencoded DocumentId */
        binaryDocumentId,
        /** encoded DocumentId */
        documentId,
    };
};
/**
 * Given a documentId in either binary or base58check-encoded form, returns an Automerge URL.
 * Throws on invalid input.
 */
const stringifyAutomergeUrl = (arg) => {
    const documentId = arg instanceof Uint8Array || typeof arg === "string"
        ? arg
        : "documentId" in arg
            ? arg.documentId
            : undefined;
    const encodedDocumentId = documentId instanceof Uint8Array
        ? binaryToDocumentId(documentId)
        : typeof documentId === "string"
            ? documentId
            : undefined;
    if (encodedDocumentId === undefined)
        throw new Error("Invalid documentId: " + documentId);
    return (urlPrefix + encodedDocumentId);
};
/**
 * Given a string, returns true if it is a valid Automerge URL. This function also acts as a type
 * discriminator in Typescript.
 */
const isValidAutomergeUrl = (str) => {
    if (!str || !str.startsWith(urlPrefix))
        return false;
    const automergeUrl = str;
    try {
        const { documentId } = parseAutomergeUrl(automergeUrl);
        return isValidDocumentId(documentId);
    }
    catch {
        return false;
    }
};
const isValidDocumentId = (str) => {
    // try to decode from base58
    const binaryDocumentID = documentIdToBinary(str);
    if (binaryDocumentID === undefined)
        return false; // invalid base58check encoding
    // confirm that the document ID is a valid UUID
    const documentId = stringify(binaryDocumentID);
    return validate(documentId);
};
const isValidUuid = (str) => validate(str);
/**
 * Returns a new Automerge URL with a random UUID documentId. Called by Repo.create(), and also used by tests.
 */
const generateAutomergeUrl = () => {
    const documentId = v4(null, new Uint8Array(16));
    return stringifyAutomergeUrl({ documentId });
};
const documentIdToBinary = (docId) => bs58check.decodeUnsafe(docId);
const binaryToDocumentId = (docId) => bs58check.encode(docId);
/**
 * Given any valid expression of a document ID, returns a DocumentId in base58check-encoded form.
 *
 * Currently supports:
 * - base58check-encoded DocumentId
 * - Automerge URL
 * - legacy UUID
 * - binary DocumentId
 *
 * Throws on invalid input.
 */
const interpretAsDocumentId = (id) => {
    // binary
    if (id instanceof Uint8Array)
        return binaryToDocumentId(id);
    // url
    if (isValidAutomergeUrl(id))
        return parseAutomergeUrl(id).documentId;
    // base58check
    if (isValidDocumentId(id))
        return id;
    // legacy UUID
    if (isValidUuid(id)) {
        console.warn("Future versions will not support UUIDs as document IDs; use Automerge URLs instead.");
        const binaryDocumentID = parse(id);
        return binaryToDocumentId(binaryDocumentID);
    }
    // none of the above
    throw new Error(`Invalid AutomergeUrl: '${id}'`);
};

let decoder;
try {
	decoder = new TextDecoder();
} catch(error) {}
let src;
let srcEnd;
let position$1 = 0;
const LEGACY_RECORD_INLINE_ID = 105;
const RECORD_DEFINITIONS_ID = 0xdffe;
const RECORD_INLINE_ID = 0xdfff; // temporary first-come first-serve tag // proposed tag: 0x7265 // 're'
const BUNDLED_STRINGS_ID = 0xdff9;
const PACKED_REFERENCE_TAG_ID = 6;
const STOP_CODE = {};
let maxArraySize = 112810000; // This is the maximum array size in V8. We would potentially detect and set it higher
// for JSC, but this is pretty large and should be sufficient for most use cases
let maxMapSize = 16810000; // JavaScript has a fixed maximum map size of about 16710000, but JS itself enforces this,
let currentDecoder = {};
let currentStructures;
let srcString;
let srcStringStart = 0;
let srcStringEnd = 0;
let bundledStrings$1;
let referenceMap;
let currentExtensions = [];
let currentExtensionRanges = [];
let packedValues;
let dataView;
let restoreMapsAsObject;
let defaultOptions = {
	useRecords: false,
	mapsAsObjects: true
};
let sequentialMode = false;
let inlineObjectReadThreshold = 2;
// no-eval build
try {
	new Function('');
} catch(error) {
	// if eval variants are not supported, do not create inline object readers ever
	inlineObjectReadThreshold = Infinity;
}



class Decoder {
	constructor(options) {
		if (options) {
			if ((options.keyMap || options._keyMap) && !options.useRecords) {
				options.useRecords = false;
				options.mapsAsObjects = true;
			}
			if (options.useRecords === false && options.mapsAsObjects === undefined)
				options.mapsAsObjects = true;
			if (options.getStructures)
				options.getShared = options.getStructures;
			if (options.getShared && !options.structures)
				(options.structures = []).uninitialized = true; // this is what we use to denote an uninitialized structures
			if (options.keyMap) {
				this.mapKey = new Map();
				for (let [k,v] of Object.entries(options.keyMap)) this.mapKey.set(v,k);
			}
		}
		Object.assign(this, options);
	}
	/*
	decodeKey(key) {
		return this.keyMap
			? Object.keys(this.keyMap)[Object.values(this.keyMap).indexOf(key)] || key
			: key
	}
	*/
	decodeKey(key) {
		return this.keyMap ? this.mapKey.get(key) || key : key
	}
	
	encodeKey(key) {
		return this.keyMap && this.keyMap.hasOwnProperty(key) ? this.keyMap[key] : key
	}

	encodeKeys(rec) {
		if (!this._keyMap) return rec
		let map = new Map();
		for (let [k,v] of Object.entries(rec)) map.set((this._keyMap.hasOwnProperty(k) ? this._keyMap[k] : k), v);
		return map
	}

	decodeKeys(map) {
		if (!this._keyMap || map.constructor.name != 'Map') return map
		if (!this._mapKey) {
			this._mapKey = new Map();
			for (let [k,v] of Object.entries(this._keyMap)) this._mapKey.set(v,k);
		}
		let res = {};
		//map.forEach((v,k) => res[Object.keys(this._keyMap)[Object.values(this._keyMap).indexOf(k)] || k] = v)
		map.forEach((v,k) => res[safeKey(this._mapKey.has(k) ? this._mapKey.get(k) : k)] =  v);
		return res
	}
	
	mapDecode(source, end) {
	
		let res = this.decode(source);
		if (this._keyMap) { 
			//Experiemntal support for Optimised KeyMap  decoding 
			switch (res.constructor.name) {
				case 'Array': return res.map(r => this.decodeKeys(r))
				//case 'Map': return this.decodeKeys(res)
			}
		}
		return res
	}

	decode(source, end) {
		if (src) {
			// re-entrant execution, save the state and restore it after we do this decode
			return saveState(() => {
				clearSource();
				return this ? this.decode(source, end) : Decoder.prototype.decode.call(defaultOptions, source, end)
			})
		}
		srcEnd = end > -1 ? end : source.length;
		position$1 = 0;
		srcStringEnd = 0;
		srcString = null;
		bundledStrings$1 = null;
		src = source;
		// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend
		// technique for getting data from a database where it can be copied into an existing buffer instead of creating
		// new ones
		try {
			dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));
		} catch(error) {
			// if it doesn't have a buffer, maybe it is the wrong type of object
			src = null;
			if (source instanceof Uint8Array)
				throw error
			throw new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))
		}
		if (this instanceof Decoder) {
			currentDecoder = this;
			packedValues = this.sharedValues &&
				(this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) :
				this.sharedValues);
			if (this.structures) {
				currentStructures = this.structures;
				return checkedRead()
			} else if (!currentStructures || currentStructures.length > 0) {
				currentStructures = [];
			}
		} else {
			currentDecoder = defaultOptions;
			if (!currentStructures || currentStructures.length > 0)
				currentStructures = [];
			packedValues = null;
		}
		return checkedRead()
	}
	decodeMultiple(source, forEach) {
		let values, lastPosition = 0;
		try {
			let size = source.length;
			sequentialMode = true;
			let value = this ? this.decode(source, size) : defaultDecoder.decode(source, size);
			if (forEach) {
				if (forEach(value) === false) {
					return
				}
				while(position$1 < size) {
					lastPosition = position$1;
					if (forEach(checkedRead()) === false) {
						return
					}
				}
			}
			else {
				values = [ value ];
				while(position$1 < size) {
					lastPosition = position$1;
					values.push(checkedRead());
				}
				return values
			}
		} catch(error) {
			error.lastPosition = lastPosition;
			error.values = values;
			throw error
		} finally {
			sequentialMode = false;
			clearSource();
		}
	}
}
function checkedRead() {
	try {
		let result = read();
		if (bundledStrings$1) {
			if (position$1 >= bundledStrings$1.postBundlePosition) {
				let error = new Error('Unexpected bundle position');
				error.incomplete = true;
				throw error
			}
			// bundled strings to skip past
			position$1 = bundledStrings$1.postBundlePosition;
			bundledStrings$1 = null;
		}

		if (position$1 == srcEnd) {
			// finished reading this source, cleanup references
			currentStructures = null;
			src = null;
			if (referenceMap)
				referenceMap = null;
		} else if (position$1 > srcEnd) {
			// over read
			let error = new Error('Unexpected end of CBOR data');
			error.incomplete = true;
			throw error
		} else if (!sequentialMode) {
			throw new Error('Data read, but end of buffer not reached')
		}
		// else more to read, but we are reading sequentially, so don't clear source yet
		return result
	} catch(error) {
		clearSource();
		if (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer')) {
			error.incomplete = true;
		}
		throw error
	}
}

function read() {
	let token = src[position$1++];
	let majorType = token >> 5;
	token = token & 0x1f;
	if (token > 0x17) {
		switch (token) {
			case 0x18:
				token = src[position$1++];
				break
			case 0x19:
				if (majorType == 7) {
					return getFloat16()
				}
				token = dataView.getUint16(position$1);
				position$1 += 2;
				break
			case 0x1a:
				if (majorType == 7) {
					let value = dataView.getFloat32(position$1);
					if (currentDecoder.useFloat32 > 2) {
						// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
						let multiplier = mult10[((src[position$1] & 0x7f) << 1) | (src[position$1 + 1] >> 7)];
						position$1 += 4;
						return ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier
					}
					position$1 += 4;
					return value
				}
				token = dataView.getUint32(position$1);
				position$1 += 4;
				break
			case 0x1b:
				if (majorType == 7) {
					let value = dataView.getFloat64(position$1);
					position$1 += 8;
					return value
				}
				if (majorType > 1) {
					if (dataView.getUint32(position$1) > 0)
						throw new Error('JavaScript does not support arrays, maps, or strings with length over 4294967295')
					token = dataView.getUint32(position$1 + 4);
				} else if (currentDecoder.int64AsNumber) {
					token = dataView.getUint32(position$1) * 0x100000000;
					token += dataView.getUint32(position$1 + 4);
				} else
					token = dataView.getBigUint64(position$1);
				position$1 += 8;
				break
			case 0x1f: 
				// indefinite length
				switch(majorType) {
					case 2: // byte string
					case 3: // text string
						throw new Error('Indefinite length not supported for byte or text strings')
					case 4: // array
						let array = [];
						let value, i = 0;
						while ((value = read()) != STOP_CODE) {
							if (i >= maxArraySize) throw new Error(`Array length exceeds ${maxArraySize}`)
							array[i++] = value;
						}
						return majorType == 4 ? array : majorType == 3 ? array.join('') : Buffer.concat(array)
					case 5: // map
						let key;
						if (currentDecoder.mapsAsObjects) {
							let object = {};
							let i = 0;
							if (currentDecoder.keyMap) {
								while((key = read()) != STOP_CODE) {
									if (i++ >= maxMapSize) throw new Error(`Property count exceeds ${maxMapSize}`)
									object[safeKey(currentDecoder.decodeKey(key))] = read();
								}
							}
							else {
								while ((key = read()) != STOP_CODE) {
									if (i++ >= maxMapSize) throw new Error(`Property count exceeds ${maxMapSize}`)
									object[safeKey(key)] = read();
								}
							}
							return object
						} else {
							if (restoreMapsAsObject) {
								currentDecoder.mapsAsObjects = true;
								restoreMapsAsObject = false;
							}
							let map = new Map();
							if (currentDecoder.keyMap) {
								let i = 0;
								while((key = read()) != STOP_CODE) {
									if (i++ >= maxMapSize) {
										throw new Error(`Map size exceeds ${maxMapSize}`);
									}
									map.set(currentDecoder.decodeKey(key), read());
								}
							}
							else {
								let i = 0;
								while ((key = read()) != STOP_CODE) {
									if (i++ >= maxMapSize) {
										throw new Error(`Map size exceeds ${maxMapSize}`);
									}
									map.set(key, read());
								}
							}
							return map
						}
					case 7:
						return STOP_CODE
					default:
						throw new Error('Invalid major type for indefinite length ' + majorType)
				}
			default:
				throw new Error('Unknown token ' + token)
		}
	}
	switch (majorType) {
		case 0: // positive int
			return token
		case 1: // negative int
			return ~token
		case 2: // buffer
			return readBin(token)
		case 3: // string
			if (srcStringEnd >= position$1) {
				return srcString.slice(position$1 - srcStringStart, (position$1 += token) - srcStringStart)
			}
			if (srcStringEnd == 0 && srcEnd < 140 && token < 32) {
				// for small blocks, avoiding the overhead of the extract call is helpful
				let string = token < 16 ? shortStringInJS(token) : longStringInJS(token);
				if (string != null)
					return string
			}
			return readFixedString(token)
		case 4: // array
			if (token >= maxArraySize) throw new Error(`Array length exceeds ${maxArraySize}`)
			let array = new Array(token);
		  //if (currentDecoder.keyMap) for (let i = 0; i < token; i++) array[i] = currentDecoder.decodeKey(read())	
			//else 
			for (let i = 0; i < token; i++) array[i] = read();
			return array
		case 5: // map
			if (token >= maxMapSize) throw new Error(`Map size exceeds ${maxArraySize}`)
			if (currentDecoder.mapsAsObjects) {
				let object = {};
				if (currentDecoder.keyMap) for (let i = 0; i < token; i++) object[safeKey(currentDecoder.decodeKey(read()))] = read();
				else for (let i = 0; i < token; i++) object[safeKey(read())] = read();
				return object
			} else {
				if (restoreMapsAsObject) {
					currentDecoder.mapsAsObjects = true;
					restoreMapsAsObject = false;
				}
				let map = new Map();
				if (currentDecoder.keyMap) for (let i = 0; i < token; i++) map.set(currentDecoder.decodeKey(read()),read());
				else for (let i = 0; i < token; i++) map.set(read(), read());
				return map
			}
		case 6: // extension
			if (token >= BUNDLED_STRINGS_ID) {
				let structure = currentStructures[token & 0x1fff]; // check record structures first
				// At some point we may provide an option for dynamic tag assignment with a range like token >= 8 && (token < 16 || (token > 0x80 && token < 0xc0) || (token > 0x130 && token < 0x4000))
				if (structure) {
					if (!structure.read) structure.read = createStructureReader(structure);
					return structure.read()
				}
				if (token < 0x10000) {
					if (token == RECORD_INLINE_ID) { // we do a special check for this so that we can keep the
						// currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)
						let length = readJustLength();
						let id = read();
						let structure = read();
						recordDefinition(id, structure);
						let object = {};
						if (currentDecoder.keyMap) for (let i = 2; i < length; i++) {
							let key = currentDecoder.decodeKey(structure[i - 2]);
							object[safeKey(key)] = read();
						}
						else for (let i = 2; i < length; i++) {
							let key = structure[i - 2];
							object[safeKey(key)] = read();
						}
						return object
					}
					else if (token == RECORD_DEFINITIONS_ID) {
						let length = readJustLength();
						let id = read();
						for (let i = 2; i < length; i++) {
							recordDefinition(id++, read());
						}
						return read()
					} else if (token == BUNDLED_STRINGS_ID) {
						return readBundleExt()
					}
					if (currentDecoder.getShared) {
						loadShared();
						structure = currentStructures[token & 0x1fff];
						if (structure) {
							if (!structure.read)
								structure.read = createStructureReader(structure);
							return structure.read()
						}
					}
				}
			}
			let extension = currentExtensions[token];
			if (extension) {
				if (extension.handlesRead)
					return extension(read)
				else
					return extension(read())
			} else {
				let input = read();
				for (let i = 0; i < currentExtensionRanges.length; i++) {
					let value = currentExtensionRanges[i](token, input);
					if (value !== undefined)
						return value
				}
				return new Tag(input, token)
			}
		case 7: // fixed value
			switch (token) {
				case 0x14: return false
				case 0x15: return true
				case 0x16: return null
				case 0x17: return; // undefined
				case 0x1f:
				default:
					let packedValue = (packedValues || getPackedValues())[token];
					if (packedValue !== undefined)
						return packedValue
					throw new Error('Unknown token ' + token)
			}
		default: // negative int
			if (isNaN(token)) {
				let error = new Error('Unexpected end of CBOR data');
				error.incomplete = true;
				throw error
			}
			throw new Error('Unknown CBOR token ' + token)
	}
}
const validName = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
function createStructureReader(structure) {
	if (!structure) throw new Error('Structure is required in record definition');
	function readObject() {
		// get the array size from the header
		let length = src[position$1++];
		//let majorType = token >> 5
		length = length & 0x1f;
		if (length > 0x17) {
			switch (length) {
				case 0x18:
					length = src[position$1++];
					break
				case 0x19:
					length = dataView.getUint16(position$1);
					position$1 += 2;
					break
				case 0x1a:
					length = dataView.getUint32(position$1);
					position$1 += 4;
					break
				default:
					throw new Error('Expected array header, but got ' + src[position$1 - 1])
			}
		}
		// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function
		let compiledReader = this.compiledReader; // first look to see if we have the fast compiled function
		while(compiledReader) {
			// we have a fast compiled object literal reader
			if (compiledReader.propertyCount === length)
				return compiledReader(read) // with the right length, so we use it
			compiledReader = compiledReader.next; // see if there is another reader with the right length
		}
		if (this.slowReads++ >= inlineObjectReadThreshold) { // create a fast compiled reader
			let array = this.length == length ? this : this.slice(0, length);
			compiledReader = currentDecoder.keyMap 
			? new Function('r', 'return {' + array.map(k => currentDecoder.decodeKey(k)).map(k => validName.test(k) ? safeKey(k) + ':r()' : ('[' + JSON.stringify(k) + ']:r()')).join(',') + '}')
			: new Function('r', 'return {' + array.map(key => validName.test(key) ? safeKey(key) + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '}');
			if (this.compiledReader)
				compiledReader.next = this.compiledReader; // if there is an existing one, we store multiple readers as a linked list because it is usually pretty rare to have multiple readers (of different length) for the same structure
			compiledReader.propertyCount = length;
			this.compiledReader = compiledReader;
			return compiledReader(read)
		}
		let object = {};
		if (currentDecoder.keyMap) for (let i = 0; i < length; i++) object[safeKey(currentDecoder.decodeKey(this[i]))] = read();
		else for (let i = 0; i < length; i++) {
			object[safeKey(this[i])] = read();
		}
		return object
	}
	structure.slowReads = 0;
	return readObject
}

function safeKey(key) {
	// protect against prototype pollution
	if (typeof key === 'string') return key === '__proto__' ? '__proto_' : key
	if (typeof key === 'number' || typeof key === 'boolean' || typeof key === 'bigint') return key.toString();
	if (key == null) return key + '';
	// protect against expensive (DoS) string conversions
	throw new Error('Invalid property name type ' + typeof key);
}

let readFixedString = readStringJS;
function readStringJS(length) {
	let result;
	if (length < 16) {
		if (result = shortStringInJS(length))
			return result
	}
	if (length > 64 && decoder)
		return decoder.decode(src.subarray(position$1, position$1 += length))
	const end = position$1 + length;
	const units = [];
	result = '';
	while (position$1 < end) {
		const byte1 = src[position$1++];
		if ((byte1 & 0x80) === 0) {
			// 1 byte
			units.push(byte1);
		} else if ((byte1 & 0xe0) === 0xc0) {
			// 2 bytes
			const byte2 = src[position$1++] & 0x3f;
			units.push(((byte1 & 0x1f) << 6) | byte2);
		} else if ((byte1 & 0xf0) === 0xe0) {
			// 3 bytes
			const byte2 = src[position$1++] & 0x3f;
			const byte3 = src[position$1++] & 0x3f;
			units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);
		} else if ((byte1 & 0xf8) === 0xf0) {
			// 4 bytes
			const byte2 = src[position$1++] & 0x3f;
			const byte3 = src[position$1++] & 0x3f;
			const byte4 = src[position$1++] & 0x3f;
			let unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;
			if (unit > 0xffff) {
				unit -= 0x10000;
				units.push(((unit >>> 10) & 0x3ff) | 0xd800);
				unit = 0xdc00 | (unit & 0x3ff);
			}
			units.push(unit);
		} else {
			units.push(byte1);
		}

		if (units.length >= 0x1000) {
			result += fromCharCode.apply(String, units);
			units.length = 0;
		}
	}

	if (units.length > 0) {
		result += fromCharCode.apply(String, units);
	}

	return result
}
let fromCharCode = String.fromCharCode;
function longStringInJS(length) {
	let start = position$1;
	let bytes = new Array(length);
	for (let i = 0; i < length; i++) {
		const byte = src[position$1++];
		if ((byte & 0x80) > 0) {
			position$1 = start;
    			return
    		}
    		bytes[i] = byte;
    	}
    	return fromCharCode.apply(String, bytes)
}
function shortStringInJS(length) {
	if (length < 4) {
		if (length < 2) {
			if (length === 0)
				return ''
			else {
				let a = src[position$1++];
				if ((a & 0x80) > 1) {
					position$1 -= 1;
					return
				}
				return fromCharCode(a)
			}
		} else {
			let a = src[position$1++];
			let b = src[position$1++];
			if ((a & 0x80) > 0 || (b & 0x80) > 0) {
				position$1 -= 2;
				return
			}
			if (length < 3)
				return fromCharCode(a, b)
			let c = src[position$1++];
			if ((c & 0x80) > 0) {
				position$1 -= 3;
				return
			}
			return fromCharCode(a, b, c)
		}
	} else {
		let a = src[position$1++];
		let b = src[position$1++];
		let c = src[position$1++];
		let d = src[position$1++];
		if ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {
			position$1 -= 4;
			return
		}
		if (length < 6) {
			if (length === 4)
				return fromCharCode(a, b, c, d)
			else {
				let e = src[position$1++];
				if ((e & 0x80) > 0) {
					position$1 -= 5;
					return
				}
				return fromCharCode(a, b, c, d, e)
			}
		} else if (length < 8) {
			let e = src[position$1++];
			let f = src[position$1++];
			if ((e & 0x80) > 0 || (f & 0x80) > 0) {
				position$1 -= 6;
				return
			}
			if (length < 7)
				return fromCharCode(a, b, c, d, e, f)
			let g = src[position$1++];
			if ((g & 0x80) > 0) {
				position$1 -= 7;
				return
			}
			return fromCharCode(a, b, c, d, e, f, g)
		} else {
			let e = src[position$1++];
			let f = src[position$1++];
			let g = src[position$1++];
			let h = src[position$1++];
			if ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {
				position$1 -= 8;
				return
			}
			if (length < 10) {
				if (length === 8)
					return fromCharCode(a, b, c, d, e, f, g, h)
				else {
					let i = src[position$1++];
					if ((i & 0x80) > 0) {
						position$1 -= 9;
						return
					}
					return fromCharCode(a, b, c, d, e, f, g, h, i)
				}
			} else if (length < 12) {
				let i = src[position$1++];
				let j = src[position$1++];
				if ((i & 0x80) > 0 || (j & 0x80) > 0) {
					position$1 -= 10;
					return
				}
				if (length < 11)
					return fromCharCode(a, b, c, d, e, f, g, h, i, j)
				let k = src[position$1++];
				if ((k & 0x80) > 0) {
					position$1 -= 11;
					return
				}
				return fromCharCode(a, b, c, d, e, f, g, h, i, j, k)
			} else {
				let i = src[position$1++];
				let j = src[position$1++];
				let k = src[position$1++];
				let l = src[position$1++];
				if ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {
					position$1 -= 12;
					return
				}
				if (length < 14) {
					if (length === 12)
						return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)
					else {
						let m = src[position$1++];
						if ((m & 0x80) > 0) {
							position$1 -= 13;
							return
						}
						return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)
					}
				} else {
					let m = src[position$1++];
					let n = src[position$1++];
					if ((m & 0x80) > 0 || (n & 0x80) > 0) {
						position$1 -= 14;
						return
					}
					if (length < 15)
						return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)
					let o = src[position$1++];
					if ((o & 0x80) > 0) {
						position$1 -= 15;
						return
					}
					return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
				}
			}
		}
	}
}

function readBin(length) {
	return currentDecoder.copyBuffers ?
		// specifically use the copying slice (not the node one)
		Uint8Array.prototype.slice.call(src, position$1, position$1 += length) :
		src.subarray(position$1, position$1 += length)
}
let f32Array = new Float32Array(1);
let u8Array = new Uint8Array(f32Array.buffer, 0, 4);
function getFloat16() {
	let byte0 = src[position$1++];
	let byte1 = src[position$1++];
	let exponent = (byte0 & 0x7f) >> 2;
	if (exponent === 0x1f) { // specials
		if (byte1 || (byte0 & 3))
			return NaN;
		return (byte0 & 0x80) ? -Infinity : Infinity;
	}
	if (exponent === 0) { // sub-normals
		// significand with 10 fractional bits and divided by 2^14
		let abs = (((byte0 & 3) << 8) | byte1) / (1 << 24);
		return (byte0 & 0x80) ? -abs : abs
	}

	u8Array[3] = (byte0 & 0x80) | // sign bit
		((exponent >> 1) + 56); // 4 of 5 of the exponent bits, re-offset-ed
	u8Array[2] = ((byte0 & 7) << 5) | // last exponent bit and first two mantissa bits
		(byte1 >> 3); // next 5 bits of mantissa
	u8Array[1] = byte1 << 5; // last three bits of mantissa
	u8Array[0] = 0;
	return f32Array[0];
}

new Array(4096);

class Tag {
	constructor(value, tag) {
		this.value = value;
		this.tag = tag;
	}
}

currentExtensions[0] = (dateString) => {
	// string date extension
	return new Date(dateString)
};

currentExtensions[1] = (epochSec) => {
	// numeric date extension
	return new Date(Math.round(epochSec * 1000))
};

currentExtensions[2] = (buffer) => {
	// bigint extension
	let value = BigInt(0);
	for (let i = 0, l = buffer.byteLength; i < l; i++) {
		value = BigInt(buffer[i]) + (value << BigInt(8));
	}
	return value
};

currentExtensions[3] = (buffer) => {
	// negative bigint extension
	return BigInt(-1) - currentExtensions[2](buffer)
};
currentExtensions[4] = (fraction) => {
	// best to reparse to maintain accuracy
	return +(fraction[1] + 'e' + fraction[0])
};

currentExtensions[5] = (fraction) => {
	// probably not sufficiently accurate
	return fraction[1] * Math.exp(fraction[0] * Math.log(2))
};

// the registration of the record definition extension
const recordDefinition = (id, structure) => {
	id = id - 0xe000;
	let existingStructure = currentStructures[id];
	if (existingStructure && existingStructure.isShared) {
		(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;
	}
	currentStructures[id] = structure;

	structure.read = createStructureReader(structure);
};
currentExtensions[LEGACY_RECORD_INLINE_ID] = (data) => {
	let length = data.length;
	let structure = data[1];
	recordDefinition(data[0], structure);
	let object = {};
	for (let i = 2; i < length; i++) {
		let key = structure[i - 2];
		object[safeKey(key)] = data[i];
	}
	return object
};
currentExtensions[14] = (value) => {
	if (bundledStrings$1)
		return bundledStrings$1[0].slice(bundledStrings$1.position0, bundledStrings$1.position0 += value)
	return new Tag(value, 14)
};
currentExtensions[15] = (value) => {
	if (bundledStrings$1)
		return bundledStrings$1[1].slice(bundledStrings$1.position1, bundledStrings$1.position1 += value)
	return new Tag(value, 15)
};
let glbl = { Error, RegExp };
currentExtensions[27] = (data) => { // http://cbor.schmorp.de/generic-object
	return (glbl[data[0]] || Error)(data[1], data[2])
};
const packedTable = (read) => {
	if (src[position$1++] != 0x84) {
		let error = new Error('Packed values structure must be followed by a 4 element array');
		if (src.length < position$1)
			error.incomplete = true;
		throw error
	}
	let newPackedValues = read(); // packed values
	if (!newPackedValues || !newPackedValues.length) {
		let error = new Error('Packed values structure must be followed by a 4 element array');
		error.incomplete = true;
		throw error
	}
	packedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues;
	packedValues.prefixes = read();
	packedValues.suffixes = read();
	return read() // read the rump
};
packedTable.handlesRead = true;
currentExtensions[51] = packedTable;

currentExtensions[PACKED_REFERENCE_TAG_ID] = (data) => { // packed reference
	if (!packedValues) {
		if (currentDecoder.getShared)
			loadShared();
		else
			return new Tag(data, PACKED_REFERENCE_TAG_ID)
	}
	if (typeof data == 'number')
		return packedValues[16 + (data >= 0 ? 2 * data : (-2 * data - 1))]
	let error = new Error('No support for non-integer packed references yet');
	if (data === undefined)
		error.incomplete = true;
	throw error
};

// The following code is an incomplete implementation of http://cbor.schmorp.de/stringref
// the real thing would need to implemennt more logic to populate the stringRefs table and
// maintain a stack of stringRef "namespaces".
//
// currentExtensions[25] = (id) => {
// 	return stringRefs[id]
// }
// currentExtensions[256] = (read) => {
// 	stringRefs = []
// 	try {
// 		return read()
// 	} finally {
// 		stringRefs = null
// 	}
// }
// currentExtensions[256].handlesRead = true

currentExtensions[28] = (read) => { 
	// shareable http://cbor.schmorp.de/value-sharing (for structured clones)
	if (!referenceMap) {
		referenceMap = new Map();
		referenceMap.id = 0;
	}
	let id = referenceMap.id++;
	let startingPosition = position$1;
	let token = src[position$1];
	let target;
	// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read
	// ahead past references to record structure definitions
	if ((token >> 5) == 4)
		target = [];
	else
		target = {};

	let refEntry = { target }; // a placeholder object
	referenceMap.set(id, refEntry);
	let targetProperties = read(); // read the next value as the target object to id
	if (refEntry.used) {// there is a cycle, so we have to assign properties to original target
		if (Object.getPrototypeOf(target) !== Object.getPrototypeOf(targetProperties)) {
			// this means that the returned target does not match the targetProperties, so we need rerun the read to
			// have the correctly create instance be assigned as a reference, then we do the copy the properties back to the
			// target
			// reset the position so that the read can be repeated
			position$1 = startingPosition;
			// the returned instance is our new target for references
			target = targetProperties;
			referenceMap.set(id, { target });
			targetProperties = read();
		}
		return Object.assign(target, targetProperties)
	}
	refEntry.target = targetProperties; // the placeholder wasn't used, replace with the deserialized one
	return targetProperties // no cycle, can just use the returned read object
};
currentExtensions[28].handlesRead = true;

currentExtensions[29] = (id) => {
	// sharedref http://cbor.schmorp.de/value-sharing (for structured clones)
	let refEntry = referenceMap.get(id);
	refEntry.used = true;
	return refEntry.target
};

currentExtensions[258] = (array) => new Set(array); // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md
(currentExtensions[259] = (read) => {
	// https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec
	// for decoding as a standard Map
	if (currentDecoder.mapsAsObjects) {
		currentDecoder.mapsAsObjects = false;
		restoreMapsAsObject = true;
	}
	return read()
}).handlesRead = true;
function combine(a, b) {
	if (typeof a === 'string')
		return a + b
	if (a instanceof Array)
		return a.concat(b)
	return Object.assign({}, a, b)
}
function getPackedValues() {
	if (!packedValues) {
		if (currentDecoder.getShared)
			loadShared();
		else
			throw new Error('No packed values available')
	}
	return packedValues
}
const SHARED_DATA_TAG_ID = 0x53687264; // ascii 'Shrd'
currentExtensionRanges.push((tag, input) => {
	if (tag >= 225 && tag <= 255)
		return combine(getPackedValues().prefixes[tag - 224], input)
	if (tag >= 28704 && tag <= 32767)
		return combine(getPackedValues().prefixes[tag - 28672], input)
	if (tag >= 1879052288 && tag <= 2147483647)
		return combine(getPackedValues().prefixes[tag - 1879048192], input)
	if (tag >= 216 && tag <= 223)
		return combine(input, getPackedValues().suffixes[tag - 216])
	if (tag >= 27647 && tag <= 28671)
		return combine(input, getPackedValues().suffixes[tag - 27639])
	if (tag >= 1811940352 && tag <= 1879048191)
		return combine(input, getPackedValues().suffixes[tag - 1811939328])
	if (tag == SHARED_DATA_TAG_ID) {// we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)
		return {
			packedValues: packedValues,
			structures: currentStructures.slice(0),
			version: input,
		}
	}
	if (tag == 55799) // self-descriptive CBOR tag, just return input value
		return input
});

const isLittleEndianMachine$1 = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
const typedArrays = [Uint8Array, Uint8ClampedArray, Uint16Array, Uint32Array,
	typeof BigUint64Array == 'undefined' ? { name:'BigUint64Array' } : BigUint64Array, Int8Array, Int16Array, Int32Array,
	typeof BigInt64Array == 'undefined' ? { name:'BigInt64Array' } : BigInt64Array, Float32Array, Float64Array];
const typedArrayTags = [64, 68, 69, 70, 71, 72, 77, 78, 79, 85, 86];
for (let i = 0; i < typedArrays.length; i++) {
	registerTypedArray(typedArrays[i], typedArrayTags[i]);
}
function registerTypedArray(TypedArray, tag) {
	let dvMethod = 'get' + TypedArray.name.slice(0, -5);
	let bytesPerElement;
	if (typeof TypedArray === 'function')
		bytesPerElement = TypedArray.BYTES_PER_ELEMENT;
	else
		TypedArray = null;
	for (let littleEndian = 0; littleEndian < 2; littleEndian++) {
		if (!littleEndian && bytesPerElement == 1)
			continue
		let sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : bytesPerElement == 8 ? 3 : 0;
		currentExtensions[littleEndian ? tag : (tag - 4)] = (bytesPerElement == 1 || littleEndian == isLittleEndianMachine$1) ? (buffer) => {
			if (!TypedArray)
				throw new Error('Could not find typed array for code ' + tag)
			if (!currentDecoder.copyBuffers) {
				// try provide a direct view, but will only work if we are byte-aligned
				if (bytesPerElement === 1 ||
					bytesPerElement === 2 && !(buffer.byteOffset & 1) ||
					bytesPerElement === 4 && !(buffer.byteOffset & 3) ||
					bytesPerElement === 8 && !(buffer.byteOffset & 7))
					return new TypedArray(buffer.buffer, buffer.byteOffset, buffer.byteLength >> sizeShift);
			}
			// we have to slice/copy here to get a new ArrayBuffer, if we are not word/byte aligned
			return new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer)
		} : buffer => {
			if (!TypedArray)
				throw new Error('Could not find typed array for code ' + tag)
			let dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
			let elements = buffer.length >> sizeShift;
			let ta = new TypedArray(elements);
			let method = dv[dvMethod];
			for (let i = 0; i < elements; i++) {
				ta[i] = method.call(dv, i << sizeShift, littleEndian);
			}
			return ta
		};
	}
}

function readBundleExt() {
	let length = readJustLength();
	let bundlePosition = position$1 + read();
	for (let i = 2; i < length; i++) {
		// skip past bundles that were already read
		let bundleLength = readJustLength(); // this will increment position, so must add to position afterwards
		position$1 += bundleLength;
	}
	let dataPosition = position$1;
	position$1 = bundlePosition;
	bundledStrings$1 = [readStringJS(readJustLength()), readStringJS(readJustLength())];
	bundledStrings$1.position0 = 0;
	bundledStrings$1.position1 = 0;
	bundledStrings$1.postBundlePosition = position$1;
	position$1 = dataPosition;
	return read()
}

function readJustLength() {
	let token = src[position$1++] & 0x1f;
	if (token > 0x17) {
		switch (token) {
			case 0x18:
				token = src[position$1++];
				break
			case 0x19:
				token = dataView.getUint16(position$1);
				position$1 += 2;
				break
			case 0x1a:
				token = dataView.getUint32(position$1);
				position$1 += 4;
				break
		}
	}
	return token
}

function loadShared() {
	if (currentDecoder.getShared) {
		let sharedData = saveState(() => {
			// save the state in case getShared modifies our buffer
			src = null;
			return currentDecoder.getShared()
		}) || {};
		let updatedStructures = sharedData.structures || [];
		currentDecoder.sharedVersion = sharedData.version;
		packedValues = currentDecoder.sharedValues = sharedData.packedValues;
		if (currentStructures === true)
			currentDecoder.structures = currentStructures = updatedStructures;
		else
			currentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures));
	}
}

function saveState(callback) {
	let savedSrcEnd = srcEnd;
	let savedPosition = position$1;
	let savedSrcStringStart = srcStringStart;
	let savedSrcStringEnd = srcStringEnd;
	let savedSrcString = srcString;
	let savedReferenceMap = referenceMap;
	let savedBundledStrings = bundledStrings$1;

	// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)
	let savedSrc = new Uint8Array(src.slice(0, srcEnd)); // we copy the data in case it changes while external data is processed
	let savedStructures = currentStructures;
	let savedDecoder = currentDecoder;
	let savedSequentialMode = sequentialMode;
	let value = callback();
	srcEnd = savedSrcEnd;
	position$1 = savedPosition;
	srcStringStart = savedSrcStringStart;
	srcStringEnd = savedSrcStringEnd;
	srcString = savedSrcString;
	referenceMap = savedReferenceMap;
	bundledStrings$1 = savedBundledStrings;
	src = savedSrc;
	sequentialMode = savedSequentialMode;
	currentStructures = savedStructures;
	currentDecoder = savedDecoder;
	dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);
	return value
}
function clearSource() {
	src = null;
	referenceMap = null;
	currentStructures = null;
}

const mult10 = new Array(147); // this is a table matching binary exponents to the multiplier to determine significant digit rounding
for (let i = 0; i < 256; i++) {
	mult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103));
}
let defaultDecoder = new Decoder({ useRecords: false });
const decode$1 = defaultDecoder.decode;
defaultDecoder.decodeMultiple;

let textEncoder;
try {
	textEncoder = new TextEncoder();
} catch (error) {}
let extensions, extensionClasses;
const Buffer$1 = typeof globalThis === 'object' && globalThis.Buffer;
const hasNodeBuffer = typeof Buffer$1 !== 'undefined';
const ByteArrayAllocate = hasNodeBuffer ? Buffer$1.allocUnsafeSlow : Uint8Array;
const ByteArray = hasNodeBuffer ? Buffer$1 : Uint8Array;
const MAX_STRUCTURES = 0x100;
const MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000;
let throwOnIterable;
let target;
let targetView;
let position = 0;
let safeEnd;
let bundledStrings = null;
const MAX_BUNDLE_SIZE = 0xf000;
const hasNonLatin = /[\u0080-\uFFFF]/;
const RECORD_SYMBOL = Symbol('record-id');
class Encoder extends Decoder {
	constructor(options) {
		super(options);
		this.offset = 0;
		let start;
		let sharedStructures;
		let hasSharedUpdate;
		let structures;
		let referenceMap;
		options = options || {};
		let encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position, maxBytes) {
			return target.utf8Write(string, position, maxBytes)
		} : (textEncoder && textEncoder.encodeInto) ?
			function(string, position) {
				return textEncoder.encodeInto(string, target.subarray(position)).written
			} : false;

		let encoder = this;
		let hasSharedStructures = options.structures || options.saveStructures;
		let maxSharedStructures = options.maxSharedStructures;
		if (maxSharedStructures == null)
			maxSharedStructures = hasSharedStructures ? 128 : 0;
		if (maxSharedStructures > 8190)
			throw new Error('Maximum maxSharedStructure is 8190')
		let isSequential = options.sequential;
		if (isSequential) {
			maxSharedStructures = 0;
		}
		if (!this.structures)
			this.structures = [];
		if (this.saveStructures)
			this.saveShared = this.saveStructures;
		let samplingPackedValues, packedObjectMap, sharedValues = options.sharedValues;
		let sharedPackedObjectMap;
		if (sharedValues) {
			sharedPackedObjectMap = Object.create(null);
			for (let i = 0, l = sharedValues.length; i < l; i++) {
				sharedPackedObjectMap[sharedValues[i]] = i;
			}
		}
		let recordIdsToRemove = [];
		let transitionsCount = 0;
		let serializationsSinceTransitionRebuild = 0;
		
		this.mapEncode = function(value, encodeOptions) {
			// Experimental support for premapping keys using _keyMap instad of keyMap - not optiimised yet)
			if (this._keyMap && !this._mapped) {
				//console.log('encoding ', value)
				switch (value.constructor.name) {
					case 'Array': 
						value = value.map(r => this.encodeKeys(r));
						break
					//case 'Map': 
					//	value = this.encodeKeys(value)
					//	break
				}
				//this._mapped = true
			}
			return this.encode(value, encodeOptions)
		};
		
		this.encode = function(value, encodeOptions)	{
			if (!target) {
				target = new ByteArrayAllocate(8192);
				targetView = new DataView(target.buffer, 0, 8192);
				position = 0;
			}
			safeEnd = target.length - 10;
			if (safeEnd - position < 0x800) {
				// don't start too close to the end, 
				target = new ByteArrayAllocate(target.length);
				targetView = new DataView(target.buffer, 0, target.length);
				safeEnd = target.length - 10;
				position = 0;
			} else if (encodeOptions === REUSE_BUFFER_MODE)
				position = (position + 7) & 0x7ffffff8; // Word align to make any future copying of this buffer faster
			start = position;
			if (encoder.useSelfDescribedHeader) {
				targetView.setUint32(position, 0xd9d9f700); // tag two byte, then self-descriptive tag
				position += 3;
			}
			referenceMap = encoder.structuredClone ? new Map() : null;
			if (encoder.bundleStrings && typeof value !== 'string') {
				bundledStrings = [];
				bundledStrings.size = Infinity; // force a new bundle start on first string
			} else
				bundledStrings = null;

			sharedStructures = encoder.structures;
			if (sharedStructures) {
				if (sharedStructures.uninitialized) {
					let sharedData = encoder.getShared() || {};
					encoder.structures = sharedStructures = sharedData.structures || [];
					encoder.sharedVersion = sharedData.version;
					let sharedValues = encoder.sharedValues = sharedData.packedValues;
					if (sharedValues) {
						sharedPackedObjectMap = {};
						for (let i = 0, l = sharedValues.length; i < l; i++)
							sharedPackedObjectMap[sharedValues[i]] = i;
					}
				}
				let sharedStructuresLength = sharedStructures.length;
				if (sharedStructuresLength > maxSharedStructures && !isSequential)
					sharedStructuresLength = maxSharedStructures;
				if (!sharedStructures.transitions) {
					// rebuild our structure transitions
					sharedStructures.transitions = Object.create(null);
					for (let i = 0; i < sharedStructuresLength; i++) {
						let keys = sharedStructures[i];
						//console.log('shared struct keys:', keys)
						if (!keys)
							continue
						let nextTransition, transition = sharedStructures.transitions;
						for (let j = 0, l = keys.length; j < l; j++) {
							if (transition[RECORD_SYMBOL] === undefined)
								transition[RECORD_SYMBOL] = i;
							let key = keys[j];
							nextTransition = transition[key];
							if (!nextTransition) {
								nextTransition = transition[key] = Object.create(null);
							}
							transition = nextTransition;
						}
						transition[RECORD_SYMBOL] = i | 0x100000;
					}
				}
				if (!isSequential)
					sharedStructures.nextId = sharedStructuresLength;
			}
			if (hasSharedUpdate)
				hasSharedUpdate = false;
			structures = sharedStructures || [];
			packedObjectMap = sharedPackedObjectMap;
			if (options.pack) {
				let packedValues = new Map();
				packedValues.values = [];
				packedValues.encoder = encoder;
				packedValues.maxValues = options.maxPrivatePackedValues || (sharedPackedObjectMap ? 16 : Infinity);
				packedValues.objectMap = sharedPackedObjectMap || false;
				packedValues.samplingPackedValues = samplingPackedValues;
				findRepetitiveStrings(value, packedValues);
				if (packedValues.values.length > 0) {
					target[position++] = 0xd8; // one-byte tag
					target[position++] = 51; // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt
					writeArrayHeader(4);
					let valuesArray = packedValues.values;
					encode(valuesArray);
					writeArrayHeader(0); // prefixes
					writeArrayHeader(0); // suffixes
					packedObjectMap = Object.create(sharedPackedObjectMap || null);
					for (let i = 0, l = valuesArray.length; i < l; i++) {
						packedObjectMap[valuesArray[i]] = i;
					}
				}
			}
			throwOnIterable = encodeOptions & THROW_ON_ITERABLE;
			try {
				if (throwOnIterable)
					return;
				encode(value);
				if (bundledStrings) {
					writeBundles(start, encode);
				}
				encoder.offset = position; // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially
				if (referenceMap && referenceMap.idsToInsert) {
					position += referenceMap.idsToInsert.length * 2;
					if (position > safeEnd)
						makeRoom(position);
					encoder.offset = position;
					let serialized = insertIds(target.subarray(start, position), referenceMap.idsToInsert);
					referenceMap = null;
					return serialized
				}
				if (encodeOptions & REUSE_BUFFER_MODE) {
					target.start = start;
					target.end = position;
					return target
				}
				return target.subarray(start, position) // position can change if we call encode again in saveShared, so we get the buffer now
			} finally {
				if (sharedStructures) {
					if (serializationsSinceTransitionRebuild < 10)
						serializationsSinceTransitionRebuild++;
					if (sharedStructures.length > maxSharedStructures)
						sharedStructures.length = maxSharedStructures;
					if (transitionsCount > 10000) {
						// force a rebuild occasionally after a lot of transitions so it can get cleaned up
						sharedStructures.transitions = null;
						serializationsSinceTransitionRebuild = 0;
						transitionsCount = 0;
						if (recordIdsToRemove.length > 0)
							recordIdsToRemove = [];
					} else if (recordIdsToRemove.length > 0 && !isSequential) {
						for (let i = 0, l = recordIdsToRemove.length; i < l; i++) {
							recordIdsToRemove[i][RECORD_SYMBOL] = undefined;
						}
						recordIdsToRemove = [];
						//sharedStructures.nextId = maxSharedStructures
					}
				}
				if (hasSharedUpdate && encoder.saveShared) {
					if (encoder.structures.length > maxSharedStructures) {
						encoder.structures = encoder.structures.slice(0, maxSharedStructures);
					}
					// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save
					let returnBuffer = target.subarray(start, position);
					if (encoder.updateSharedData() === false)
						return encoder.encode(value) // re-encode if it fails
					return returnBuffer
				}
				if (encodeOptions & RESET_BUFFER_MODE)
					position = start;
			}
		};
		this.findCommonStringsToPack = () => {
			samplingPackedValues = new Map();
			if (!sharedPackedObjectMap)
				sharedPackedObjectMap = Object.create(null);
			return (options) => {
				let threshold = options && options.threshold || 4;
				let position = this.pack ? options.maxPrivatePackedValues || 16 : 0;
				if (!sharedValues)
					sharedValues = this.sharedValues = [];
				for (let [ key, status ] of samplingPackedValues) {
					if (status.count > threshold) {
						sharedPackedObjectMap[key] = position++;
						sharedValues.push(key);
						hasSharedUpdate = true;
					}
				}
				while (this.saveShared && this.updateSharedData() === false) {}
				samplingPackedValues = null;
			}
		};
		const encode = (value) => {
			if (position > safeEnd)
				target = makeRoom(position);

			var type = typeof value;
			var length;
			if (type === 'string') {
				if (packedObjectMap) {
					let packedPosition = packedObjectMap[value];
					if (packedPosition >= 0) {
						if (packedPosition < 16)
							target[position++] = packedPosition + 0xe0; // simple values, defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt
						else {
							target[position++] = 0xc6; // tag 6 defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt
							if (packedPosition & 1)
								encode((15 - packedPosition) >> 1);
							else
								encode((packedPosition - 16) >> 1);
						}
						return
/*						} else if (packedStatus.serializationId != serializationId) {
							packedStatus.serializationId = serializationId
							packedStatus.count = 1
							if (options.sharedPack) {
								let sharedCount = packedStatus.sharedCount = (packedStatus.sharedCount || 0) + 1
								if (shareCount > (options.sharedPack.threshold || 5)) {
									let sharedPosition = packedStatus.position = packedStatus.nextSharedPosition
									hasSharedUpdate = true
									if (sharedPosition < 16)
										target[position++] = sharedPosition + 0xc0

								}
							}
						} // else any in-doc incrementation?*/
					} else if (samplingPackedValues && !options.pack) {
						let status = samplingPackedValues.get(value);
						if (status)
							status.count++;
						else
							samplingPackedValues.set(value, {
								count: 1,
							});
					}
				}
				let strLength = value.length;
				if (bundledStrings && strLength >= 4 && strLength < 0x400) {
					if ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {
						let extStart;
						let maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10;
						if (position + maxBytes > safeEnd)
							target = makeRoom(position + maxBytes);
						target[position++] = 0xd9; // tag 16-bit
						target[position++] = 0xdf; // tag 0xdff9
						target[position++] = 0xf9;
						// TODO: If we only have one bundle with any string data, only write one string bundle
						target[position++] = bundledStrings.position ? 0x84 : 0x82; // array of 4 or 2 elements depending on if we write bundles
						target[position++] = 0x1a; // 32-bit unsigned int
						extStart = position - start;
						position += 4; // reserve for writing bundle reference
						if (bundledStrings.position) {
							writeBundles(start, encode); // write the last bundles
						}
						bundledStrings = ['', '']; // create new ones
						bundledStrings.size = 0;
						bundledStrings.position = extStart;
					}
					let twoByte = hasNonLatin.test(value);
					bundledStrings[twoByte ? 0 : 1] += value;
					target[position++] = twoByte ? 0xce : 0xcf;
					encode(strLength);
					return
				}
				let headerSize;
				// first we estimate the header size, so we can write to the correct location
				if (strLength < 0x20) {
					headerSize = 1;
				} else if (strLength < 0x100) {
					headerSize = 2;
				} else if (strLength < 0x10000) {
					headerSize = 3;
				} else {
					headerSize = 5;
				}
				let maxBytes = strLength * 3;
				if (position + maxBytes > safeEnd)
					target = makeRoom(position + maxBytes);

				if (strLength < 0x40 || !encodeUtf8) {
					let i, c1, c2, strPosition = position + headerSize;
					for (i = 0; i < strLength; i++) {
						c1 = value.charCodeAt(i);
						if (c1 < 0x80) {
							target[strPosition++] = c1;
						} else if (c1 < 0x800) {
							target[strPosition++] = c1 >> 6 | 0xc0;
							target[strPosition++] = c1 & 0x3f | 0x80;
						} else if (
							(c1 & 0xfc00) === 0xd800 &&
							((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00
						) {
							c1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);
							i++;
							target[strPosition++] = c1 >> 18 | 0xf0;
							target[strPosition++] = c1 >> 12 & 0x3f | 0x80;
							target[strPosition++] = c1 >> 6 & 0x3f | 0x80;
							target[strPosition++] = c1 & 0x3f | 0x80;
						} else {
							target[strPosition++] = c1 >> 12 | 0xe0;
							target[strPosition++] = c1 >> 6 & 0x3f | 0x80;
							target[strPosition++] = c1 & 0x3f | 0x80;
						}
					}
					length = strPosition - position - headerSize;
				} else {
					length = encodeUtf8(value, position + headerSize, maxBytes);
				}

				if (length < 0x18) {
					target[position++] = 0x60 | length;
				} else if (length < 0x100) {
					if (headerSize < 2) {
						target.copyWithin(position + 2, position + 1, position + 1 + length);
					}
					target[position++] = 0x78;
					target[position++] = length;
				} else if (length < 0x10000) {
					if (headerSize < 3) {
						target.copyWithin(position + 3, position + 2, position + 2 + length);
					}
					target[position++] = 0x79;
					target[position++] = length >> 8;
					target[position++] = length & 0xff;
				} else {
					if (headerSize < 5) {
						target.copyWithin(position + 5, position + 3, position + 3 + length);
					}
					target[position++] = 0x7a;
					targetView.setUint32(position, length);
					position += 4;
				}
				position += length;
			} else if (type === 'number') {
				if (!this.alwaysUseFloat && value >>> 0 === value) {// positive integer, 32-bit or less
					// positive uint
					if (value < 0x18) {
						target[position++] = value;
					} else if (value < 0x100) {
						target[position++] = 0x18;
						target[position++] = value;
					} else if (value < 0x10000) {
						target[position++] = 0x19;
						target[position++] = value >> 8;
						target[position++] = value & 0xff;
					} else {
						target[position++] = 0x1a;
						targetView.setUint32(position, value);
						position += 4;
					}
				} else if (!this.alwaysUseFloat && value >> 0 === value) { // negative integer
					if (value >= -0x18) {
						target[position++] = 0x1f - value;
					} else if (value >= -0x100) {
						target[position++] = 0x38;
						target[position++] = ~value;
					} else if (value >= -0x10000) {
						target[position++] = 0x39;
						targetView.setUint16(position, ~value);
						position += 2;
					} else {
						target[position++] = 0x3a;
						targetView.setUint32(position, ~value);
						position += 4;
					}
				} else {
					let useFloat32;
					if ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {
						target[position++] = 0xfa;
						targetView.setFloat32(position, value);
						let xShifted;
						if (useFloat32 < 4 ||
								// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
								((xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {
							position += 4;
							return
						} else
							position--; // move back into position for writing a double
					}
					target[position++] = 0xfb;
					targetView.setFloat64(position, value);
					position += 8;
				}
			} else if (type === 'object') {
				if (!value)
					target[position++] = 0xf6;
				else {
					if (referenceMap) {
						let referee = referenceMap.get(value);
						if (referee) {
							target[position++] = 0xd8;
							target[position++] = 29; // http://cbor.schmorp.de/value-sharing
							target[position++] = 0x19; // 16-bit uint
							if (!referee.references) {
								let idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = []);
								referee.references = [];
								idsToInsert.push(referee);
							}
							referee.references.push(position - start);
							position += 2; // TODO: also support 32-bit
							return
						} else 
							referenceMap.set(value, { offset: position - start });
					}
					let constructor = value.constructor;
					if (constructor === Object) {
						writeObject(value);
					} else if (constructor === Array) {
						length = value.length;
						if (length < 0x18) {
							target[position++] = 0x80 | length;
						} else {
							writeArrayHeader(length);
						}
						for (let i = 0; i < length; i++) {
							encode(value[i]);
						}
					} else if (constructor === Map) {
						if (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {
							// use Tag 259 (https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec--explicit-maps.md) for maps if the user wants it that way
							target[position++] = 0xd9;
							target[position++] = 1;
							target[position++] = 3;
						}
						length = value.size;
						if (length < 0x18) {
							target[position++] = 0xa0 | length;
						} else if (length < 0x100) {
							target[position++] = 0xb8;
							target[position++] = length;
						} else if (length < 0x10000) {
							target[position++] = 0xb9;
							target[position++] = length >> 8;
							target[position++] = length & 0xff;
						} else {
							target[position++] = 0xba;
							targetView.setUint32(position, length);
							position += 4;
						}
						if (encoder.keyMap) { 
							for (let [ key, entryValue ] of value) {
								encode(encoder.encodeKey(key));
								encode(entryValue);
							} 
						} else { 
							for (let [ key, entryValue ] of value) {
								encode(key); 
								encode(entryValue);
							} 	
						}
					} else {
						for (let i = 0, l = extensions.length; i < l; i++) {
							let extensionClass = extensionClasses[i];
							if (value instanceof extensionClass) {
								let extension = extensions[i];
								let tag = extension.tag;
								if (tag == undefined)
									tag = extension.getTag && extension.getTag.call(this, value);
								if (tag < 0x18) {
									target[position++] = 0xc0 | tag;
								} else if (tag < 0x100) {
									target[position++] = 0xd8;
									target[position++] = tag;
								} else if (tag < 0x10000) {
									target[position++] = 0xd9;
									target[position++] = tag >> 8;
									target[position++] = tag & 0xff;
								} else if (tag > -1) {
									target[position++] = 0xda;
									targetView.setUint32(position, tag);
									position += 4;
								} // else undefined, don't write tag
								extension.encode.call(this, value, encode, makeRoom);
								return
							}
						}
						if (value[Symbol.iterator]) {
							if (throwOnIterable) {
								let error = new Error('Iterable should be serialized as iterator');
								error.iteratorNotHandled = true;
								throw error;
							}
							target[position++] = 0x9f; // indefinite length array
							for (let entry of value) {
								encode(entry);
							}
							target[position++] = 0xff; // stop-code
							return
						}
						if (value[Symbol.asyncIterator] || isBlob(value)) {
							let error = new Error('Iterable/blob should be serialized as iterator');
							error.iteratorNotHandled = true;
							throw error;
						}
						if (this.useToJSON && value.toJSON) {
							const json = value.toJSON();
							// if for some reason value.toJSON returns itself it'll loop forever
							if (json !== value)
								return encode(json)
						}

						// no extension found, write as a plain object
						writeObject(value);
					}
				}
			} else if (type === 'boolean') {
				target[position++] = value ? 0xf5 : 0xf4;
			} else if (type === 'bigint') {
				if (value < (BigInt(1)<<BigInt(64)) && value >= 0) {
					// use an unsigned int as long as it fits
					target[position++] = 0x1b;
					targetView.setBigUint64(position, value);
				} else if (value > -(BigInt(1)<<BigInt(64)) && value < 0) {
					// if we can fit an unsigned int, use that
					target[position++] = 0x3b;
					targetView.setBigUint64(position, -value - BigInt(1));
				} else {
					// overflow
					if (this.largeBigIntToFloat) {
						target[position++] = 0xfb;
						targetView.setFloat64(position, Number(value));
					} else {
						if (value >= BigInt(0))
							target[position++] = 0xc2; // tag 2
						else {
							target[position++] = 0xc3; // tag 2
							value = BigInt(-1) - value;
						}
						let bytes = [];
						while (value) {
							bytes.push(Number(value & BigInt(0xff)));
							value >>= BigInt(8);
						}
						writeBuffer(new Uint8Array(bytes.reverse()), makeRoom);
						return;
					}
				}
				position += 8;
			} else if (type === 'undefined') {
				target[position++] = 0xf7;
			} else {
				throw new Error('Unknown type: ' + type)
			}
		};

		const writeObject = this.useRecords === false ? this.variableMapSize ? (object) => {
			// this method is slightly slower, but generates "preferred serialization" (optimally small for smaller objects)
			let keys = Object.keys(object);
			let vals = Object.values(object);
			let length = keys.length;
			if (length < 0x18) {
				target[position++] = 0xa0 | length;
			} else if (length < 0x100) {
				target[position++] = 0xb8;
				target[position++] = length;
			} else if (length < 0x10000) {
				target[position++] = 0xb9;
				target[position++] = length >> 8;
				target[position++] = length & 0xff;
			} else {
				target[position++] = 0xba;
				targetView.setUint32(position, length);
				position += 4;
			}
			if (encoder.keyMap) { 
				for (let i = 0; i < length; i++) {
					encode(encoder.encodeKey(keys[i]));
					encode(vals[i]);
				}
			} else {
				for (let i = 0; i < length; i++) {
					encode(keys[i]);
					encode(vals[i]);
				}
			}
		} :
		(object) => {
			target[position++] = 0xb9; // always use map 16, so we can preallocate and set the length afterwards
			let objectOffset = position - start;
			position += 2;
			let size = 0;
			if (encoder.keyMap) {
				for (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {
					encode(encoder.encodeKey(key));
					encode(object[key]);
					size++;
				}
			} else { 
				for (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {
						encode(key);
						encode(object[key]);
					size++;
				}
			}
			target[objectOffset++ + start] = size >> 8;
			target[objectOffset + start] = size & 0xff;
		} :
		(object, skipValues) => {
			let nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null));
			let newTransitions = 0;
			let length = 0;
			let parentRecordId;
			let keys;
			if (this.keyMap) {
				keys = Object.keys(object).map(k => this.encodeKey(k));
				length = keys.length;
				for (let i = 0; i < length; i++) {
					let key = keys[i];
					nextTransition = transition[key];
					if (!nextTransition) {
						nextTransition = transition[key] = Object.create(null);
						newTransitions++;
					}
					transition = nextTransition;
				}				
			} else {
				for (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {
					nextTransition = transition[key];
					if (!nextTransition) {
						if (transition[RECORD_SYMBOL] & 0x100000) {// this indicates it is a brancheable/extendable terminal node, so we will use this record id and extend it
							parentRecordId = transition[RECORD_SYMBOL] & 0xffff;
						}
						nextTransition = transition[key] = Object.create(null);
						newTransitions++;
					}
					transition = nextTransition;
					length++;
				}
			}
			let recordId = transition[RECORD_SYMBOL];
			if (recordId !== undefined) {
				recordId &= 0xffff;
				target[position++] = 0xd9;
				target[position++] = (recordId >> 8) | 0xe0;
				target[position++] = recordId & 0xff;
			} else {
				if (!keys)
					keys = transition.__keys__ || (transition.__keys__ = Object.keys(object));
				if (parentRecordId === undefined) {
					recordId = structures.nextId++;
					if (!recordId) {
						recordId = 0;
						structures.nextId = 1;
					}
					if (recordId >= MAX_STRUCTURES) {// cycle back around
						structures.nextId = (recordId = maxSharedStructures) + 1;
					}
				} else {
					recordId = parentRecordId;
				}
				structures[recordId] = keys;
				if (recordId < maxSharedStructures) {
					target[position++] = 0xd9;
					target[position++] = (recordId >> 8) | 0xe0;
					target[position++] = recordId & 0xff;
					transition = structures.transitions;
					for (let i = 0; i < length; i++) {
						if (transition[RECORD_SYMBOL] === undefined || (transition[RECORD_SYMBOL] & 0x100000))
							transition[RECORD_SYMBOL] = recordId;
						transition = transition[keys[i]];
					}
					transition[RECORD_SYMBOL] = recordId | 0x100000; // indicates it is a extendable terminal
					hasSharedUpdate = true;
				} else {
					transition[RECORD_SYMBOL] = recordId;
					targetView.setUint32(position, 0xd9dfff00); // tag two byte, then record definition id
					position += 3;
					if (newTransitions)
						transitionsCount += serializationsSinceTransitionRebuild * newTransitions;
					// record the removal of the id, we can maintain our shared structure
					if (recordIdsToRemove.length >= MAX_STRUCTURES - maxSharedStructures)
						recordIdsToRemove.shift()[RECORD_SYMBOL] = undefined; // we are cycling back through, and have to remove old ones
					recordIdsToRemove.push(transition);
					writeArrayHeader(length + 2);
					encode(0xe000 + recordId);
					encode(keys);
					if (skipValues) return; // special exit for iterator
					for (let key in object)
						if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key))
							encode(object[key]);
					return
				}
			}
			if (length < 0x18) { // write the array header
				target[position++] = 0x80 | length;
			} else {
				writeArrayHeader(length);
			}
			if (skipValues) return; // special exit for iterator
			for (let key in object)
				if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key))
					encode(object[key]);
		};
		const makeRoom = (end) => {
			let newSize;
			if (end > 0x1000000) {
				// special handling for really large buffers
				if ((end - start) > MAX_BUFFER_SIZE)
					throw new Error('Encoded buffer would be larger than maximum buffer size')
				newSize = Math.min(MAX_BUFFER_SIZE,
					Math.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000);
			} else // faster handling for smaller buffers
				newSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12;
			let newBuffer = new ByteArrayAllocate(newSize);
			targetView = new DataView(newBuffer.buffer, 0, newSize);
			if (target.copy)
				target.copy(newBuffer, 0, start, end);
			else
				newBuffer.set(target.slice(start, end));
			position -= start;
			start = 0;
			safeEnd = newBuffer.length - 10;
			return target = newBuffer
		};
		let chunkThreshold = 100;
		let continuedChunkThreshold = 1000;
		this.encodeAsIterable = function(value, options) {
			return startEncoding(value, options, encodeObjectAsIterable);
		};
		this.encodeAsAsyncIterable = function(value, options) {
			return startEncoding(value, options, encodeObjectAsAsyncIterable);
		};

		function* encodeObjectAsIterable(object, iterateProperties, finalIterable) {
			let constructor = object.constructor;
			if (constructor === Object) {
				let useRecords = encoder.useRecords !== false;
				if (useRecords)
					writeObject(object, true); // write the record identifier
				else
					writeEntityLength(Object.keys(object).length, 0xa0);
				for (let key in object) {
					let value = object[key];
					if (!useRecords) encode(key);
					if (value && typeof value === 'object') {
						if (iterateProperties[key])
							yield* encodeObjectAsIterable(value, iterateProperties[key]);
						else
							yield* tryEncode(value, iterateProperties, key);
					} else encode(value);
				}
			} else if (constructor === Array) {
				let length = object.length;
				writeArrayHeader(length);
				for (let i = 0; i < length; i++) {
					let value = object[i];
					if (value && (typeof value === 'object' || position - start > chunkThreshold)) {
						if (iterateProperties.element)
							yield* encodeObjectAsIterable(value, iterateProperties.element);
						else
							yield* tryEncode(value, iterateProperties, 'element');
					} else encode(value);
				}
			} else if (object[Symbol.iterator] && !object.buffer) { // iterator, but exclude typed arrays
				target[position++] = 0x9f; // start indefinite array
				for (let value of object) {
					if (value && (typeof value === 'object' || position - start > chunkThreshold)) {
						if (iterateProperties.element)
							yield* encodeObjectAsIterable(value, iterateProperties.element);
						else
							yield* tryEncode(value, iterateProperties, 'element');
					} else encode(value);
				}
				target[position++] = 0xff; // stop byte
			} else if (isBlob(object)){
				writeEntityLength(object.size, 0x40); // encode as binary data
				yield target.subarray(start, position);
				yield object; // directly return blobs, they have to be encoded asynchronously
				restartEncoding();
			} else if (object[Symbol.asyncIterator]) {
				target[position++] = 0x9f; // start indefinite array
				yield target.subarray(start, position);
				yield object; // directly return async iterators, they have to be encoded asynchronously
				restartEncoding();
				target[position++] = 0xff; // stop byte
			} else {
				encode(object);
			}
			if (finalIterable && position > start) yield target.subarray(start, position);
			else if (position - start > chunkThreshold) {
				yield target.subarray(start, position);
				restartEncoding();
			}
		}
		function* tryEncode(value, iterateProperties, key) {
			let restart = position - start;
			try {
				encode(value);
				if (position - start > chunkThreshold) {
					yield target.subarray(start, position);
					restartEncoding();
				}
			} catch (error) {
				if (error.iteratorNotHandled) {
					iterateProperties[key] = {};
					position = start + restart; // restart our position so we don't have partial data from last encode
					yield* encodeObjectAsIterable.call(this, value, iterateProperties[key]);
				} else throw error;
			}
		}
		function restartEncoding() {
			chunkThreshold = continuedChunkThreshold;
			encoder.encode(null, THROW_ON_ITERABLE); // restart encoding
		}
		function startEncoding(value, options, encodeIterable) {
			if (options && options.chunkThreshold) // explicitly specified chunk sizes
				chunkThreshold = continuedChunkThreshold = options.chunkThreshold;
			else // we start with a smaller threshold to get initial bytes sent quickly
				chunkThreshold = 100;
			if (value && typeof value === 'object') {
				encoder.encode(null, THROW_ON_ITERABLE); // start encoding
				return encodeIterable(value, encoder.iterateProperties || (encoder.iterateProperties = {}), true);
			}
			return [encoder.encode(value)];
		}

		async function* encodeObjectAsAsyncIterable(value, iterateProperties) {
			for (let encodedValue of encodeObjectAsIterable(value, iterateProperties, true)) {
				let constructor = encodedValue.constructor;
				if (constructor === ByteArray || constructor === Uint8Array)
					yield encodedValue;
				else if (isBlob(encodedValue)) {
					let reader = encodedValue.stream().getReader();
					let next;
					while (!(next = await reader.read()).done) {
						yield next.value;
					}
				} else if (encodedValue[Symbol.asyncIterator]) {
					for await (let asyncValue of encodedValue) {
						restartEncoding();
						if (asyncValue)
							yield* encodeObjectAsAsyncIterable(asyncValue, iterateProperties.async || (iterateProperties.async = {}));
						else yield encoder.encode(asyncValue);
					}
				} else {
					yield encodedValue;
				}
			}
		}
	}
	useBuffer(buffer) {
		// this means we are finished using our own buffer and we can write over it safely
		target = buffer;
		targetView = new DataView(target.buffer, target.byteOffset, target.byteLength);
		position = 0;
	}
	clearSharedData() {
		if (this.structures)
			this.structures = [];
		if (this.sharedValues)
			this.sharedValues = undefined;
	}
	updateSharedData() {
		let lastVersion = this.sharedVersion || 0;
		this.sharedVersion = lastVersion + 1;
		let structuresCopy = this.structures.slice(0);
		let sharedData = new SharedData(structuresCopy, this.sharedValues, this.sharedVersion);
		let saveResults = this.saveShared(sharedData,
				existingShared => (existingShared && existingShared.version || 0) == lastVersion);
		if (saveResults === false) {
			// get updated structures and try again if the update failed
			sharedData = this.getShared() || {};
			this.structures = sharedData.structures || [];
			this.sharedValues = sharedData.packedValues;
			this.sharedVersion = sharedData.version;
			this.structures.nextId = this.structures.length;
		} else {
			// restore structures
			structuresCopy.forEach((structure, i) => this.structures[i] = structure);
		}
		// saveShared may fail to write and reload, or may have reloaded to check compatibility and overwrite saved data, either way load the correct shared data
		return saveResults
	}
}
function writeEntityLength(length, majorValue) {
	if (length < 0x18)
		target[position++] = majorValue | length;
	else if (length < 0x100) {
		target[position++] = majorValue | 0x18;
		target[position++] = length;
	} else if (length < 0x10000) {
		target[position++] = majorValue | 0x19;
		target[position++] = length >> 8;
		target[position++] = length & 0xff;
	} else {
		target[position++] = majorValue | 0x1a;
		targetView.setUint32(position, length);
		position += 4;
	}

}
class SharedData {
	constructor(structures, values, version) {
		this.structures = structures;
		this.packedValues = values;
		this.version = version;
	}
}

function writeArrayHeader(length) {
	if (length < 0x18)
		target[position++] = 0x80 | length;
	else if (length < 0x100) {
		target[position++] = 0x98;
		target[position++] = length;
	} else if (length < 0x10000) {
		target[position++] = 0x99;
		target[position++] = length >> 8;
		target[position++] = length & 0xff;
	} else {
		target[position++] = 0x9a;
		targetView.setUint32(position, length);
		position += 4;
	}
}

const BlobConstructor = typeof Blob === 'undefined' ? function(){} : Blob;
function isBlob(object) {
	if (object instanceof BlobConstructor)
		return true;
	let tag = object[Symbol.toStringTag];
	return tag === 'Blob' || tag === 'File';
}
function findRepetitiveStrings(value, packedValues) {
	switch(typeof value) {
		case 'string':
			if (value.length > 3) {
				if (packedValues.objectMap[value] > -1 || packedValues.values.length >= packedValues.maxValues)
					return
				let packedStatus = packedValues.get(value);
				if (packedStatus) {
					if (++packedStatus.count == 2) {
						packedValues.values.push(value);
					}
				} else {
					packedValues.set(value, {
						count: 1,
					});
					if (packedValues.samplingPackedValues) {
						let status = packedValues.samplingPackedValues.get(value);
						if (status)
							status.count++;
						else
							packedValues.samplingPackedValues.set(value, {
								count: 1,
							});
					}
				}
			}
			break
		case 'object':
			if (value) {
				if (value instanceof Array) {
					for (let i = 0, l = value.length; i < l; i++) {
						findRepetitiveStrings(value[i], packedValues);
					}

				} else {
					let includeKeys = !packedValues.encoder.useRecords;
					for (var key in value) {
						if (value.hasOwnProperty(key)) {
							if (includeKeys)
								findRepetitiveStrings(key, packedValues);
							findRepetitiveStrings(value[key], packedValues);
						}
					}
				}
			}
			break
		case 'function': console.log(value);
	}
}
const isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
extensionClasses = [ Date, Set, Error, RegExp, Tag, ArrayBuffer,
	Uint8Array, Uint8ClampedArray, Uint16Array, Uint32Array,
	typeof BigUint64Array == 'undefined' ? function() {} : BigUint64Array, Int8Array, Int16Array, Int32Array,
	typeof BigInt64Array == 'undefined' ? function() {} : BigInt64Array,
	Float32Array, Float64Array, SharedData ];

//Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/
extensions = [{ // Date
	tag: 1,
	encode(date, encode) {
		let seconds = date.getTime() / 1000;
		if ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {
			// Timestamp 32
			target[position++] = 0x1a;
			targetView.setUint32(position, seconds);
			position += 4;
		} else {
			// Timestamp float64
			target[position++] = 0xfb;
			targetView.setFloat64(position, seconds);
			position += 8;
		}
	}
}, { // Set
	tag: 258, // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md
	encode(set, encode) {
		let array = Array.from(set);
		encode(array);
	}
}, { // Error
	tag: 27, // http://cbor.schmorp.de/generic-object
	encode(error, encode) {
		encode([ error.name, error.message ]);
	}
}, { // RegExp
	tag: 27, // http://cbor.schmorp.de/generic-object
	encode(regex, encode) {
		encode([ 'RegExp', regex.source, regex.flags ]);
	}
}, { // Tag
	getTag(tag) {
		return tag.tag
	},
	encode(tag, encode) {
		encode(tag.value);
	}
}, { // ArrayBuffer
	encode(arrayBuffer, encode, makeRoom) {
		writeBuffer(arrayBuffer, makeRoom);
	}
}, { // Uint8Array
	getTag(typedArray) {
		if (typedArray.constructor === Uint8Array) {
			if (this.tagUint8Array || hasNodeBuffer && this.tagUint8Array !== false)
				return 64;
		} // else no tag
	},
	encode(typedArray, encode, makeRoom) {
		writeBuffer(typedArray, makeRoom);
	}
},
	typedArrayEncoder(68, 1),
	typedArrayEncoder(69, 2),
	typedArrayEncoder(70, 4),
	typedArrayEncoder(71, 8),
	typedArrayEncoder(72, 1),
	typedArrayEncoder(77, 2),
	typedArrayEncoder(78, 4),
	typedArrayEncoder(79, 8),
	typedArrayEncoder(85, 4),
	typedArrayEncoder(86, 8),
{
	encode(sharedData, encode) { // write SharedData
		let packedValues = sharedData.packedValues || [];
		let sharedStructures = sharedData.structures || [];
		if (packedValues.values.length > 0) {
			target[position++] = 0xd8; // one-byte tag
			target[position++] = 51; // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt
			writeArrayHeader(4);
			let valuesArray = packedValues.values;
			encode(valuesArray);
			writeArrayHeader(0); // prefixes
			writeArrayHeader(0); // suffixes
			packedObjectMap = Object.create(sharedPackedObjectMap || null);
			for (let i = 0, l = valuesArray.length; i < l; i++) {
				packedObjectMap[valuesArray[i]] = i;
			}
		}
		{
			targetView.setUint32(position, 0xd9dffe00);
			position += 3;
			let definitions = sharedStructures.slice(0);
			definitions.unshift(0xe000);
			definitions.push(new Tag(sharedData.version, 0x53687264));
			encode(definitions);
		}
		}
	}];
function typedArrayEncoder(tag, size) {
	if (!isLittleEndianMachine && size > 1)
		tag -= 4; // the big endian equivalents are 4 less
	return {
		tag: tag,
		encode: function writeExtBuffer(typedArray, encode) {
			let length = typedArray.byteLength;
			let offset = typedArray.byteOffset || 0;
			let buffer = typedArray.buffer || typedArray;
			encode(hasNodeBuffer ? Buffer$1.from(buffer, offset, length) :
				new Uint8Array(buffer, offset, length));
		}
	}
}
function writeBuffer(buffer, makeRoom) {
	let length = buffer.byteLength;
	if (length < 0x18) {
		target[position++] = 0x40 + length;
	} else if (length < 0x100) {
		target[position++] = 0x58;
		target[position++] = length;
	} else if (length < 0x10000) {
		target[position++] = 0x59;
		target[position++] = length >> 8;
		target[position++] = length & 0xff;
	} else {
		target[position++] = 0x5a;
		targetView.setUint32(position, length);
		position += 4;
	}
	if (position + length >= target.length) {
		makeRoom(position + length);
	}
	// if it is already a typed array (has an ArrayBuffer), use that, but if it is an ArrayBuffer itself,
	// must wrap it to set it.
	target.set(buffer.buffer ? buffer : new Uint8Array(buffer), position);
	position += length;
}

function insertIds(serialized, idsToInsert) {
	// insert the ids that need to be referenced for structured clones
	let nextId;
	let distanceToMove = idsToInsert.length * 2;
	let lastEnd = serialized.length - distanceToMove;
	idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);
	for (let id = 0; id < idsToInsert.length; id++) {
		let referee = idsToInsert[id];
		referee.id = id;
		for (let position of referee.references) {
			serialized[position++] = id >> 8;
			serialized[position] = id & 0xff;
		}
	}
	while (nextId = idsToInsert.pop()) {
		let offset = nextId.offset;
		serialized.copyWithin(offset + distanceToMove, offset, lastEnd);
		distanceToMove -= 2;
		let position = offset + distanceToMove;
		serialized[position++] = 0xd8;
		serialized[position++] = 28; // http://cbor.schmorp.de/value-sharing
		lastEnd = offset;
	}
	return serialized
}
function writeBundles(start, encode) {
	targetView.setUint32(bundledStrings.position + start, position - bundledStrings.position - start + 1); // the offset to bundle
	let writeStrings = bundledStrings;
	bundledStrings = null;
	encode(writeStrings[0]);
	encode(writeStrings[1]);
}
let defaultEncoder = new Encoder({ useRecords: false });
defaultEncoder.encode;
defaultEncoder.encodeAsIterable;
defaultEncoder.encodeAsAsyncIterable;
const REUSE_BUFFER_MODE = 512;
const RESET_BUFFER_MODE = 1024;
const THROW_ON_ITERABLE = 2048;

function encode(obj) {
    const encoder = new Encoder({ tagUint8Array: false, useRecords: false });
    return encoder.encode(obj);
}
function decode(buf) {
    return decode$1(buf);
}

const arraysAreEqual = (a, b) => a.length === b.length && a.every((element, index) => element === b[index]);

const headsAreSame = (a, b) => {
    return arraysAreEqual(a, b);
};

/* c8 ignore start */
/**
 * If `promise` is resolved before `t` ms elapse, the timeout is cleared and the result of the
 * promise is returned. If the timeout ends first, a `TimeoutError` is thrown.
 */
const withTimeout = async (promise, t) => {
    let timeoutId;
    const timeoutPromise = new Promise((_, reject) => {
        timeoutId = setTimeout(() => reject(new TimeoutError(`withTimeout: timed out after ${t}ms`)), t);
    });
    try {
        return await Promise.race([promise, timeoutPromise]);
    }
    finally {
        clearTimeout(timeoutId);
    }
};
class TimeoutError extends Error {
    constructor(message) {
        super(message);
        this.name = "TimeoutError";
    }
}
/* c8 ignore end */

/**
 * A DocHandle is a wrapper around a single Automerge document that lets us listen for changes and
 * notify the network and storage of new changes.
 *
 * @remarks
 * A `DocHandle` represents a document which is being managed by a {@link Repo}. You shouldn't ever
 * instantiate this yourself. To obtain `DocHandle` use {@link Repo.find} or {@link Repo.create}.
 *
 * To modify the underlying document use either {@link DocHandle.change} or
 * {@link DocHandle.changeAt}. These methods will notify the `Repo` that some change has occured and
 * the `Repo` will save any new changes to the attached {@link StorageAdapter} and send sync
 * messages to connected peers.
 */
class DocHandle extends EventEmitter$1 {
    documentId;
    #log;
    /** The XState actor running our state machine.  */
    #machine;
    /** The last known state of our document. */
    #prevDocState;
    /** How long to wait before giving up on a document. (Note that a document will be marked
     * unavailable much sooner if all known peers respond that they don't have it.) */
    #timeoutDelay = 60_000;
    /** A dictionary mapping each peer to the last heads we know they have. */
    #remoteHeads = {};
    /** @hidden */
    constructor(documentId, options = {}) {
        super();
        this.documentId = documentId;
        if ("timeoutDelay" in options && options.timeoutDelay) {
            this.#timeoutDelay = options.timeoutDelay;
        }
        let doc;
        const isNew = "isNew" in options && options.isNew;
        if (isNew) {
            // T should really be constrained to extend `Record<string, unknown>` (an automerge doc can't be
            // e.g. a primitive, an array, etc. - it must be an object). But adding that constraint creates
            // a bunch of other problems elsewhere so for now we'll just cast it here to make Automerge happy.
            doc = from(options.initialValue);
            doc = emptyChange(doc);
        }
        else {
            doc = init();
        }
        this.#log = debug(`automerge-repo:dochandle:${this.documentId.slice(0, 5)}`);
        const delay = this.#timeoutDelay;
        const machine = setup({
            types: {
                context: {},
                events: {},
            },
            actions: {
                /** Update the doc using the given callback and put the modified doc in context */
                onUpdate: assign(({ context, event }) => {
                    const oldDoc = context.doc;
                    assertEvent(event, UPDATE);
                    const { callback } = event.payload;
                    const doc = callback(oldDoc);
                    return { doc };
                }),
                onDelete: assign(() => {
                    this.emit("delete", { handle: this });
                    return { doc: undefined };
                }),
                onUnavailable: () => {
                    this.emit("unavailable", { handle: this });
                },
            },
        }).createMachine({
            /** @xstate-layout N4IgpgJg5mDOIC5QAoC2BDAxgCwJYDswBKAYgFUAFAEQEEAVAUQG0AGAXUVAAcB7WXAC64e+TiAAeiAOwAOAKwA6ACxSAzKqks1ATjlTdAGhABPRAFolAJksKN2y1KtKAbFLla5AX09G0WPISkVAwAMgyMrBxIILz8QiJikggAjCzOijKqLEqqybJyLizaRqYIFpbJtro5Uo7J2o5S3r4YOATECrgQADZgJADCAEoM9MzsYrGCwqLRSeoyCtra8pa5adquySXmDjY5ac7JljLJeepKzSB+bYGdPX0AYgCSAHJUkRN8UwmziM7HCgqyVcUnqcmScmcMm2ZV2yiyzkOx1OalUFx8V1aAQ63R46AgBCgJGGAEUyAwAMp0D7RSbxGagJKHFgKOSWJTJGRSCosCpKaEmRCqbQKU5yXINeTaer6LwY67YogKXH4wkkKgAeX6AH1hjQqABNGncL70xKIJQ5RY5BHOJag6wwpRyEWImQVeT1aWrVSXBXtJUqgn4Ik0ADqNCedG1L3CYY1gwA0saYqbpuaEG4pKLksKpFDgcsCjDhTnxTKpTLdH6sQGFOgAO7oKYhl5gAQNngAJwA1iRY3R40ndSNDSm6enfpm5BkWAVkvy7bpuTCKq7ndZnfVeSwuTX-HWu2AAI4AVzgQhD6q12rILxoADVIyEaAAhMLjtM-RmIE4LVSQi4nLLDIGzOCWwLKA0cgyLBoFWNy+43B0R5nheaqajqepjuMtJfgyEh-FoixqMCoKqOyhzgYKCDOq6UIeuCSxHOoSGKgop74OgABuzbdOgABGvTXlho5GrhJpxJOP4pLulT6KoMhpJY2hzsWNF0QobqMV6LG+pc+A8BAcBiP6gSfFJ36EQgKksksKxrHamwwmY7gLKB85QjBzoAWxdZdL0FnfARST8ooLC7qoTnWBU4pyC5ViVMKBQaHUDQuM4fm3EGhJBWaU7-CysEAUp3LpEpWw0WYRw2LmqzgqciIsCxWUdI2zaXlAbYdt2PZ5dJ1n5jY2iJY1ikOIcMJHCyUWHC62hRZkUVNPKta3Kh56wJ1-VWUyzhFc64JWJCtQNBBzhQW4cHwbsrVKpxPF8YJgV4ZZIWIKkiKiiNSkqZYWjzCWaQ5hFh0AcCuR3QoR74qUknBRmzholpv3OkpRQNNRpTzaKTWKbIWR5FDxm9AIkA7e9skUYCWayLILBZGoLkUSKbIyIdpxHPoyTeN4QA */
            // You can use the XState extension for VS Code to visualize this machine.
            // Or, you can see this static visualization (last updated April 2024): https://stately.ai/registry/editor/d7af9b58-c518-44f1-9c36-92a238b04a7a?machineId=91c387e7-0f01-42c9-a21d-293e9bf95bb7
            initial: "idle",
            context: { documentId, doc },
            on: {
                UPDATE: { actions: "onUpdate" },
                DELETE: ".deleted",
            },
            states: {
                idle: {
                    on: {
                        CREATE: "ready",
                        FIND: "loading",
                    },
                },
                loading: {
                    on: {
                        REQUEST: "requesting",
                        DOC_READY: "ready",
                        AWAIT_NETWORK: "awaitingNetwork",
                    },
                    after: { [delay]: "unavailable" },
                },
                awaitingNetwork: {
                    on: { NETWORK_READY: "requesting" },
                },
                requesting: {
                    on: {
                        DOC_UNAVAILABLE: "unavailable",
                        DOC_READY: "ready",
                    },
                    after: { [delay]: "unavailable" },
                },
                unavailable: {
                    entry: "onUnavailable",
                    on: { DOC_READY: "ready" },
                },
                ready: {},
                deleted: { entry: "onDelete", type: "final" },
            },
        });
        // Instantiate the state machine
        this.#machine = createActor(machine);
        // Listen for state transitions
        this.#machine.subscribe(state => {
            const before = this.#prevDocState;
            const after = state.context.doc;
            this.#log(` ${state.value} %o`, after);
            // if the document has changed, emit a change event
            this.#checkForChanges(before, after);
        });
        // Start the machine, and send a create or find event to get things going
        this.#machine.start();
        this.#machine.send(isNew ? { type: CREATE } : { type: FIND });
    }
    // PRIVATE
    /** Returns the current document, regardless of state */
    get #doc() {
        return this.#machine?.getSnapshot().context.doc;
    }
    /** Returns the docHandle's state (READY, etc.) */
    get #state() {
        return this.#machine?.getSnapshot().value;
    }
    /** Returns a promise that resolves when the docHandle is in one of the given states */
    #statePromise(awaitStates) {
        const awaitStatesArray = Array.isArray(awaitStates)
            ? awaitStates
            : [awaitStates];
        return waitFor(this.#machine, s => awaitStatesArray.some(state => s.matches(state)), 
        // use a longer delay here so as not to race with other delays
        { timeout: this.#timeoutDelay * 2 });
    }
    /**
     * Called after state transitions. If the document has changed, emits a change event. If we just
     * received the document for the first time, signal that our request has been completed.
     */
    #checkForChanges(before, after) {
        const docChanged = after && before && !headsAreSame(getHeads(after), getHeads(before));
        if (docChanged) {
            this.emit("heads-changed", { handle: this, doc: after });
            const patches = diff(after, getHeads(before), getHeads(after));
            if (patches.length > 0) {
                this.emit("change", {
                    handle: this,
                    doc: after,
                    patches,
                    // TODO: pass along the source (load/change/network)
                    patchInfo: { before, after, source: "change" },
                });
            }
            // If we didn't have the document yet, signal that we now do
            if (!this.isReady())
                this.#machine.send({ type: DOC_READY });
        }
        this.#prevDocState = after;
    }
    // PUBLIC
    /** Our documentId in Automerge URL form.
     */
    get url() {
        return stringifyAutomergeUrl({ documentId: this.documentId });
    }
    /**
     * @returns true if the document is ready for accessing or changes.
     *
     * Note that for documents already stored locally this occurs before synchronization with any
     * peers. We do not currently have an equivalent `whenSynced()`.
     */
    isReady = () => this.inState(["ready"]);
    /**
     * @returns true if the document has been marked as deleted.
     *
     * Deleted documents are removed from local storage and the sync process. It's not currently
     * possible at runtime to undelete a document.
     */
    isDeleted = () => this.inState(["deleted"]);
    /**
     * @returns true if the document is currently unavailable.
     *
     * This will be the case if the document is not found in storage and no peers have shared it with us.
     */
    isUnavailable = () => this.inState(["unavailable"]);
    /**
     * @returns true if the handle is in one of the given states.
     */
    inState = (states) => states.some(s => this.#machine.getSnapshot().matches(s));
    /** @hidden */
    get state() {
        return this.#machine.getSnapshot().value;
    }
    /**
     * @returns a promise that resolves when the document is in one of the given states (if no states
     * are passed, when the document is ready)
     *
     * Use this to block until the document handle has finished loading. The async equivalent to
     * checking `inState()`.
     */
    async whenReady(awaitStates = ["ready"]) {
        await withTimeout(this.#statePromise(awaitStates), this.#timeoutDelay);
    }
    /**
     * @returns the current state of this handle's Automerge document.
     *
     * This is the recommended way to access a handle's document. Note that this waits for the handle
     * to be ready if necessary. If loading (or synchronization) fails, this will never resolve.
     */
    async doc(
    /** states to wait for, such as "LOADING". mostly for internal use. */
    awaitStates = ["ready", "unavailable"]) {
        try {
            // wait for the document to enter one of the desired states
            await this.#statePromise(awaitStates);
        }
        catch (error) {
            // if we timed out, return undefined
            return undefined;
        }
        // Return the document
        return !this.isUnavailable() ? this.#doc : undefined;
    }
    /**
     * Synchronously returns the current state of the Automerge document this handle manages, or
     * undefined. Consider using `await handle.doc()` instead. Check `isReady()`, or use `whenReady()`
     * if you want to make sure loading is complete first.
     *
     * Not to be confused with the SyncState of the document, which describes the state of the
     * synchronization process.
     *
     * Note that `undefined` is not a valid Automerge document, so the return from this function is
     * unambigous.
     *
     * @returns the current document, or undefined if the document is not ready.
     */
    docSync() {
        if (!this.isReady())
            return undefined;
        else
            return this.#doc;
    }
    /**
     * Returns the current "heads" of the document, akin to a git commit.
     * This precisely defines the state of a document.
     * @returns the current document's heads, or undefined if the document is not ready
     */
    heads() {
        if (!this.isReady()) {
            return undefined;
        }
        return getHeads(this.#doc);
    }
    /**
     * `update` is called by the repo when we receive changes from the network
     * Called by the repo when we receive changes from the network.
     * @hidden
     */
    update(callback) {
        this.#machine.send({ type: UPDATE, payload: { callback } });
    }
    /**
     * Called by the repo either when a doc handle changes or we receive new remote heads.
     * @hidden
     */
    setRemoteHeads(storageId, heads) {
        this.#remoteHeads[storageId] = heads;
        this.emit("remote-heads", { storageId, heads });
    }
    /** Returns the heads of the storageId. */
    getRemoteHeads(storageId) {
        return this.#remoteHeads[storageId];
    }
    /**
     * All changes to an Automerge document should be made through this method.
     * Inside the callback, the document should be treated as mutable: all edits will be recorded
     * using a Proxy and translated into operations as part of a single recorded "change".
     *
     * Note that assignment via ES6 spread operators will result in *replacing* the object
     * instead of mutating it which will prevent clean merges. This may be what you want, but
     * `doc.foo = { ...doc.foo, bar: "baz" }` is not equivalent to `doc.foo.bar = "baz"`.
     *
     * Local changes will be stored (by the StorageSubsystem) and synchronized (by the
     * DocSynchronizer) to any peers you are sharing it with.
     *
     * @param callback - A function that takes the current document and mutates it.
     *
     */
    change(callback, options = {}) {
        if (!this.isReady()) {
            throw new Error(`DocHandle#${this.documentId} is not ready. Check \`handle.isReady()\` before accessing the document.`);
        }
        this.#machine.send({
            type: UPDATE,
            payload: { callback: doc => change(doc, options, callback) },
        });
    }
    /**
     * Makes a change as if the document were at `heads`.
     *
     * @returns A set of heads representing the concurrent change that was made.
     */
    changeAt(heads, callback, options = {}) {
        if (!this.isReady()) {
            throw new Error(`DocHandle#${this.documentId} is not ready. Check \`handle.isReady()\` before accessing the document.`);
        }
        let resultHeads = undefined;
        this.#machine.send({
            type: UPDATE,
            payload: {
                callback: doc => {
                    const result = changeAt(doc, heads, options, callback);
                    resultHeads = result.newHeads || undefined;
                    return result.newDoc;
                },
            },
        });
        // the callback above will always run before we get here, so this should always contain the new heads
        return resultHeads;
    }
    /**
     * Merges another document into this document. Any peers we are sharing changes with will be
     * notified of the changes resulting from the merge.
     *
     * @returns the merged document.
     *
     * @throws if either document is not ready or if `otherHandle` is unavailable.
     */
    merge(
    /** the handle of the document to merge into this one */
    otherHandle) {
        if (!this.isReady() || !otherHandle.isReady()) {
            throw new Error("Both handles must be ready to merge");
        }
        const mergingDoc = otherHandle.docSync();
        if (!mergingDoc) {
            throw new Error("The document to be merged in is falsy, aborting.");
        }
        this.update(doc => {
            return merge(doc, mergingDoc);
        });
    }
    /**
     * Used in testing to mark this document as unavailable.
     * @hidden
     */
    unavailable() {
        this.#machine.send({ type: DOC_UNAVAILABLE });
    }
    /** Called by the repo when the document is not found in storage.
     * @hidden
     * */
    request() {
        if (this.#state === "loading")
            this.#machine.send({ type: REQUEST });
    }
    /** @hidden */
    awaitNetwork() {
        if (this.#state === "loading")
            this.#machine.send({ type: AWAIT_NETWORK });
    }
    /** @hidden */
    networkReady() {
        if (this.#state === "awaitingNetwork")
            this.#machine.send({ type: NETWORK_READY });
    }
    /** Called by the repo when the document is deleted. */
    delete() {
        this.#machine.send({ type: DELETE });
    }
    /**
     * Sends an arbitrary ephemeral message out to all reachable peers who would receive sync messages
     * from you. It has no guarantee of delivery, and is not persisted to the underlying automerge doc
     * in any way. Messages will have a sending PeerId but this is *not* a useful user identifier (a
     * user could have multiple tabs open and would appear as multiple PeerIds). Every message source
     * must have a unique PeerId.
     */
    broadcast(message) {
        this.emit("ephemeral-message-outbound", {
            handle: this,
            data: encode(message),
        });
    }
}
// STATE MACHINE TYPES & CONSTANTS
// state
/**
 * Possible internal states for a DocHandle
 */
const HandleState = {
    /** The handle has been created but not yet loaded or requested */
    IDLE: "idle",
    /** We are waiting for storage to finish loading */
    LOADING: "loading",
    /** We are waiting for the network to be come ready */
    AWAITING_NETWORK: "awaitingNetwork",
    /** We are waiting for someone in the network to respond to a sync request */
    REQUESTING: "requesting",
    /** The document is available */
    READY: "ready",
    /** The document has been deleted from the repo */
    DELETED: "deleted",
    /** The document was not available in storage or from any connected peers */
    UNAVAILABLE: "unavailable",
};
const { IDLE, LOADING, AWAITING_NETWORK, REQUESTING, READY, DELETED, UNAVAILABLE, } = HandleState;
const CREATE = "CREATE";
const FIND = "FIND";
const REQUEST = "REQUEST";
const DOC_READY = "DOC_READY";
const AWAIT_NETWORK = "AWAIT_NETWORK";
const NETWORK_READY = "NETWORK_READY";
const UPDATE = "UPDATE";
const DELETE = "DELETE";
const DOC_UNAVAILABLE = "DOC_UNAVAILABLE";

class RemoteHeadsSubscriptions extends EventEmitter$1 {
    // Storage IDs we have received remote heads from
    #knownHeads = new Map();
    // Storage IDs we have subscribed to via Repo.subscribeToRemoteHeads
    #ourSubscriptions = new Set();
    // Storage IDs other peers have subscribed to by sending us a control message
    #theirSubscriptions = new Map();
    // Peers we will always share remote heads with even if they are not subscribed
    #generousPeers = new Set();
    // Documents each peer has open, we need this information so we only send remote heads of documents that the peer knows
    #subscribedDocsByPeer = new Map();
    #log = debug("automerge-repo:remote-heads-subscriptions");
    subscribeToRemotes(remotes) {
        this.#log("subscribeToRemotes", remotes);
        const remotesToAdd = [];
        for (const remote of remotes) {
            if (!this.#ourSubscriptions.has(remote)) {
                this.#ourSubscriptions.add(remote);
                remotesToAdd.push(remote);
            }
        }
        if (remotesToAdd.length > 0) {
            this.emit("change-remote-subs", {
                add: remotesToAdd,
                peers: Array.from(this.#generousPeers),
            });
        }
    }
    unsubscribeFromRemotes(remotes) {
        this.#log("subscribeToRemotes", remotes);
        const remotesToRemove = [];
        for (const remote of remotes) {
            if (this.#ourSubscriptions.has(remote)) {
                this.#ourSubscriptions.delete(remote);
                if (!this.#theirSubscriptions.has(remote)) {
                    remotesToRemove.push(remote);
                }
            }
        }
        if (remotesToRemove.length > 0) {
            this.emit("change-remote-subs", {
                remove: remotesToRemove,
                peers: Array.from(this.#generousPeers),
            });
        }
    }
    handleControlMessage(control) {
        const remotesToAdd = [];
        const remotesToRemove = [];
        const addedRemotesWeKnow = [];
        this.#log("handleControlMessage", control);
        if (control.add) {
            for (const remote of control.add) {
                let theirSubs = this.#theirSubscriptions.get(remote);
                if (this.#ourSubscriptions.has(remote) || theirSubs) {
                    addedRemotesWeKnow.push(remote);
                }
                if (!theirSubs) {
                    theirSubs = new Set();
                    this.#theirSubscriptions.set(remote, theirSubs);
                    if (!this.#ourSubscriptions.has(remote)) {
                        remotesToAdd.push(remote);
                    }
                }
                theirSubs.add(control.senderId);
            }
        }
        if (control.remove) {
            for (const remote of control.remove) {
                const theirSubs = this.#theirSubscriptions.get(remote);
                if (theirSubs) {
                    theirSubs.delete(control.senderId);
                    // if no one is subscribed anymore remove remote
                    if (theirSubs.size == 0 && !this.#ourSubscriptions.has(remote)) {
                        remotesToRemove.push(remote);
                    }
                }
            }
        }
        if (remotesToAdd.length > 0 || remotesToRemove.length > 0) {
            this.emit("change-remote-subs", {
                peers: Array.from(this.#generousPeers),
                add: remotesToAdd,
                remove: remotesToRemove,
            });
        }
        // send all our stored heads of documents the peer knows for the remotes they've added
        for (const remote of addedRemotesWeKnow) {
            const subscribedDocs = this.#subscribedDocsByPeer.get(control.senderId);
            if (subscribedDocs) {
                for (const documentId of subscribedDocs) {
                    const knownHeads = this.#knownHeads.get(documentId);
                    if (!knownHeads) {
                        continue;
                    }
                    const lastHeads = knownHeads.get(remote);
                    if (lastHeads) {
                        this.emit("notify-remote-heads", {
                            targetId: control.senderId,
                            documentId,
                            heads: lastHeads.heads,
                            timestamp: lastHeads.timestamp,
                            storageId: remote,
                        });
                    }
                }
            }
        }
    }
    /** A peer we are not directly connected to has changed their heads */
    handleRemoteHeads(msg) {
        this.#log("handleRemoteHeads", msg);
        const changedHeads = this.#changedHeads(msg);
        // Emit a remote-heads-changed event to update local dochandles
        for (const event of changedHeads) {
            if (this.#ourSubscriptions.has(event.storageId)) {
                this.emit("remote-heads-changed", event);
            }
        }
        // Notify generous peers of these changes regardless of if they are subscribed to us
        for (const event of changedHeads) {
            for (const peer of this.#generousPeers) {
                // don't emit event to sender if sender is a generous peer
                if (peer === msg.senderId) {
                    continue;
                }
                this.emit("notify-remote-heads", {
                    targetId: peer,
                    documentId: event.documentId,
                    heads: event.remoteHeads,
                    timestamp: event.timestamp,
                    storageId: event.storageId,
                });
            }
        }
        // Notify subscribers of these changes
        for (const event of changedHeads) {
            const theirSubs = this.#theirSubscriptions.get(event.storageId);
            if (theirSubs) {
                for (const peerId of theirSubs) {
                    if (this.#isPeerSubscribedToDoc(peerId, event.documentId)) {
                        this.emit("notify-remote-heads", {
                            targetId: peerId,
                            documentId: event.documentId,
                            heads: event.remoteHeads,
                            timestamp: event.timestamp,
                            storageId: event.storageId,
                        });
                    }
                }
            }
        }
    }
    /** A peer we are directly connected to has updated their heads */
    handleImmediateRemoteHeadsChanged(documentId, storageId, heads) {
        this.#log("handleLocalHeadsChanged", documentId, storageId, heads);
        const remote = this.#knownHeads.get(documentId);
        const timestamp = Date.now();
        if (!remote) {
            this.#knownHeads.set(documentId, new Map([[storageId, { heads, timestamp }]]));
        }
        else {
            const docRemote = remote.get(storageId);
            if (!docRemote || docRemote.timestamp < Date.now()) {
                remote.set(storageId, { heads, timestamp: Date.now() });
            }
        }
        const theirSubs = this.#theirSubscriptions.get(storageId);
        if (theirSubs) {
            for (const peerId of theirSubs) {
                if (this.#isPeerSubscribedToDoc(peerId, documentId)) {
                    this.emit("notify-remote-heads", {
                        targetId: peerId,
                        documentId: documentId,
                        heads: heads,
                        timestamp: timestamp,
                        storageId: storageId,
                    });
                }
            }
        }
    }
    addGenerousPeer(peerId) {
        this.#log("addGenerousPeer", peerId);
        this.#generousPeers.add(peerId);
        if (this.#ourSubscriptions.size > 0) {
            this.emit("change-remote-subs", {
                add: Array.from(this.#ourSubscriptions),
                peers: [peerId],
            });
        }
        for (const [documentId, remote] of this.#knownHeads) {
            for (const [storageId, { heads, timestamp }] of remote) {
                this.emit("notify-remote-heads", {
                    targetId: peerId,
                    documentId: documentId,
                    heads: heads,
                    timestamp: timestamp,
                    storageId: storageId,
                });
            }
        }
    }
    removePeer(peerId) {
        this.#log("removePeer", peerId);
        const remotesToRemove = [];
        this.#generousPeers.delete(peerId);
        this.#subscribedDocsByPeer.delete(peerId);
        for (const [storageId, peerIds] of this.#theirSubscriptions) {
            if (peerIds.has(peerId)) {
                peerIds.delete(peerId);
                if (peerIds.size == 0) {
                    remotesToRemove.push(storageId);
                    this.#theirSubscriptions.delete(storageId);
                }
            }
        }
        if (remotesToRemove.length > 0) {
            this.emit("change-remote-subs", {
                remove: remotesToRemove,
                peers: Array.from(this.#generousPeers),
            });
        }
    }
    subscribePeerToDoc(peerId, documentId) {
        let subscribedDocs = this.#subscribedDocsByPeer.get(peerId);
        if (!subscribedDocs) {
            subscribedDocs = new Set();
            this.#subscribedDocsByPeer.set(peerId, subscribedDocs);
        }
        subscribedDocs.add(documentId);
        const remoteHeads = this.#knownHeads.get(documentId);
        if (remoteHeads) {
            for (const [storageId, lastHeads] of remoteHeads) {
                const subscribedPeers = this.#theirSubscriptions.get(storageId);
                if (subscribedPeers && subscribedPeers.has(peerId)) {
                    this.emit("notify-remote-heads", {
                        targetId: peerId,
                        documentId,
                        heads: lastHeads.heads,
                        timestamp: lastHeads.timestamp,
                        storageId,
                    });
                }
            }
        }
    }
    #isPeerSubscribedToDoc(peerId, documentId) {
        const subscribedDocs = this.#subscribedDocsByPeer.get(peerId);
        return subscribedDocs && subscribedDocs.has(documentId);
    }
    /** Returns the (document, storageId) pairs which have changed after processing msg */
    #changedHeads(msg) {
        const changedHeads = [];
        const { documentId, newHeads } = msg;
        for (const [storageId, { heads, timestamp }] of Object.entries(newHeads)) {
            if (!this.#ourSubscriptions.has(storageId) &&
                !this.#theirSubscriptions.has(storageId)) {
                continue;
            }
            let remote = this.#knownHeads.get(documentId);
            if (!remote) {
                remote = new Map();
                this.#knownHeads.set(documentId, remote);
            }
            const docRemote = remote.get(storageId);
            if (docRemote && docRemote.timestamp >= timestamp) {
                continue;
            }
            else {
                remote.set(storageId, { timestamp, heads });
                changedHeads.push({
                    documentId,
                    storageId: storageId,
                    remoteHeads: heads,
                    timestamp,
                });
            }
        }
        return changedHeads;
    }
}

/** Throttle
 * Returns a function with a built in throttle timer that runs after `delay` ms.
 *
 * This function differs from a conventional `throttle` in that it ensures the final
 * call will also execute and delays sending the first one until `delay` ms to allow
 * additional work to accumulate.
 *
 * Here's a diagram:
 *
 * calls +----++++++-----++----
 * dlay  ^--v ^--v^--v   ^--v
 * execs ---+----+---+------+--
 *
 * The goal in this design is to create batches of changes without flooding
 * communication or storage systems while still feeling responsive.
 * (By default we communicate at 10hz / every 100ms.)
 *
 * Note that the args go inside the parameter and you should be careful not to
 * recreate the function on each usage. (In React, see useMemo().)
 *
 *
 * Example usage:
 * const callback = debounce((ev) => { doSomethingExpensiveOrOccasional() }, 100)
 * target.addEventListener('frequent-event', callback);
 *
 */
const throttle = (fn, delay) => {
    let lastCall = Date.now();
    let wait;
    let timeout;
    return function (...args) {
        wait = lastCall + delay - Date.now();
        clearTimeout(timeout);
        timeout = setTimeout(() => {
            fn(...args);
            lastCall = Date.now();
        }, wait);
    };
};

// TYPE GUARDS
const isRepoMessage = (message) => isSyncMessage(message) ||
    isEphemeralMessage(message) ||
    isRequestMessage(message) ||
    isDocumentUnavailableMessage(message) ||
    isRemoteSubscriptionControlMessage(message) ||
    isRemoteHeadsChanged(message);
// prettier-ignore
const isDocumentUnavailableMessage = (msg) => msg.type === "doc-unavailable";
const isRequestMessage = (msg) => msg.type === "request";
const isSyncMessage = (msg) => msg.type === "sync";
const isEphemeralMessage = (msg) => msg.type === "ephemeral";
// prettier-ignore
const isRemoteSubscriptionControlMessage = (msg) => msg.type === "remote-subscription-change";
const isRemoteHeadsChanged = (msg) => msg.type === "remote-heads-changed";

const getEphemeralMessageSource = (message) => `${message.senderId}:${message.sessionId}`;
class NetworkSubsystem extends EventEmitter$1 {
    peerId;
    peerMetadata;
    #log;
    #adaptersByPeer = {};
    #count = 0;
    #sessionId = Math.random().toString(36).slice(2);
    #ephemeralSessionCounts = {};
    #readyAdapterCount = 0;
    #adapters = [];
    constructor(adapters, peerId = randomPeerId(), peerMetadata) {
        super();
        this.peerId = peerId;
        this.peerMetadata = peerMetadata;
        this.#log = debug(`automerge-repo:network:${this.peerId}`);
        adapters.forEach(a => this.addNetworkAdapter(a));
    }
    addNetworkAdapter(networkAdapter) {
        this.#adapters.push(networkAdapter);
        networkAdapter.once("ready", () => {
            this.#readyAdapterCount++;
            this.#log("Adapters ready: ", this.#readyAdapterCount, "/", this.#adapters.length);
            if (this.#readyAdapterCount === this.#adapters.length) {
                this.emit("ready");
            }
        });
        networkAdapter.on("peer-candidate", ({ peerId, peerMetadata }) => {
            this.#log(`peer candidate: ${peerId} `);
            // TODO: This is where authentication would happen
            if (!this.#adaptersByPeer[peerId]) {
                // TODO: handle losing a server here
                this.#adaptersByPeer[peerId] = networkAdapter;
            }
            this.emit("peer", { peerId, peerMetadata });
        });
        networkAdapter.on("peer-disconnected", ({ peerId }) => {
            this.#log(`peer disconnected: ${peerId} `);
            delete this.#adaptersByPeer[peerId];
            this.emit("peer-disconnected", { peerId });
        });
        networkAdapter.on("message", msg => {
            if (!isRepoMessage(msg)) {
                this.#log(`invalid message: ${JSON.stringify(msg)}`);
                return;
            }
            this.#log(`message from ${msg.senderId}`);
            if (isEphemeralMessage(msg)) {
                const source = getEphemeralMessageSource(msg);
                if (this.#ephemeralSessionCounts[source] === undefined ||
                    msg.count > this.#ephemeralSessionCounts[source]) {
                    this.#ephemeralSessionCounts[source] = msg.count;
                    this.emit("message", msg);
                }
                return;
            }
            this.emit("message", msg);
        });
        networkAdapter.on("close", () => {
            this.#log("adapter closed");
            Object.entries(this.#adaptersByPeer).forEach(([peerId, other]) => {
                if (other === networkAdapter) {
                    delete this.#adaptersByPeer[peerId];
                }
            });
        });
        this.peerMetadata
            .then(peerMetadata => {
            networkAdapter.connect(this.peerId, peerMetadata);
        })
            .catch(err => {
            this.#log("error connecting to network", err);
        });
    }
    send(message) {
        const peer = this.#adaptersByPeer[message.targetId];
        if (!peer) {
            this.#log(`Tried to send message but peer not found: ${message.targetId}`);
            return;
        }
        /** Messages come in without a senderId and other required information; this is where we make
         * sure they have everything they need.
         */
        const prepareMessage = (message) => {
            if (message.type === "ephemeral") {
                if ("count" in message) {
                    // existing ephemeral message from another peer; pass on without changes
                    return message;
                }
                else {
                    // new ephemeral message from us; add our senderId as well as a counter and session id
                    return {
                        ...message,
                        count: ++this.#count,
                        sessionId: this.#sessionId,
                        senderId: this.peerId,
                    };
                }
            }
            else {
                // other message type; just add our senderId
                return {
                    ...message,
                    senderId: this.peerId,
                };
            }
        };
        const outbound = prepareMessage(message);
        this.#log("sending message %o", outbound);
        peer.send(outbound);
    }
    isReady = () => {
        return this.#readyAdapterCount === this.#adapters.length;
    };
    whenReady = async () => {
        if (this.isReady()) {
            return;
        }
        else {
            return new Promise(resolve => {
                this.once("ready", () => {
                    resolve();
                });
            });
        }
    };
}
function randomPeerId() {
    return `user-${Math.round(Math.random() * 100000)}`;
}

function mergeArrays(myArrays) {
    // Get the total length of all arrays.
    let length = 0;
    myArrays.forEach(item => {
        length += item.length;
    });
    // Create a new array with total length and merge all source arrays.
    const mergedArray = new Uint8Array(length);
    let offset = 0;
    myArrays.forEach(item => {
        mergedArray.set(item, offset);
        offset += item.length;
    });
    return mergedArray;
}

var sha256$1 = {exports: {}};

var sha256 = sha256$1.exports;

var hasRequiredSha256;

function requireSha256 () {
	if (hasRequiredSha256) return sha256$1.exports;
	hasRequiredSha256 = 1;
	(function (module) {
		(function (root, factory) {
		    // Hack to make all exports of this module sha256 function object properties.
		    var exports = {};
		    factory(exports);
		    var sha256 = exports["default"];
		    for (var k in exports) {
		        sha256[k] = exports[k];
		    }
		        
		    {
		        module.exports = sha256;
		    }
		})(sha256, function(exports) {
		exports.__esModule = true;
		// SHA-256 (+ HMAC and PBKDF2) for JavaScript.
		//
		// Written in 2014-2016 by Dmitry Chestnykh.
		// Public domain, no warranty.
		//
		// Functions (accept and return Uint8Arrays):
		//
		//   sha256(message) -> hash
		//   sha256.hmac(key, message) -> mac
		//   sha256.pbkdf2(password, salt, rounds, dkLen) -> dk
		//
		//  Classes:
		//
		//   new sha256.Hash()
		//   new sha256.HMAC(key)
		//
		exports.digestLength = 32;
		exports.blockSize = 64;
		// SHA-256 constants
		var K = new Uint32Array([
		    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,
		    0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,
		    0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,
		    0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
		    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,
		    0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,
		    0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,
		    0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
		    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,
		    0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08,
		    0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f,
		    0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
		    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
		]);
		function hashBlocks(w, v, p, pos, len) {
		    var a, b, c, d, e, f, g, h, u, i, j, t1, t2;
		    while (len >= 64) {
		        a = v[0];
		        b = v[1];
		        c = v[2];
		        d = v[3];
		        e = v[4];
		        f = v[5];
		        g = v[6];
		        h = v[7];
		        for (i = 0; i < 16; i++) {
		            j = pos + i * 4;
		            w[i] = (((p[j] & 0xff) << 24) | ((p[j + 1] & 0xff) << 16) |
		                ((p[j + 2] & 0xff) << 8) | (p[j + 3] & 0xff));
		        }
		        for (i = 16; i < 64; i++) {
		            u = w[i - 2];
		            t1 = (u >>> 17 | u << (32 - 17)) ^ (u >>> 19 | u << (32 - 19)) ^ (u >>> 10);
		            u = w[i - 15];
		            t2 = (u >>> 7 | u << (32 - 7)) ^ (u >>> 18 | u << (32 - 18)) ^ (u >>> 3);
		            w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0);
		        }
		        for (i = 0; i < 64; i++) {
		            t1 = (((((e >>> 6 | e << (32 - 6)) ^ (e >>> 11 | e << (32 - 11)) ^
		                (e >>> 25 | e << (32 - 25))) + ((e & f) ^ (~e & g))) | 0) +
		                ((h + ((K[i] + w[i]) | 0)) | 0)) | 0;
		            t2 = (((a >>> 2 | a << (32 - 2)) ^ (a >>> 13 | a << (32 - 13)) ^
		                (a >>> 22 | a << (32 - 22))) + ((a & b) ^ (a & c) ^ (b & c))) | 0;
		            h = g;
		            g = f;
		            f = e;
		            e = (d + t1) | 0;
		            d = c;
		            c = b;
		            b = a;
		            a = (t1 + t2) | 0;
		        }
		        v[0] += a;
		        v[1] += b;
		        v[2] += c;
		        v[3] += d;
		        v[4] += e;
		        v[5] += f;
		        v[6] += g;
		        v[7] += h;
		        pos += 64;
		        len -= 64;
		    }
		    return pos;
		}
		// Hash implements SHA256 hash algorithm.
		var Hash = /** @class */ (function () {
		    function Hash() {
		        this.digestLength = exports.digestLength;
		        this.blockSize = exports.blockSize;
		        // Note: Int32Array is used instead of Uint32Array for performance reasons.
		        this.state = new Int32Array(8); // hash state
		        this.temp = new Int32Array(64); // temporary state
		        this.buffer = new Uint8Array(128); // buffer for data to hash
		        this.bufferLength = 0; // number of bytes in buffer
		        this.bytesHashed = 0; // number of total bytes hashed
		        this.finished = false; // indicates whether the hash was finalized
		        this.reset();
		    }
		    // Resets hash state making it possible
		    // to re-use this instance to hash other data.
		    Hash.prototype.reset = function () {
		        this.state[0] = 0x6a09e667;
		        this.state[1] = 0xbb67ae85;
		        this.state[2] = 0x3c6ef372;
		        this.state[3] = 0xa54ff53a;
		        this.state[4] = 0x510e527f;
		        this.state[5] = 0x9b05688c;
		        this.state[6] = 0x1f83d9ab;
		        this.state[7] = 0x5be0cd19;
		        this.bufferLength = 0;
		        this.bytesHashed = 0;
		        this.finished = false;
		        return this;
		    };
		    // Cleans internal buffers and re-initializes hash state.
		    Hash.prototype.clean = function () {
		        for (var i = 0; i < this.buffer.length; i++) {
		            this.buffer[i] = 0;
		        }
		        for (var i = 0; i < this.temp.length; i++) {
		            this.temp[i] = 0;
		        }
		        this.reset();
		    };
		    // Updates hash state with the given data.
		    //
		    // Optionally, length of the data can be specified to hash
		    // fewer bytes than data.length.
		    //
		    // Throws error when trying to update already finalized hash:
		    // instance must be reset to use it again.
		    Hash.prototype.update = function (data, dataLength) {
		        if (dataLength === void 0) { dataLength = data.length; }
		        if (this.finished) {
		            throw new Error("SHA256: can't update because hash was finished.");
		        }
		        var dataPos = 0;
		        this.bytesHashed += dataLength;
		        if (this.bufferLength > 0) {
		            while (this.bufferLength < 64 && dataLength > 0) {
		                this.buffer[this.bufferLength++] = data[dataPos++];
		                dataLength--;
		            }
		            if (this.bufferLength === 64) {
		                hashBlocks(this.temp, this.state, this.buffer, 0, 64);
		                this.bufferLength = 0;
		            }
		        }
		        if (dataLength >= 64) {
		            dataPos = hashBlocks(this.temp, this.state, data, dataPos, dataLength);
		            dataLength %= 64;
		        }
		        while (dataLength > 0) {
		            this.buffer[this.bufferLength++] = data[dataPos++];
		            dataLength--;
		        }
		        return this;
		    };
		    // Finalizes hash state and puts hash into out.
		    //
		    // If hash was already finalized, puts the same value.
		    Hash.prototype.finish = function (out) {
		        if (!this.finished) {
		            var bytesHashed = this.bytesHashed;
		            var left = this.bufferLength;
		            var bitLenHi = (bytesHashed / 0x20000000) | 0;
		            var bitLenLo = bytesHashed << 3;
		            var padLength = (bytesHashed % 64 < 56) ? 64 : 128;
		            this.buffer[left] = 0x80;
		            for (var i = left + 1; i < padLength - 8; i++) {
		                this.buffer[i] = 0;
		            }
		            this.buffer[padLength - 8] = (bitLenHi >>> 24) & 0xff;
		            this.buffer[padLength - 7] = (bitLenHi >>> 16) & 0xff;
		            this.buffer[padLength - 6] = (bitLenHi >>> 8) & 0xff;
		            this.buffer[padLength - 5] = (bitLenHi >>> 0) & 0xff;
		            this.buffer[padLength - 4] = (bitLenLo >>> 24) & 0xff;
		            this.buffer[padLength - 3] = (bitLenLo >>> 16) & 0xff;
		            this.buffer[padLength - 2] = (bitLenLo >>> 8) & 0xff;
		            this.buffer[padLength - 1] = (bitLenLo >>> 0) & 0xff;
		            hashBlocks(this.temp, this.state, this.buffer, 0, padLength);
		            this.finished = true;
		        }
		        for (var i = 0; i < 8; i++) {
		            out[i * 4 + 0] = (this.state[i] >>> 24) & 0xff;
		            out[i * 4 + 1] = (this.state[i] >>> 16) & 0xff;
		            out[i * 4 + 2] = (this.state[i] >>> 8) & 0xff;
		            out[i * 4 + 3] = (this.state[i] >>> 0) & 0xff;
		        }
		        return this;
		    };
		    // Returns the final hash digest.
		    Hash.prototype.digest = function () {
		        var out = new Uint8Array(this.digestLength);
		        this.finish(out);
		        return out;
		    };
		    // Internal function for use in HMAC for optimization.
		    Hash.prototype._saveState = function (out) {
		        for (var i = 0; i < this.state.length; i++) {
		            out[i] = this.state[i];
		        }
		    };
		    // Internal function for use in HMAC for optimization.
		    Hash.prototype._restoreState = function (from, bytesHashed) {
		        for (var i = 0; i < this.state.length; i++) {
		            this.state[i] = from[i];
		        }
		        this.bytesHashed = bytesHashed;
		        this.finished = false;
		        this.bufferLength = 0;
		    };
		    return Hash;
		}());
		exports.Hash = Hash;
		// HMAC implements HMAC-SHA256 message authentication algorithm.
		var HMAC = /** @class */ (function () {
		    function HMAC(key) {
		        this.inner = new Hash();
		        this.outer = new Hash();
		        this.blockSize = this.inner.blockSize;
		        this.digestLength = this.inner.digestLength;
		        var pad = new Uint8Array(this.blockSize);
		        if (key.length > this.blockSize) {
		            (new Hash()).update(key).finish(pad).clean();
		        }
		        else {
		            for (var i = 0; i < key.length; i++) {
		                pad[i] = key[i];
		            }
		        }
		        for (var i = 0; i < pad.length; i++) {
		            pad[i] ^= 0x36;
		        }
		        this.inner.update(pad);
		        for (var i = 0; i < pad.length; i++) {
		            pad[i] ^= 0x36 ^ 0x5c;
		        }
		        this.outer.update(pad);
		        this.istate = new Uint32Array(8);
		        this.ostate = new Uint32Array(8);
		        this.inner._saveState(this.istate);
		        this.outer._saveState(this.ostate);
		        for (var i = 0; i < pad.length; i++) {
		            pad[i] = 0;
		        }
		    }
		    // Returns HMAC state to the state initialized with key
		    // to make it possible to run HMAC over the other data with the same
		    // key without creating a new instance.
		    HMAC.prototype.reset = function () {
		        this.inner._restoreState(this.istate, this.inner.blockSize);
		        this.outer._restoreState(this.ostate, this.outer.blockSize);
		        return this;
		    };
		    // Cleans HMAC state.
		    HMAC.prototype.clean = function () {
		        for (var i = 0; i < this.istate.length; i++) {
		            this.ostate[i] = this.istate[i] = 0;
		        }
		        this.inner.clean();
		        this.outer.clean();
		    };
		    // Updates state with provided data.
		    HMAC.prototype.update = function (data) {
		        this.inner.update(data);
		        return this;
		    };
		    // Finalizes HMAC and puts the result in out.
		    HMAC.prototype.finish = function (out) {
		        if (this.outer.finished) {
		            this.outer.finish(out);
		        }
		        else {
		            this.inner.finish(out);
		            this.outer.update(out, this.digestLength).finish(out);
		        }
		        return this;
		    };
		    // Returns message authentication code.
		    HMAC.prototype.digest = function () {
		        var out = new Uint8Array(this.digestLength);
		        this.finish(out);
		        return out;
		    };
		    return HMAC;
		}());
		exports.HMAC = HMAC;
		// Returns SHA256 hash of data.
		function hash(data) {
		    var h = (new Hash()).update(data);
		    var digest = h.digest();
		    h.clean();
		    return digest;
		}
		exports.hash = hash;
		// Function hash is both available as module.hash and as default export.
		exports["default"] = hash;
		// Returns HMAC-SHA256 of data under the key.
		function hmac(key, data) {
		    var h = (new HMAC(key)).update(data);
		    var digest = h.digest();
		    h.clean();
		    return digest;
		}
		exports.hmac = hmac;
		// Fills hkdf buffer like this:
		// T(1) = HMAC-Hash(PRK, T(0) | info | 0x01)
		function fillBuffer(buffer, hmac, info, counter) {
		    // Counter is a byte value: check if it overflowed.
		    var num = counter[0];
		    if (num === 0) {
		        throw new Error("hkdf: cannot expand more");
		    }
		    // Prepare HMAC instance for new data with old key.
		    hmac.reset();
		    // Hash in previous output if it was generated
		    // (i.e. counter is greater than 1).
		    if (num > 1) {
		        hmac.update(buffer);
		    }
		    // Hash in info if it exists.
		    if (info) {
		        hmac.update(info);
		    }
		    // Hash in the counter.
		    hmac.update(counter);
		    // Output result to buffer and clean HMAC instance.
		    hmac.finish(buffer);
		    // Increment counter inside typed array, this works properly.
		    counter[0]++;
		}
		var hkdfSalt = new Uint8Array(exports.digestLength); // Filled with zeroes.
		function hkdf(key, salt, info, length) {
		    if (salt === void 0) { salt = hkdfSalt; }
		    if (length === void 0) { length = 32; }
		    var counter = new Uint8Array([1]);
		    // HKDF-Extract uses salt as HMAC key, and key as data.
		    var okm = hmac(salt, key);
		    // Initialize HMAC for expanding with extracted key.
		    // Ensure no collisions with `hmac` function.
		    var hmac_ = new HMAC(okm);
		    // Allocate buffer.
		    var buffer = new Uint8Array(hmac_.digestLength);
		    var bufpos = buffer.length;
		    var out = new Uint8Array(length);
		    for (var i = 0; i < length; i++) {
		        if (bufpos === buffer.length) {
		            fillBuffer(buffer, hmac_, info, counter);
		            bufpos = 0;
		        }
		        out[i] = buffer[bufpos++];
		    }
		    hmac_.clean();
		    buffer.fill(0);
		    counter.fill(0);
		    return out;
		}
		exports.hkdf = hkdf;
		// Derives a key from password and salt using PBKDF2-HMAC-SHA256
		// with the given number of iterations.
		//
		// The number of bytes returned is equal to dkLen.
		//
		// (For better security, avoid dkLen greater than hash length - 32 bytes).
		function pbkdf2(password, salt, iterations, dkLen) {
		    var prf = new HMAC(password);
		    var len = prf.digestLength;
		    var ctr = new Uint8Array(4);
		    var t = new Uint8Array(len);
		    var u = new Uint8Array(len);
		    var dk = new Uint8Array(dkLen);
		    for (var i = 0; i * len < dkLen; i++) {
		        var c = i + 1;
		        ctr[0] = (c >>> 24) & 0xff;
		        ctr[1] = (c >>> 16) & 0xff;
		        ctr[2] = (c >>> 8) & 0xff;
		        ctr[3] = (c >>> 0) & 0xff;
		        prf.reset();
		        prf.update(salt);
		        prf.update(ctr);
		        prf.finish(u);
		        for (var j = 0; j < len; j++) {
		            t[j] = u[j];
		        }
		        for (var j = 2; j <= iterations; j++) {
		            prf.reset();
		            prf.update(u).finish(u);
		            for (var k = 0; k < len; k++) {
		                t[k] ^= u[k];
		            }
		        }
		        for (var j = 0; j < len && i * len + j < dkLen; j++) {
		            dk[i * len + j] = t[j];
		        }
		    }
		    for (var i = 0; i < len; i++) {
		        t[i] = u[i] = 0;
		    }
		    for (var i = 0; i < 4; i++) {
		        ctr[i] = 0;
		    }
		    prf.clean();
		    return dk;
		}
		exports.pbkdf2 = pbkdf2;
		}); 
	} (sha256$1));
	return sha256$1.exports;
}

var sha256Exports = requireSha256();

function keyHash(binary) {
    // calculate hash
    const hash = sha256Exports.hash(binary);
    return bufferToHexString(hash);
}
function headsHash(heads) {
    const encoder = new TextEncoder();
    const headsbinary = mergeArrays(heads.map((h) => encoder.encode(h)));
    return keyHash(headsbinary);
}
function bufferToHexString(data) {
    return Array.from(data, byte => byte.toString(16).padStart(2, "0")).join("");
}

/**
 * Keys for storing Automerge documents are of the form:
 * ```ts
 * [documentId, "snapshot", hash]  // OR
 * [documentId, "incremental", hash]
 * ```
 * This function returns the chunk type ("snapshot" or "incremental") if the key is in one of these
 * forms.
 */
function chunkTypeFromKey(key) {
    if (key.length < 2)
        return null;
    const chunkTypeStr = key[key.length - 2]; // next-to-last element in key
    if (chunkTypeStr === "snapshot" || chunkTypeStr === "incremental") {
        return chunkTypeStr;
    }
    return null;
}

/**
 * The storage subsystem is responsible for saving and loading Automerge documents to and from
 * storage adapter. It also provides a generic key/value storage interface for other uses.
 */
class StorageSubsystem {
    /** The storage adapter to use for saving and loading documents */
    #storageAdapter;
    /** Record of the latest heads we've loaded or saved for each document  */
    #storedHeads = new Map();
    /** Metadata on the chunks we've already loaded for each document */
    #chunkInfos = new Map();
    /** Flag to avoid compacting when a compaction is already underway */
    #compacting = false;
    #log = debug(`automerge-repo:storage-subsystem`);
    constructor(storageAdapter) {
        this.#storageAdapter = storageAdapter;
    }
    async id() {
        const storedId = await this.#storageAdapter.load(["storage-adapter-id"]);
        let id;
        if (storedId) {
            id = new TextDecoder().decode(storedId);
        }
        else {
            id = v4();
            await this.#storageAdapter.save(["storage-adapter-id"], new TextEncoder().encode(id));
        }
        return id;
    }
    // ARBITRARY KEY/VALUE STORAGE
    // The `load`, `save`, and `remove` methods are for generic key/value storage, as opposed to
    // Automerge documents. For example, they're used by the LocalFirstAuthProvider to persist the
    // encrypted team graph that encodes group membership and permissions.
    //
    // The namespace parameter is to prevent collisions with other users of the storage subsystem.
    // Typically this will be the name of the plug-in, adapter, or other system that is using it. For
    // example, the LocalFirstAuthProvider uses the namespace `LocalFirstAuthProvider`.
    /** Loads a value from storage. */
    async load(
    /** Namespace to prevent collisions with other users of the storage subsystem. */
    namespace, 
    /** Key to load. Typically a UUID or other unique identifier, but could be any string. */
    key) {
        const storageKey = [namespace, key];
        return await this.#storageAdapter.load(storageKey);
    }
    /** Saves a value in storage. */
    async save(
    /** Namespace to prevent collisions with other users of the storage subsystem. */
    namespace, 
    /** Key to load. Typically a UUID or other unique identifier, but could be any string. */
    key, 
    /** Data to save, as a binary blob. */
    data) {
        const storageKey = [namespace, key];
        await this.#storageAdapter.save(storageKey, data);
    }
    /** Removes a value from storage. */
    async remove(
    /** Namespace to prevent collisions with other users of the storage subsystem. */
    namespace, 
    /** Key to remove. Typically a UUID or other unique identifier, but could be any string. */
    key) {
        const storageKey = [namespace, key];
        await this.#storageAdapter.remove(storageKey);
    }
    // AUTOMERGE DOCUMENT STORAGE
    /**
     * Loads the Automerge document with the given ID from storage.
     */
    async loadDoc(documentId) {
        // Load all the chunks for this document
        const chunks = await this.#storageAdapter.loadRange([documentId]);
        const binaries = [];
        const chunkInfos = [];
        for (const chunk of chunks) {
            // chunks might have been deleted in the interim
            if (chunk.data === undefined)
                continue;
            const chunkType = chunkTypeFromKey(chunk.key);
            if (chunkType == null)
                continue;
            chunkInfos.push({
                key: chunk.key,
                type: chunkType,
                size: chunk.data.length,
            });
            binaries.push(chunk.data);
        }
        this.#chunkInfos.set(documentId, chunkInfos);
        // Merge the chunks into a single binary
        const binary = mergeArrays(binaries);
        if (binary.length === 0)
            return null;
        // Load into an Automerge document
        const newDoc = loadIncremental(init(), binary);
        // Record the latest heads for the document
        this.#storedHeads.set(documentId, getHeads(newDoc));
        return newDoc;
    }
    /**
     * Saves the provided Automerge document to storage.
     *
     * @remarks
     * Under the hood this makes incremental saves until the incremental size is greater than the
     * snapshot size, at which point the document is compacted into a single snapshot.
     */
    async saveDoc(documentId, doc) {
        // Don't bother saving if the document hasn't changed
        if (!this.#shouldSave(documentId, doc))
            return;
        const sourceChunks = this.#chunkInfos.get(documentId) ?? [];
        if (this.#shouldCompact(sourceChunks)) {
            await this.#saveTotal(documentId, doc, sourceChunks);
        }
        else {
            await this.#saveIncremental(documentId, doc);
        }
        this.#storedHeads.set(documentId, getHeads(doc));
    }
    /**
     * Removes the Automerge document with the given ID from storage
     */
    async removeDoc(documentId) {
        await this.#storageAdapter.removeRange([documentId, "snapshot"]);
        await this.#storageAdapter.removeRange([documentId, "incremental"]);
        await this.#storageAdapter.removeRange([documentId, "sync-state"]);
    }
    /**
     * Saves just the incremental changes since the last save.
     */
    async #saveIncremental(documentId, doc) {
        const binary = saveSince(doc, this.#storedHeads.get(documentId) ?? []);
        if (binary && binary.length > 0) {
            const key = [documentId, "incremental", keyHash(binary)];
            this.#log(`Saving incremental ${key} for document ${documentId}`);
            await this.#storageAdapter.save(key, binary);
            if (!this.#chunkInfos.has(documentId)) {
                this.#chunkInfos.set(documentId, []);
            }
            this.#chunkInfos.get(documentId).push({
                key,
                type: "incremental",
                size: binary.length,
            });
            this.#storedHeads.set(documentId, getHeads(doc));
        }
        else {
            return Promise.resolve();
        }
    }
    /**
     * Compacts the document storage into a single shapshot.
     */
    async #saveTotal(documentId, doc, sourceChunks) {
        this.#compacting = true;
        const binary = save(doc);
        const snapshotHash = headsHash(getHeads(doc));
        const key = [documentId, "snapshot", snapshotHash];
        const oldKeys = new Set(sourceChunks.map(c => c.key).filter(k => k[2] !== snapshotHash));
        this.#log(`Saving snapshot ${key} for document ${documentId}`);
        this.#log(`deleting old chunks ${Array.from(oldKeys)}`);
        await this.#storageAdapter.save(key, binary);
        for (const key of oldKeys) {
            await this.#storageAdapter.remove(key);
        }
        const newChunkInfos = this.#chunkInfos.get(documentId)?.filter(c => !oldKeys.has(c.key)) ?? [];
        newChunkInfos.push({ key, type: "snapshot", size: binary.length });
        this.#chunkInfos.set(documentId, newChunkInfos);
        this.#compacting = false;
    }
    async loadSyncState(documentId, storageId) {
        const key = [documentId, "sync-state", storageId];
        const loaded = await this.#storageAdapter.load(key);
        return loaded ? decodeSyncState$2(loaded) : undefined;
    }
    async saveSyncState(documentId, storageId, syncState) {
        const key = [documentId, "sync-state", storageId];
        await this.#storageAdapter.save(key, encodeSyncState$2(syncState));
    }
    /**
     * Returns true if the document has changed since the last time it was saved.
     */
    #shouldSave(documentId, doc) {
        const oldHeads = this.#storedHeads.get(documentId);
        if (!oldHeads) {
            // we haven't saved this document before
            return true;
        }
        const newHeads = getHeads(doc);
        if (headsAreSame(newHeads, oldHeads)) {
            // the document hasn't changed
            return false;
        }
        return true; // the document has changed
    }
    /**
     * We only compact if the incremental size is greater than the snapshot size.
     */
    #shouldCompact(sourceChunks) {
        if (this.#compacting)
            return false;
        let snapshotSize = 0;
        let incrementalSize = 0;
        for (const chunk of sourceChunks) {
            if (chunk.type === "snapshot") {
                snapshotSize += chunk.size;
            }
            else {
                incrementalSize += chunk.size;
            }
        }
        // if the file is currently small, don't worry, just compact
        // this might seem a bit arbitrary (1k is arbitrary) but is designed to ensure compaction
        // for documents with only a single large change on top of an empty (or nearly empty) document
        // for example: imported NPM modules, images, etc.
        // if we have even more incrementals (so far) than the snapshot, compact
        return snapshotSize < 1024 || incrementalSize >= snapshotSize;
    }
}

class Synchronizer extends EventEmitter$1 {
}

/**
 * DocSynchronizer takes a handle to an Automerge document, and receives & dispatches sync messages
 * to bring it inline with all other peers' versions.
 */
class DocSynchronizer extends Synchronizer {
    #log;
    syncDebounceRate = 100;
    /** Active peers */
    #peers = [];
    #pendingSyncStateCallbacks = {};
    #peerDocumentStatuses = {};
    /** Sync state for each peer we've communicated with (including inactive peers) */
    #syncStates = {};
    #pendingSyncMessages = [];
    #syncStarted = false;
    #handle;
    #onLoadSyncState;
    constructor({ handle, onLoadSyncState }) {
        super();
        this.#handle = handle;
        this.#onLoadSyncState =
            onLoadSyncState ?? (() => Promise.resolve(undefined));
        const docId = handle.documentId.slice(0, 5);
        this.#log = debug(`automerge-repo:docsync:${docId}`);
        handle.on("change", throttle(() => this.#syncWithPeers(), this.syncDebounceRate));
        handle.on("ephemeral-message-outbound", payload => this.#broadcastToPeers(payload));
        // Process pending sync messages immediately after the handle becomes ready.
        void (async () => {
            await handle.doc([READY, REQUESTING]);
            this.#processAllPendingSyncMessages();
        })();
    }
    get peerStates() {
        return this.#peerDocumentStatuses;
    }
    get documentId() {
        return this.#handle.documentId;
    }
    /// PRIVATE
    async #syncWithPeers() {
        this.#log(`syncWithPeers`);
        const doc = await this.#handle.doc();
        if (doc === undefined)
            return;
        this.#peers.forEach(peerId => this.#sendSyncMessage(peerId, doc));
    }
    async #broadcastToPeers({ data, }) {
        this.#log(`broadcastToPeers`, this.#peers);
        this.#peers.forEach(peerId => this.#sendEphemeralMessage(peerId, data));
    }
    #sendEphemeralMessage(peerId, data) {
        this.#log(`sendEphemeralMessage ->${peerId}`);
        const message = {
            type: "ephemeral",
            targetId: peerId,
            documentId: this.#handle.documentId,
            data,
        };
        this.emit("message", message);
    }
    #withSyncState(peerId, callback) {
        this.#addPeer(peerId);
        if (!(peerId in this.#peerDocumentStatuses)) {
            this.#peerDocumentStatuses[peerId] = "unknown";
        }
        const syncState = this.#syncStates[peerId];
        if (syncState) {
            callback(syncState);
            return;
        }
        let pendingCallbacks = this.#pendingSyncStateCallbacks[peerId];
        if (!pendingCallbacks) {
            this.#onLoadSyncState(peerId)
                .then(syncState => {
                this.#initSyncState(peerId, syncState ?? initSyncState$2());
            })
                .catch(err => {
                this.#log(`Error loading sync state for ${peerId}: ${err}`);
            });
            pendingCallbacks = this.#pendingSyncStateCallbacks[peerId] = [];
        }
        pendingCallbacks.push(callback);
    }
    #addPeer(peerId) {
        if (!this.#peers.includes(peerId)) {
            this.#peers.push(peerId);
            this.emit("open-doc", { documentId: this.documentId, peerId });
        }
    }
    #initSyncState(peerId, syncState) {
        const pendingCallbacks = this.#pendingSyncStateCallbacks[peerId];
        if (pendingCallbacks) {
            for (const callback of pendingCallbacks) {
                callback(syncState);
            }
        }
        delete this.#pendingSyncStateCallbacks[peerId];
        this.#syncStates[peerId] = syncState;
    }
    #setSyncState(peerId, syncState) {
        this.#syncStates[peerId] = syncState;
        this.emit("sync-state", {
            peerId,
            syncState,
            documentId: this.#handle.documentId,
        });
    }
    #sendSyncMessage(peerId, doc) {
        this.#log(`sendSyncMessage ->${peerId}`);
        this.#withSyncState(peerId, syncState => {
            const [newSyncState, message] = generateSyncMessage(doc, syncState);
            if (message) {
                this.#setSyncState(peerId, newSyncState);
                const isNew = getHeads(doc).length === 0;
                if (!this.#handle.isReady() &&
                    isNew &&
                    newSyncState.sharedHeads.length === 0 &&
                    !Object.values(this.#peerDocumentStatuses).includes("has") &&
                    this.#peerDocumentStatuses[peerId] === "unknown") {
                    // we don't have the document (or access to it), so we request it
                    this.emit("message", {
                        type: "request",
                        targetId: peerId,
                        documentId: this.#handle.documentId,
                        data: message,
                    });
                }
                else {
                    this.emit("message", {
                        type: "sync",
                        targetId: peerId,
                        data: message,
                        documentId: this.#handle.documentId,
                    });
                }
                // if we have sent heads, then the peer now has or will have the document
                if (!isNew) {
                    this.#peerDocumentStatuses[peerId] = "has";
                }
            }
        });
    }
    /// PUBLIC
    hasPeer(peerId) {
        return this.#peers.includes(peerId);
    }
    beginSync(peerIds) {
        const noPeersWithDocument = peerIds.every(peerId => this.#peerDocumentStatuses[peerId] in ["unavailable", "wants"]);
        // At this point if we don't have anything in our storage, we need to use an empty doc to sync
        // with; but we don't want to surface that state to the front end
        const docPromise = this.#handle
            .doc([READY, REQUESTING, UNAVAILABLE])
            .then(doc => {
            // we register out peers first, then say that sync has started
            this.#syncStarted = true;
            this.#checkDocUnavailable();
            const wasUnavailable = doc === undefined;
            if (wasUnavailable && noPeersWithDocument) {
                return;
            }
            // If the doc is unavailable we still need a blank document to generate
            // the sync message from
            return doc ?? init();
        });
        this.#log(`beginSync: ${peerIds.join(", ")}`);
        peerIds.forEach(peerId => {
            this.#withSyncState(peerId, syncState => {
                // HACK: if we have a sync state already, we round-trip it through the encoding system to make
                // sure state is preserved. This prevents an infinite loop caused by failed attempts to send
                // messages during disconnection.
                // TODO: cover that case with a test and remove this hack
                const reparsedSyncState = decodeSyncState$2(encodeSyncState$2(syncState));
                this.#setSyncState(peerId, reparsedSyncState);
                docPromise
                    .then(doc => {
                    if (doc) {
                        this.#sendSyncMessage(peerId, doc);
                    }
                })
                    .catch(err => {
                    this.#log(`Error loading doc for ${peerId}: ${err}`);
                });
            });
        });
    }
    endSync(peerId) {
        this.#log(`removing peer ${peerId}`);
        this.#peers = this.#peers.filter(p => p !== peerId);
    }
    receiveMessage(message) {
        switch (message.type) {
            case "sync":
            case "request":
                this.receiveSyncMessage(message);
                break;
            case "ephemeral":
                this.receiveEphemeralMessage(message);
                break;
            case "doc-unavailable":
                this.#peerDocumentStatuses[message.senderId] = "unavailable";
                this.#checkDocUnavailable();
                break;
            default:
                throw new Error(`unknown message type: ${message}`);
        }
    }
    receiveEphemeralMessage(message) {
        if (message.documentId !== this.#handle.documentId)
            throw new Error(`channelId doesn't match documentId`);
        const { senderId, data } = message;
        const contents = decode$1(new Uint8Array(data));
        this.#handle.emit("ephemeral-message", {
            handle: this.#handle,
            senderId,
            message: contents,
        });
        this.#peers.forEach(peerId => {
            if (peerId === senderId)
                return;
            this.emit("message", {
                ...message,
                targetId: peerId,
            });
        });
    }
    receiveSyncMessage(message) {
        if (message.documentId !== this.#handle.documentId)
            throw new Error(`channelId doesn't match documentId`);
        // We need to block receiving the syncMessages until we've checked local storage
        if (!this.#handle.inState([READY, REQUESTING, UNAVAILABLE])) {
            this.#pendingSyncMessages.push({ message, received: new Date() });
            return;
        }
        this.#processAllPendingSyncMessages();
        this.#processSyncMessage(message);
    }
    #processSyncMessage(message) {
        if (isRequestMessage(message)) {
            this.#peerDocumentStatuses[message.senderId] = "wants";
        }
        this.#checkDocUnavailable();
        // if the message has heads, then the peer has the document
        if (decodeSyncMessage$2(message.data).heads.length > 0) {
            this.#peerDocumentStatuses[message.senderId] = "has";
        }
        this.#withSyncState(message.senderId, syncState => {
            this.#handle.update(doc => {
                const [newDoc, newSyncState] = receiveSyncMessage(doc, syncState, message.data);
                this.#setSyncState(message.senderId, newSyncState);
                // respond to just this peer (as required)
                this.#sendSyncMessage(message.senderId, doc);
                return newDoc;
            });
            this.#checkDocUnavailable();
        });
    }
    #checkDocUnavailable() {
        // if we know none of the peers have the document, tell all our peers that we don't either
        if (this.#syncStarted &&
            this.#handle.inState([REQUESTING]) &&
            this.#peers.every(peerId => this.#peerDocumentStatuses[peerId] === "unavailable" ||
                this.#peerDocumentStatuses[peerId] === "wants")) {
            this.#peers
                .filter(peerId => this.#peerDocumentStatuses[peerId] === "wants")
                .forEach(peerId => {
                const message = {
                    type: "doc-unavailable",
                    documentId: this.#handle.documentId,
                    targetId: peerId,
                };
                this.emit("message", message);
            });
            this.#handle.unavailable();
        }
    }
    #processAllPendingSyncMessages() {
        for (const message of this.#pendingSyncMessages) {
            this.#processSyncMessage(message.message);
        }
        this.#pendingSyncMessages = [];
    }
}

const log = debug("automerge-repo:collectionsync");
/** A CollectionSynchronizer is responsible for synchronizing a DocCollection with peers. */
class CollectionSynchronizer extends Synchronizer {
    repo;
    /** The set of peers we are connected with */
    #peers = new Set();
    /** A map of documentIds to their synchronizers */
    #docSynchronizers = {};
    /** Used to determine if the document is know to the Collection and a synchronizer exists or is being set up */
    #docSetUp = {};
    constructor(repo) {
        super();
        this.repo = repo;
    }
    /** Returns a synchronizer for the given document, creating one if it doesn't already exist.  */
    #fetchDocSynchronizer(documentId) {
        if (!this.#docSynchronizers[documentId]) {
            const handle = this.repo.find(stringifyAutomergeUrl({ documentId }));
            this.#docSynchronizers[documentId] = this.#initDocSynchronizer(handle);
        }
        return this.#docSynchronizers[documentId];
    }
    /** Creates a new docSynchronizer and sets it up to propagate messages */
    #initDocSynchronizer(handle) {
        const docSynchronizer = new DocSynchronizer({
            handle,
            onLoadSyncState: async (peerId) => {
                if (!this.repo.storageSubsystem) {
                    return;
                }
                const { storageId, isEphemeral } = this.repo.peerMetadataByPeerId[peerId] || {};
                if (!storageId || isEphemeral) {
                    return;
                }
                return this.repo.storageSubsystem.loadSyncState(handle.documentId, storageId);
            },
        });
        docSynchronizer.on("message", event => this.emit("message", event));
        docSynchronizer.on("open-doc", event => this.emit("open-doc", event));
        docSynchronizer.on("sync-state", event => this.emit("sync-state", event));
        return docSynchronizer;
    }
    /** returns an array of peerIds that we share this document generously with */
    async #documentGenerousPeers(documentId) {
        const peers = Array.from(this.#peers);
        const generousPeers = [];
        for (const peerId of peers) {
            const okToShare = await this.repo.sharePolicy(peerId, documentId);
            if (okToShare)
                generousPeers.push(peerId);
        }
        return generousPeers;
    }
    // PUBLIC
    /**
     * When we receive a sync message for a document we haven't got in memory, we
     * register it with the repo and start synchronizing
     */
    async receiveMessage(message) {
        log(`onSyncMessage: ${message.senderId}, ${message.documentId}, ${"data" in message ? message.data.byteLength + "bytes" : ""}`);
        const documentId = message.documentId;
        if (!documentId) {
            throw new Error("received a message with an invalid documentId");
        }
        this.#docSetUp[documentId] = true;
        const docSynchronizer = this.#fetchDocSynchronizer(documentId);
        docSynchronizer.receiveMessage(message);
        // Initiate sync with any new peers
        const peers = await this.#documentGenerousPeers(documentId);
        docSynchronizer.beginSync(peers.filter(peerId => !docSynchronizer.hasPeer(peerId)));
    }
    /**
     * Starts synchronizing the given document with all peers that we share it generously with.
     */
    addDocument(documentId) {
        // HACK: this is a hack to prevent us from adding the same document twice
        if (this.#docSetUp[documentId]) {
            return;
        }
        const docSynchronizer = this.#fetchDocSynchronizer(documentId);
        void this.#documentGenerousPeers(documentId).then(peers => {
            docSynchronizer.beginSync(peers);
        });
    }
    // TODO: implement this
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    removeDocument(documentId) {
        throw new Error("not implemented");
    }
    /** Adds a peer and maybe starts synchronizing with them */
    addPeer(peerId) {
        log(`adding ${peerId} & synchronizing with them`);
        if (this.#peers.has(peerId)) {
            return;
        }
        this.#peers.add(peerId);
        for (const docSynchronizer of Object.values(this.#docSynchronizers)) {
            const { documentId } = docSynchronizer;
            void this.repo.sharePolicy(peerId, documentId).then(okToShare => {
                if (okToShare)
                    docSynchronizer.beginSync([peerId]);
            });
        }
    }
    /** Removes a peer and stops synchronizing with them */
    removePeer(peerId) {
        log(`removing peer ${peerId}`);
        this.#peers.delete(peerId);
        for (const docSynchronizer of Object.values(this.#docSynchronizers)) {
            docSynchronizer.endSync(peerId);
        }
    }
    /** Returns a list of all connected peer ids */
    get peers() {
        return Array.from(this.#peers);
    }
}

/** A Repo is a collection of documents with networking, syncing, and storage capabilities. */
/** The `Repo` is the main entry point of this library
 *
 * @remarks
 * To construct a `Repo` you will need an {@link StorageAdapter} and one or
 * more {@link NetworkAdapter}s. Once you have a `Repo` you can use it to
 * obtain {@link DocHandle}s.
 */
class Repo extends EventEmitter$1 {
    #log;
    /** @hidden */
    networkSubsystem;
    /** @hidden */
    storageSubsystem;
    /** The debounce rate is adjustable on the repo. */
    /** @hidden */
    saveDebounceRate = 100;
    #handleCache = {};
    #synchronizer;
    /** By default, we share generously with all peers. */
    /** @hidden */
    sharePolicy = async () => true;
    /** maps peer id to to persistence information (storageId, isEphemeral), access by collection synchronizer  */
    /** @hidden */
    peerMetadataByPeerId = {};
    #remoteHeadsSubscriptions = new RemoteHeadsSubscriptions();
    #remoteHeadsGossipingEnabled = false;
    constructor({ storage, network = [], peerId, sharePolicy, isEphemeral = storage === undefined, enableRemoteHeadsGossiping = false, } = {}) {
        super();
        this.#remoteHeadsGossipingEnabled = enableRemoteHeadsGossiping;
        this.#log = debug(`automerge-repo:repo`);
        this.sharePolicy = sharePolicy ?? this.sharePolicy;
        // DOC COLLECTION
        // The `document` event is fired by the DocCollection any time we create a new document or look
        // up a document by ID. We listen for it in order to wire up storage and network synchronization.
        this.on("document", async ({ handle, isNew }) => {
            if (storageSubsystem) {
                // Save when the document changes, but no more often than saveDebounceRate.
                const saveFn = ({ handle, doc, }) => {
                    void storageSubsystem.saveDoc(handle.documentId, doc);
                };
                handle.on("heads-changed", throttle(saveFn, this.saveDebounceRate));
                if (isNew) {
                    // this is a new document, immediately save it
                    await storageSubsystem.saveDoc(handle.documentId, handle.docSync());
                }
                else {
                    // Try to load from disk
                    const loadedDoc = await storageSubsystem.loadDoc(handle.documentId);
                    if (loadedDoc) {
                        handle.update(() => loadedDoc);
                    }
                }
            }
            handle.on("unavailable", () => {
                this.#log("document unavailable", { documentId: handle.documentId });
                this.emit("unavailable-document", {
                    documentId: handle.documentId,
                });
            });
            if (this.networkSubsystem.isReady()) {
                handle.request();
            }
            else {
                handle.awaitNetwork();
                this.networkSubsystem
                    .whenReady()
                    .then(() => {
                    handle.networkReady();
                })
                    .catch(err => {
                    this.#log("error waiting for network", { err });
                });
            }
            // Register the document with the synchronizer. This advertises our interest in the document.
            this.#synchronizer.addDocument(handle.documentId);
        });
        this.on("delete-document", ({ documentId }) => {
            // TODO Pass the delete on to the network
            // synchronizer.removeDocument(documentId)
            if (storageSubsystem) {
                storageSubsystem.removeDoc(documentId).catch(err => {
                    this.#log("error deleting document", { documentId, err });
                });
            }
        });
        // SYNCHRONIZER
        // The synchronizer uses the network subsystem to keep documents in sync with peers.
        this.#synchronizer = new CollectionSynchronizer(this);
        // When the synchronizer emits messages, send them to peers
        this.#synchronizer.on("message", message => {
            this.#log(`sending ${message.type} message to ${message.targetId}`);
            networkSubsystem.send(message);
        });
        if (this.#remoteHeadsGossipingEnabled) {
            this.#synchronizer.on("open-doc", ({ peerId, documentId }) => {
                this.#remoteHeadsSubscriptions.subscribePeerToDoc(peerId, documentId);
            });
        }
        // STORAGE
        // The storage subsystem has access to some form of persistence, and deals with save and loading documents.
        const storageSubsystem = storage ? new StorageSubsystem(storage) : undefined;
        this.storageSubsystem = storageSubsystem;
        // NETWORK
        // The network subsystem deals with sending and receiving messages to and from peers.
        const myPeerMetadata = (async () => ({
            storageId: await storageSubsystem?.id(),
            isEphemeral,
        }))();
        const networkSubsystem = new NetworkSubsystem(network, peerId, myPeerMetadata);
        this.networkSubsystem = networkSubsystem;
        // When we get a new peer, register it with the synchronizer
        networkSubsystem.on("peer", async ({ peerId, peerMetadata }) => {
            this.#log("peer connected", { peerId });
            if (peerMetadata) {
                this.peerMetadataByPeerId[peerId] = { ...peerMetadata };
            }
            this.sharePolicy(peerId)
                .then(shouldShare => {
                if (shouldShare && this.#remoteHeadsGossipingEnabled) {
                    this.#remoteHeadsSubscriptions.addGenerousPeer(peerId);
                }
            })
                .catch(err => {
                console.log("error in share policy", { err });
            });
            this.#synchronizer.addPeer(peerId);
        });
        // When a peer disconnects, remove it from the synchronizer
        networkSubsystem.on("peer-disconnected", ({ peerId }) => {
            this.#synchronizer.removePeer(peerId);
            this.#remoteHeadsSubscriptions.removePeer(peerId);
        });
        // Handle incoming messages
        networkSubsystem.on("message", async (msg) => {
            this.#receiveMessage(msg);
        });
        this.#synchronizer.on("sync-state", message => {
            this.#saveSyncState(message);
            const handle = this.#handleCache[message.documentId];
            const { storageId } = this.peerMetadataByPeerId[message.peerId] || {};
            if (!storageId) {
                return;
            }
            const heads = handle.getRemoteHeads(storageId);
            const haveHeadsChanged = message.syncState.theirHeads &&
                (!heads || !headsAreSame(heads, message.syncState.theirHeads));
            if (haveHeadsChanged && message.syncState.theirHeads) {
                handle.setRemoteHeads(storageId, message.syncState.theirHeads);
                if (storageId && this.#remoteHeadsGossipingEnabled) {
                    this.#remoteHeadsSubscriptions.handleImmediateRemoteHeadsChanged(message.documentId, storageId, message.syncState.theirHeads);
                }
            }
        });
        if (this.#remoteHeadsGossipingEnabled) {
            this.#remoteHeadsSubscriptions.on("notify-remote-heads", message => {
                this.networkSubsystem.send({
                    type: "remote-heads-changed",
                    targetId: message.targetId,
                    documentId: message.documentId,
                    newHeads: {
                        [message.storageId]: {
                            heads: message.heads,
                            timestamp: message.timestamp,
                        },
                    },
                });
            });
            this.#remoteHeadsSubscriptions.on("change-remote-subs", message => {
                this.#log("change-remote-subs", message);
                for (const peer of message.peers) {
                    this.networkSubsystem.send({
                        type: "remote-subscription-change",
                        targetId: peer,
                        add: message.add,
                        remove: message.remove,
                    });
                }
            });
            this.#remoteHeadsSubscriptions.on("remote-heads-changed", message => {
                const handle = this.#handleCache[message.documentId];
                handle.setRemoteHeads(message.storageId, message.remoteHeads);
            });
        }
    }
    #receiveMessage(message) {
        switch (message.type) {
            case "remote-subscription-change":
                if (this.#remoteHeadsGossipingEnabled) {
                    this.#remoteHeadsSubscriptions.handleControlMessage(message);
                }
                break;
            case "remote-heads-changed":
                if (this.#remoteHeadsGossipingEnabled) {
                    this.#remoteHeadsSubscriptions.handleRemoteHeads(message);
                }
                break;
            case "sync":
            case "request":
            case "ephemeral":
            case "doc-unavailable":
                this.#synchronizer.receiveMessage(message).catch(err => {
                    console.log("error receiving message", { err });
                });
        }
    }
    #throttledSaveSyncStateHandlers = {};
    /** saves sync state throttled per storage id, if a peer doesn't have a storage id it's sync state is not persisted */
    #saveSyncState(payload) {
        if (!this.storageSubsystem) {
            return;
        }
        const { storageId, isEphemeral } = this.peerMetadataByPeerId[payload.peerId] || {};
        if (!storageId || isEphemeral) {
            return;
        }
        let handler = this.#throttledSaveSyncStateHandlers[storageId];
        if (!handler) {
            handler = this.#throttledSaveSyncStateHandlers[storageId] = throttle(({ documentId, syncState }) => {
                void this.storageSubsystem.saveSyncState(documentId, storageId, syncState);
            }, this.saveDebounceRate);
        }
        handler(payload);
    }
    /** Returns an existing handle if we have it; creates one otherwise. */
    #getHandle({ documentId, isNew, initialValue, }) {
        // If we have the handle cached, return it
        if (this.#handleCache[documentId])
            return this.#handleCache[documentId];
        // If not, create a new handle, cache it, and return it
        if (!documentId)
            throw new Error(`Invalid documentId ${documentId}`);
        const handle = new DocHandle(documentId, { isNew, initialValue });
        this.#handleCache[documentId] = handle;
        return handle;
    }
    /** Returns all the handles we have cached. */
    get handles() {
        return this.#handleCache;
    }
    /** Returns a list of all connected peer ids */
    get peers() {
        return this.#synchronizer.peers;
    }
    getStorageIdOfPeer(peerId) {
        return this.peerMetadataByPeerId[peerId]?.storageId;
    }
    /**
     * Creates a new document and returns a handle to it. The initial value of the document is an
     * empty object `{}` unless an initial value is provided. Its documentId is generated by the
     * system. we emit a `document` event to advertise interest in the document.
     */
    create(initialValue) {
        // Generate a new UUID and store it in the buffer
        const { documentId } = parseAutomergeUrl(generateAutomergeUrl());
        const handle = this.#getHandle({
            documentId,
            isNew: true,
            initialValue,
        });
        this.emit("document", { handle, isNew: true });
        return handle;
    }
    /** Create a new DocHandle by cloning the history of an existing DocHandle.
     *
     * @param clonedHandle - The handle to clone
     *
     * @remarks This is a wrapper around the `clone` function in the Automerge library.
     * The new `DocHandle` will have a new URL but will share history with the original,
     * which means that changes made to the cloned handle can be sensibly merged back
     * into the original.
     *
     * Any peers this `Repo` is connected to for whom `sharePolicy` returns `true` will
     * be notified of the newly created DocHandle.
     *
     * @throws if the cloned handle is not yet ready or if
     * `clonedHandle.docSync()` returns `undefined` (i.e. the handle is unavailable).
     */
    clone(clonedHandle) {
        if (!clonedHandle.isReady()) {
            throw new Error(`Cloned handle is not yet in ready state.
        (Try await handle.waitForReady() first.)`);
        }
        const sourceDoc = clonedHandle.docSync();
        if (!sourceDoc) {
            throw new Error("Cloned handle doesn't have a document.");
        }
        const handle = this.create();
        handle.update(() => {
            // we replace the document with the new cloned one
            return clone(sourceDoc);
        });
        return handle;
    }
    /**
     * Retrieves a document by id. It gets data from the local system, but also emits a `document`
     * event to advertise interest in the document.
     */
    find(
    /** The url or documentId of the handle to retrieve */
    id) {
        const documentId = interpretAsDocumentId(id);
        // If we have the handle cached, return it
        if (this.#handleCache[documentId]) {
            if (this.#handleCache[documentId].isUnavailable()) {
                // this ensures that the event fires after the handle has been returned
                setTimeout(() => {
                    this.#handleCache[documentId].emit("unavailable", {
                        handle: this.#handleCache[documentId],
                    });
                });
            }
            return this.#handleCache[documentId];
        }
        const handle = this.#getHandle({
            documentId,
            isNew: false,
        });
        this.emit("document", { handle, isNew: false });
        return handle;
    }
    delete(
    /** The url or documentId of the handle to delete */
    id) {
        const documentId = interpretAsDocumentId(id);
        const handle = this.#getHandle({ documentId, isNew: false });
        handle.delete();
        delete this.#handleCache[documentId];
        this.emit("delete-document", { documentId });
    }
    /**
     * Exports a document to a binary format.
     * @param id - The url or documentId of the handle to export
     *
     * @returns Promise<Uint8Array | undefined> - A Promise containing the binary document,
     * or undefined if the document is unavailable.
     */
    async export(id) {
        const documentId = interpretAsDocumentId(id);
        const handle = this.#getHandle({ documentId, isNew: false });
        const doc = await handle.doc();
        if (!doc)
            return undefined;
        return save(doc);
    }
    /**
     * Imports document binary into the repo.
     * @param binary - The binary to import
     */
    import(binary) {
        const doc = load$2(binary);
        const handle = this.create();
        handle.update(() => {
            return clone(doc);
        });
        return handle;
    }
    subscribeToRemotes = (remotes) => {
        if (this.#remoteHeadsGossipingEnabled) {
            this.#log("subscribeToRemotes", { remotes });
            this.#remoteHeadsSubscriptions.subscribeToRemotes(remotes);
        }
        else {
            this.#log("WARN: subscribeToRemotes called but remote heads gossiping is not enabled");
        }
    };
    storageId = async () => {
        if (!this.storageSubsystem) {
            return undefined;
        }
        else {
            return this.storageSubsystem.id();
        }
    };
    /**
     * Writes Documents to a disk.
     * @hidden this API is experimental and may change.
     * @param documents - if provided, only writes the specified documents.
     * @returns Promise<void>
     */
    async flush(documents) {
        if (!this.storageSubsystem) {
            return;
        }
        const handles = documents
            ? documents.map(id => this.#handleCache[id])
            : Object.values(this.#handleCache);
        await Promise.all(handles.map(async (handle) => {
            const doc = handle.docSync();
            if (!doc) {
                return;
            }
            return this.storageSubsystem.saveDoc(handle.documentId, doc);
        }));
    }
}

/* c8 ignore start */
/** An interface representing some way to connect to other peers
 *
 * @remarks
 * The {@link Repo} uses one or more `NetworkAdapter`s to connect to other peers.
 * Because the network may take some time to be ready the {@link Repo} will wait
 * until the adapter emits a `ready` event before it starts trying to use it
 *
 * This utility class can be used as a base to build a custom network adapter. It
 * is most useful as a simple way to add the necessary event emitter functionality
 */
class NetworkAdapter extends EventEmitter$1 {
    peerId;
    peerMetadata;
}

const __vite__wasmUrl = ""+new URL('automerge_wasm_bg-BEjDkhWo.wasm', import.meta.url).href+"";

const __vite__initWasm = async (opts = {}, url) => {
    let result;
    if (url.startsWith("data:")) {
        const urlContent = url.replace(/^data:.*?base64,/, "");
        let bytes;
        if (typeof Buffer === "function" && typeof Buffer.from === "function") {
            bytes = Buffer.from(urlContent, "base64");
        }
        else if (typeof atob === "function") {
            const binaryString = atob(urlContent);
            bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
        }
        else {
            throw new Error("Cannot decode base64-encoded data URL");
        }
        result = await WebAssembly.instantiate(bytes, opts);
    }
    else {
        // https://github.com/mdn/webassembly-examples/issues/5
        // WebAssembly.instantiateStreaming requires the server to provide the
        // correct MIME type for .wasm files, which unfortunately doesn't work for
        // a lot of static file servers, so we just work around it by getting the
        // raw buffer.
        // @ts-ignore
        const response = await fetch(url);
        const contentType = response.headers.get("Content-Type") || "";
        if ("instantiateStreaming" in WebAssembly && contentType.startsWith("application/wasm")) {
            result = await WebAssembly.instantiateStreaming(response, opts);
        }
        else {
            const buffer = await response.arrayBuffer();
            result = await WebAssembly.instantiate(buffer, opts);
        }
    }
    return result.instance.exports;
};

let wasm$1;
function __wbg_set_wasm(val) {
    wasm$1 = val;
}


const heap = new Array(128).fill(undefined);

heap.push(undefined, null, true, false);

function getObject(idx) { return heap[idx]; }

let heap_next = heap.length;

function dropObject(idx) {
    if (idx < 132) return;
    heap[idx] = heap_next;
    heap_next = idx;
}

function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
}

let WASM_VECTOR_LEN = 0;

let cachedUint8Memory0 = null;

function getUint8Memory0() {
    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
        cachedUint8Memory0 = new Uint8Array(wasm$1.memory.buffer);
    }
    return cachedUint8Memory0;
}

const lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;

let cachedTextEncoder = new lTextEncoder('utf-8');

const encodeString = (typeof cachedTextEncoder.encodeInto === 'function'
    ? function (arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
}
    : function (arg, view) {
    const buf = cachedTextEncoder.encode(arg);
    view.set(buf);
    return {
        read: arg.length,
        written: buf.length
    };
});

function passStringToWasm0(arg, malloc, realloc) {

    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length, 1) >>> 0;
        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }

    let len = arg.length;
    let ptr = malloc(len, 1) >>> 0;

    const mem = getUint8Memory0();

    let offset = 0;

    for (; offset < len; offset++) {
        const code = arg.charCodeAt(offset);
        if (code > 0x7F) break;
        mem[ptr + offset] = code;
    }

    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);

        offset += ret.written;
        ptr = realloc(ptr, len, offset, 1) >>> 0;
    }

    WASM_VECTOR_LEN = offset;
    return ptr;
}

function isLikeNone(x) {
    return x === undefined || x === null;
}

let cachedInt32Memory0 = null;

function getInt32Memory0() {
    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
        cachedInt32Memory0 = new Int32Array(wasm$1.memory.buffer);
    }
    return cachedInt32Memory0;
}

const lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;

let cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });

cachedTextDecoder.decode();

function getStringFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}

function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];

    heap[idx] = obj;
    return idx;
}

let cachedFloat64Memory0 = null;

function getFloat64Memory0() {
    if (cachedFloat64Memory0 === null || cachedFloat64Memory0.byteLength === 0) {
        cachedFloat64Memory0 = new Float64Array(wasm$1.memory.buffer);
    }
    return cachedFloat64Memory0;
}

function debugString(val) {
    // primitive types
    const type = typeof val;
    if (type == 'number' || type == 'boolean' || val == null) {
        return  `${val}`;
    }
    if (type == 'string') {
        return `"${val}"`;
    }
    if (type == 'symbol') {
        const description = val.description;
        if (description == null) {
            return 'Symbol';
        } else {
            return `Symbol(${description})`;
        }
    }
    if (type == 'function') {
        const name = val.name;
        if (typeof name == 'string' && name.length > 0) {
            return `Function(${name})`;
        } else {
            return 'Function';
        }
    }
    // objects
    if (Array.isArray(val)) {
        const length = val.length;
        let debug = '[';
        if (length > 0) {
            debug += debugString(val[0]);
        }
        for(let i = 1; i < length; i++) {
            debug += ', ' + debugString(val[i]);
        }
        debug += ']';
        return debug;
    }
    // Test for built-in
    const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
    let className;
    if (builtInMatches.length > 1) {
        className = builtInMatches[1];
    } else {
        // Failed to match the standard '[object ClassName]'
        return toString.call(val);
    }
    if (className == 'Object') {
        // we're a user defined class or Object
        // JSON.stringify avoids problems with cycles, and is generally much
        // easier than looping through ownProperties of `val`.
        try {
            return 'Object(' + JSON.stringify(val) + ')';
        } catch (_) {
            return 'Object';
        }
    }
    // errors
    if (val instanceof Error) {
        return `${val.name}: ${val.message}\n${val.stack}`;
    }
    // TODO we could test for more things here, like `Set`s and `Map`s.
    return className;
}

function _assertClass(instance, klass) {
    if (!(instance instanceof klass)) {
        throw new Error(`expected instance of ${klass.name}`);
    }
    return instance.ptr;
}
/**
* @param {any} options
* @returns {Automerge}
*/
function create$1(options) {
    try {
        const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
        wasm$1.create(retptr, addHeapObject(options));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return Automerge.__wrap(r0);
    } finally {
        wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} data
* @param {any} options
* @returns {Automerge}
*/
function load$1(data, options) {
    try {
        const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
        wasm$1.load(retptr, addHeapObject(data), addHeapObject(options));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return Automerge.__wrap(r0);
    } finally {
        wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {any} change
* @returns {Uint8Array}
*/
function encodeChange$1(change) {
    try {
        const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
        wasm$1.encodeChange(retptr, addHeapObject(change));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} change
* @returns {any}
*/
function decodeChange$1(change) {
    try {
        const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
        wasm$1.decodeChange(retptr, addHeapObject(change));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @returns {SyncState}
*/
function initSyncState$1() {
    const ret = wasm$1.initSyncState();
    return SyncState.__wrap(ret);
}

/**
* @param {any} state
* @returns {SyncState}
*/
function importSyncState$1(state) {
    try {
        const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
        wasm$1.importSyncState(retptr, addHeapObject(state));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return SyncState.__wrap(r0);
    } finally {
        wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {SyncState} state
* @returns {any}
*/
function exportSyncState$1(state) {
    _assertClass(state, SyncState);
    const ret = wasm$1.exportSyncState(state.__wbg_ptr);
    return takeObject(ret);
}

/**
* @param {any} message
* @returns {Uint8Array}
*/
function encodeSyncMessage$1(message) {
    try {
        const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
        wasm$1.encodeSyncMessage(retptr, addHeapObject(message));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {Uint8Array} msg
* @returns {any}
*/
function decodeSyncMessage$1(msg) {
    try {
        const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
        wasm$1.decodeSyncMessage(retptr, addHeapObject(msg));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return takeObject(r0);
    } finally {
        wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
}

/**
* @param {SyncState} state
* @returns {Uint8Array}
*/
function encodeSyncState$1(state) {
    _assertClass(state, SyncState);
    const ret = wasm$1.encodeSyncState(state.__wbg_ptr);
    return takeObject(ret);
}

/**
* @param {Uint8Array} data
* @returns {SyncState}
*/
function decodeSyncState$1(data) {
    try {
        const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
        wasm$1.decodeSyncState(retptr, addHeapObject(data));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        if (r2) {
            throw takeObject(r1);
        }
        return SyncState.__wrap(r0);
    } finally {
        wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
}

function handleError(f, args) {
    try {
        return f.apply(this, args);
    } catch (e) {
        wasm$1.__wbindgen_exn_store(addHeapObject(e));
    }
}
/**
* How text is represented in materialized objects on the JS side
*/
const TextRepresentation = Object.freeze({
/**
* As an array of characters and objects
*/
Array:0,"0":"Array",
/**
* As a single JS string
*/
String:1,"1":"String", });

const AutomergeFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_automerge_free(ptr >>> 0));
/**
*/
class Automerge {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Automerge.prototype);
        obj.__wbg_ptr = ptr;
        AutomergeFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        AutomergeFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_automerge_free(ptr);
    }
    /**
    * @param {string | undefined} actor
    * @param {TextRepresentation} text_rep
    * @returns {Automerge}
    */
    static new(actor, text_rep) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            var ptr0 = isLikeNone(actor) ? 0 : passStringToWasm0(actor, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
            var len0 = WASM_VECTOR_LEN;
            wasm$1.automerge_new(retptr, ptr0, len0, text_rep);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Automerge.__wrap(r0);
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string | undefined} [actor]
    * @returns {Automerge}
    */
    clone(actor) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            var ptr0 = isLikeNone(actor) ? 0 : passStringToWasm0(actor, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
            var len0 = WASM_VECTOR_LEN;
            wasm$1.automerge_clone(retptr, this.__wbg_ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Automerge.__wrap(r0);
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string | undefined} actor
    * @param {any} heads
    * @returns {Automerge}
    */
    fork(actor, heads) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            var ptr0 = isLikeNone(actor) ? 0 : passStringToWasm0(actor, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
            var len0 = WASM_VECTOR_LEN;
            wasm$1.automerge_fork(retptr, this.__wbg_ptr, ptr0, len0, addHeapObject(heads));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Automerge.__wrap(r0);
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {any}
    */
    pendingOps() {
        const ret = wasm$1.automerge_pendingOps(this.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * @param {string | undefined} [message]
    * @param {number | undefined} [time]
    * @returns {any}
    */
    commit(message, time) {
        var ptr0 = isLikeNone(message) ? 0 : passStringToWasm0(message, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm$1.automerge_commit(this.__wbg_ptr, ptr0, len0, !isLikeNone(time), isLikeNone(time) ? 0 : time);
        return takeObject(ret);
    }
    /**
    * @param {Automerge} other
    * @returns {Array<any>}
    */
    merge(other) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(other, Automerge);
            wasm$1.automerge_merge(retptr, this.__wbg_ptr, other.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {number}
    */
    rollback() {
        const ret = wasm$1.automerge_rollback(this.__wbg_ptr);
        return ret;
    }
    /**
    * @param {any} obj
    * @param {Array<any> | undefined} [heads]
    * @returns {Array<any>}
    */
    keys(obj, heads) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_keys(retptr, this.__wbg_ptr, addHeapObject(obj), isLikeNone(heads) ? 0 : addHeapObject(heads));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} obj
    * @param {Array<any> | undefined} [heads]
    * @returns {string}
    */
    text(obj, heads) {
        let deferred2_0;
        let deferred2_1;
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_text(retptr, this.__wbg_ptr, addHeapObject(obj), isLikeNone(heads) ? 0 : addHeapObject(heads));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
            wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
    * @param {any} obj
    * @param {Array<any> | undefined} [heads]
    * @returns {Array<any>}
    */
    spans(obj, heads) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_spans(retptr, this.__wbg_ptr, addHeapObject(obj), isLikeNone(heads) ? 0 : addHeapObject(heads));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} obj
    * @param {number} start
    * @param {number} delete_count
    * @param {any} text
    */
    splice(obj, start, delete_count, text) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_splice(retptr, this.__wbg_ptr, addHeapObject(obj), start, delete_count, addHeapObject(text));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} obj
    * @param {any} new_text
    */
    updateText(obj, new_text) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_updateText(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(new_text));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} obj
    * @param {any} args
    */
    updateSpans(obj, args) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_updateSpans(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(args));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} obj
    * @param {any} value
    * @param {any} datatype
    */
    push(obj, value, datatype) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_push(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(value), addHeapObject(datatype));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} obj
    * @param {any} value
    * @returns {string | undefined}
    */
    pushObject(obj, value) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_pushObject(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(value));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm$1.__wbindgen_free(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} obj
    * @param {number} index
    * @param {any} value
    * @param {any} datatype
    */
    insert(obj, index, value, datatype) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_insert(retptr, this.__wbg_ptr, addHeapObject(obj), index, addHeapObject(value), addHeapObject(datatype));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} obj
    * @param {number} index
    * @param {any} args
    */
    splitBlock(obj, index, args) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_splitBlock(retptr, this.__wbg_ptr, addHeapObject(obj), index, addHeapObject(args));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} text
    * @param {number} index
    */
    joinBlock(text, index) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_joinBlock(retptr, this.__wbg_ptr, addHeapObject(text), index);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} text
    * @param {number} index
    * @param {any} args
    */
    updateBlock(text, index, args) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_updateBlock(retptr, this.__wbg_ptr, addHeapObject(text), index, addHeapObject(args));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} text
    * @param {number} index
    * @param {Array<any> | undefined} [heads]
    * @returns {any}
    */
    getBlock(text, index, heads) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_getBlock(retptr, this.__wbg_ptr, addHeapObject(text), index, isLikeNone(heads) ? 0 : addHeapObject(heads));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} obj
    * @param {number} index
    * @param {any} value
    * @returns {string | undefined}
    */
    insertObject(obj, index, value) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_insertObject(retptr, this.__wbg_ptr, addHeapObject(obj), index, addHeapObject(value));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            let v1;
            if (r0 !== 0) {
                v1 = getStringFromWasm0(r0, r1).slice();
                wasm$1.__wbindgen_free(r0, r1 * 1, 1);
            }
            return v1;
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} obj
    * @param {any} prop
    * @param {any} value
    * @param {any} datatype
    */
    put(obj, prop, value, datatype) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_put(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(prop), addHeapObject(value), addHeapObject(datatype));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} obj
    * @param {any} prop
    * @param {any} value
    * @returns {any}
    */
    putObject(obj, prop, value) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_putObject(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(prop), addHeapObject(value));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} obj
    * @param {any} prop
    * @param {any} value
    */
    increment(obj, prop, value) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_increment(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(prop), addHeapObject(value));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} obj
    * @param {any} prop
    * @param {Array<any> | undefined} [heads]
    * @returns {any}
    */
    get(obj, prop, heads) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_get(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(prop), isLikeNone(heads) ? 0 : addHeapObject(heads));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} obj
    * @param {any} prop
    * @param {Array<any> | undefined} [heads]
    * @returns {any}
    */
    getWithType(obj, prop, heads) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_getWithType(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(prop), isLikeNone(heads) ? 0 : addHeapObject(heads));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} obj
    * @param {Array<any> | undefined} [heads]
    * @returns {object}
    */
    objInfo(obj, heads) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_objInfo(retptr, this.__wbg_ptr, addHeapObject(obj), isLikeNone(heads) ? 0 : addHeapObject(heads));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} obj
    * @param {any} arg
    * @param {Array<any> | undefined} [heads]
    * @returns {Array<any>}
    */
    getAll(obj, arg, heads) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_getAll(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(arg), isLikeNone(heads) ? 0 : addHeapObject(heads));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} enable
    * @returns {any}
    */
    enableFreeze(enable) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_enableFreeze(retptr, this.__wbg_ptr, addHeapObject(enable));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} datatype
    * @param {any} export_function
    * @param {any} import_function
    */
    registerDatatype(datatype, export_function, import_function) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_registerDatatype(retptr, this.__wbg_ptr, addHeapObject(datatype), addHeapObject(export_function), addHeapObject(import_function));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} object
    * @param {any} meta
    * @returns {any}
    */
    applyPatches(object, meta) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_applyPatches(retptr, this.__wbg_ptr, addHeapObject(object), addHeapObject(meta));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} object
    * @param {any} meta
    * @returns {any}
    */
    applyAndReturnPatches(object, meta) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_applyAndReturnPatches(retptr, this.__wbg_ptr, addHeapObject(object), addHeapObject(meta));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Array<any>}
    */
    diffIncremental() {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_diffIncremental(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    */
    updateDiffCursor() {
        wasm$1.automerge_updateDiffCursor(this.__wbg_ptr);
    }
    /**
    */
    resetDiffCursor() {
        wasm$1.automerge_resetDiffCursor(this.__wbg_ptr);
    }
    /**
    * @param {Array<any>} before
    * @param {Array<any>} after
    * @returns {Array<any>}
    */
    diff(before, after) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_diff(retptr, this.__wbg_ptr, addHeapObject(before), addHeapObject(after));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Array<any>} heads
    */
    isolate(heads) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_isolate(retptr, this.__wbg_ptr, addHeapObject(heads));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    */
    integrate() {
        wasm$1.automerge_integrate(this.__wbg_ptr);
    }
    /**
    * @param {any} obj
    * @param {Array<any> | undefined} [heads]
    * @returns {number}
    */
    length(obj, heads) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_length(retptr, this.__wbg_ptr, addHeapObject(obj), isLikeNone(heads) ? 0 : addHeapObject(heads));
            var r0 = getFloat64Memory0()[retptr / 8 + 0];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            return r0;
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} obj
    * @param {any} prop
    */
    delete(obj, prop) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_delete(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(prop));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Uint8Array}
    */
    save() {
        const ret = wasm$1.automerge_save(this.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * @returns {Uint8Array}
    */
    saveIncremental() {
        const ret = wasm$1.automerge_saveIncremental(this.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * @param {Array<any>} heads
    * @returns {Uint8Array}
    */
    saveSince(heads) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_saveSince(retptr, this.__wbg_ptr, addHeapObject(heads));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Uint8Array}
    */
    saveNoCompress() {
        const ret = wasm$1.automerge_saveNoCompress(this.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * @returns {Uint8Array}
    */
    saveAndVerify() {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_saveAndVerify(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} data
    * @returns {number}
    */
    loadIncremental(data) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_loadIncremental(retptr, this.__wbg_ptr, addHeapObject(data));
            var r0 = getFloat64Memory0()[retptr / 8 + 0];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            return r0;
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} changes
    */
    applyChanges(changes) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_applyChanges(retptr, this.__wbg_ptr, addHeapObject(changes));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} have_deps
    * @returns {Array<any>}
    */
    getChanges(have_deps) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_getChanges(retptr, this.__wbg_ptr, addHeapObject(have_deps));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} hash
    * @returns {any}
    */
    getChangeByHash(hash) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_getChangeByHash(retptr, this.__wbg_ptr, addHeapObject(hash));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} hash
    * @returns {any}
    */
    getDecodedChangeByHash(hash) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_getDecodedChangeByHash(retptr, this.__wbg_ptr, addHeapObject(hash));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Automerge} other
    * @returns {Array<any>}
    */
    getChangesAdded(other) {
        _assertClass(other, Automerge);
        const ret = wasm$1.automerge_getChangesAdded(this.__wbg_ptr, other.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * @returns {Array<any>}
    */
    getHeads() {
        const ret = wasm$1.automerge_getHeads(this.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * @returns {string}
    */
    getActorId() {
        let deferred1_0;
        let deferred1_1;
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_getActorId(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            deferred1_0 = r0;
            deferred1_1 = r1;
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
            wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
    * @returns {any}
    */
    getLastLocalChange() {
        const ret = wasm$1.automerge_getLastLocalChange(this.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    */
    dump() {
        wasm$1.automerge_dump(this.__wbg_ptr);
    }
    /**
    * @param {Array<any> | undefined} [heads]
    * @returns {Array<any>}
    */
    getMissingDeps(heads) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_getMissingDeps(retptr, this.__wbg_ptr, isLikeNone(heads) ? 0 : addHeapObject(heads));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {SyncState} state
    * @param {Uint8Array} message
    */
    receiveSyncMessage(state, message) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(state, SyncState);
            wasm$1.automerge_receiveSyncMessage(retptr, this.__wbg_ptr, state.__wbg_ptr, addHeapObject(message));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {SyncState} state
    * @returns {any}
    */
    generateSyncMessage(state) {
        _assertClass(state, SyncState);
        const ret = wasm$1.automerge_generateSyncMessage(this.__wbg_ptr, state.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * @param {any} meta
    * @returns {any}
    */
    toJS(meta) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_toJS(retptr, this.__wbg_ptr, addHeapObject(meta));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} obj
    * @param {Array<any> | undefined} heads
    * @param {any} meta
    * @returns {any}
    */
    materialize(obj, heads, meta) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_materialize(retptr, this.__wbg_ptr, addHeapObject(obj), isLikeNone(heads) ? 0 : addHeapObject(heads), addHeapObject(meta));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} obj
    * @param {number} index
    * @param {Array<any> | undefined} [heads]
    * @returns {string}
    */
    getCursor(obj, index, heads) {
        let deferred2_0;
        let deferred2_1;
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_getCursor(retptr, this.__wbg_ptr, addHeapObject(obj), index, isLikeNone(heads) ? 0 : addHeapObject(heads));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr1 = r0;
            var len1 = r1;
            if (r3) {
                ptr1 = 0; len1 = 0;
                throw takeObject(r2);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
            wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
        }
    }
    /**
    * @param {any} obj
    * @param {any} cursor
    * @param {Array<any> | undefined} [heads]
    * @returns {number}
    */
    getCursorPosition(obj, cursor, heads) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_getCursorPosition(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(cursor), isLikeNone(heads) ? 0 : addHeapObject(heads));
            var r0 = getFloat64Memory0()[retptr / 8 + 0];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            return r0;
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {string | undefined} [message]
    * @param {number | undefined} [time]
    * @returns {any}
    */
    emptyChange(message, time) {
        var ptr0 = isLikeNone(message) ? 0 : passStringToWasm0(message, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm$1.automerge_emptyChange(this.__wbg_ptr, ptr0, len0, !isLikeNone(time), isLikeNone(time) ? 0 : time);
        return takeObject(ret);
    }
    /**
    * @param {any} obj
    * @param {any} range
    * @param {any} name
    * @param {any} value
    * @param {any} datatype
    */
    mark(obj, range, name, value, datatype) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_mark(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(range), addHeapObject(name), addHeapObject(value), addHeapObject(datatype));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} obj
    * @param {any} range
    * @param {any} name
    */
    unmark(obj, range, name) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_unmark(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(range), addHeapObject(name));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} obj
    * @param {Array<any> | undefined} [heads]
    * @returns {any}
    */
    marks(obj, heads) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_marks(retptr, this.__wbg_ptr, addHeapObject(obj), isLikeNone(heads) ? 0 : addHeapObject(heads));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} obj
    * @param {number} index
    * @param {Array<any> | undefined} [heads]
    * @returns {object}
    */
    marksAt(obj, index, heads) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.automerge_marksAt(retptr, this.__wbg_ptr, addHeapObject(obj), index, isLikeNone(heads) ? 0 : addHeapObject(heads));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {SyncState} state
    * @returns {any}
    */
    hasOurChanges(state) {
        _assertClass(state, SyncState);
        const ret = wasm$1.automerge_hasOurChanges(this.__wbg_ptr, state.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * @returns {any}
    */
    topoHistoryTraversal() {
        const ret = wasm$1.automerge_topoHistoryTraversal(this.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * @returns {any}
    */
    stats() {
        const ret = wasm$1.automerge_stats(this.__wbg_ptr);
        return takeObject(ret);
    }
}

const SyncStateFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_syncstate_free(ptr >>> 0));
/**
*/
class SyncState {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(SyncState.prototype);
        obj.__wbg_ptr = ptr;
        SyncStateFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SyncStateFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_syncstate_free(ptr);
    }
    /**
    * @returns {any}
    */
    get sharedHeads() {
        const ret = wasm$1.syncstate_sharedHeads(this.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * @returns {any}
    */
    get lastSentHeads() {
        const ret = wasm$1.syncstate_lastSentHeads(this.__wbg_ptr);
        return takeObject(ret);
    }
    /**
    * @param {any} heads
    */
    set lastSentHeads(heads) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.syncstate_set_lastSentHeads(retptr, this.__wbg_ptr, addHeapObject(heads));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {any} hashes
    */
    set sentHashes(hashes) {
        try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.syncstate_set_sentHashes(retptr, this.__wbg_ptr, addHeapObject(hashes));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {SyncState}
    */
    clone() {
        const ret = wasm$1.syncstate_clone(this.__wbg_ptr);
        return SyncState.__wrap(ret);
    }
}

function __wbindgen_object_drop_ref(arg0) {
    takeObject(arg0);
}
function __wbindgen_string_get(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = typeof(obj) === 'string' ? obj : undefined;
    var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
    var len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
}
function __wbindgen_error_new(arg0, arg1) {
    const ret = new Error(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
}
function __wbindgen_string_new(arg0, arg1) {
    const ret = getStringFromWasm0(arg0, arg1);
    return addHeapObject(ret);
}
function __wbindgen_number_new(arg0) {
    const ret = arg0;
    return addHeapObject(ret);
}
function __wbindgen_object_clone_ref(arg0) {
    const ret = getObject(arg0);
    return addHeapObject(ret);
}
function __wbindgen_number_get(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = typeof(obj) === 'number' ? obj : undefined;
    getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;
    getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);
}
function __wbindgen_is_undefined(arg0) {
    const ret = getObject(arg0) === undefined;
    return ret;
}
function __wbindgen_boolean_get(arg0) {
    const v = getObject(arg0);
    const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;
    return ret;
}
function __wbindgen_is_null(arg0) {
    const ret = getObject(arg0) === null;
    return ret;
}
function __wbindgen_is_string(arg0) {
    const ret = typeof(getObject(arg0)) === 'string';
    return ret;
}
function __wbindgen_is_function(arg0) {
    const ret = typeof(getObject(arg0)) === 'function';
    return ret;
}
function __wbindgen_is_object(arg0) {
    const val = getObject(arg0);
    const ret = typeof(val) === 'object' && val !== null;
    return ret;
}
function __wbindgen_is_array(arg0) {
    const ret = Array.isArray(getObject(arg0));
    return ret;
}
function __wbindgen_json_serialize(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = JSON.stringify(obj === undefined ? null : obj);
    const ptr1 = passStringToWasm0(ret, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
}
function __wbg_new_abda76e883ba8a5f() {
    const ret = new Error();
    return addHeapObject(ret);
}
function __wbg_stack_658279fe44541cf6(arg0, arg1) {
    const ret = getObject(arg1).stack;
    const ptr1 = passStringToWasm0(ret, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
}
function __wbg_error_f851667af71bcfc6(arg0, arg1) {
    let deferred0_0;
    let deferred0_1;
    try {
        deferred0_0 = arg0;
        deferred0_1 = arg1;
        console.error(getStringFromWasm0(arg0, arg1));
    } finally {
        wasm$1.__wbindgen_free(deferred0_0, deferred0_1, 1);
    }
}
function __wbindgen_jsval_loose_eq(arg0, arg1) {
    const ret = getObject(arg0) == getObject(arg1);
    return ret;
}
function __wbg_String_91fba7ded13ba54c(arg0, arg1) {
    const ret = String(getObject(arg1));
    const ptr1 = passStringToWasm0(ret, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
}
function __wbindgen_bigint_from_i64(arg0) {
    const ret = arg0;
    return addHeapObject(ret);
}
function __wbindgen_bigint_from_u64(arg0) {
    const ret = BigInt.asUintN(64, arg0);
    return addHeapObject(ret);
}
function __wbg_set_20cbc34131e76824(arg0, arg1, arg2) {
    getObject(arg0)[takeObject(arg1)] = takeObject(arg2);
}
function __wbg_getRandomValues_3aa56aa6edec874c() { return handleError(function (arg0, arg1) {
    getObject(arg0).getRandomValues(getObject(arg1));
}, arguments) }
function __wbg_randomFillSync_5c9c955aa56b6049() { return handleError(function (arg0, arg1) {
    getObject(arg0).randomFillSync(takeObject(arg1));
}, arguments) }
function __wbg_crypto_1d1f22824a6a080c(arg0) {
    const ret = getObject(arg0).crypto;
    return addHeapObject(ret);
}
function __wbg_process_4a72847cc503995b(arg0) {
    const ret = getObject(arg0).process;
    return addHeapObject(ret);
}
function __wbg_versions_f686565e586dd935(arg0) {
    const ret = getObject(arg0).versions;
    return addHeapObject(ret);
}
function __wbg_node_104a2ff8d6ea03a2(arg0) {
    const ret = getObject(arg0).node;
    return addHeapObject(ret);
}
function __wbg_require_cca90b1a94a0255b() { return handleError(function () {
    const ret = module.require;
    return addHeapObject(ret);
}, arguments) }
function __wbg_msCrypto_eb05e62b530a1508(arg0) {
    const ret = getObject(arg0).msCrypto;
    return addHeapObject(ret);
}
function __wbg_log_5bb5f88f245d7762(arg0) {
    console.log(getObject(arg0));
}
function __wbg_log_1746d5c75ec89963(arg0, arg1) {
    console.log(getObject(arg0), getObject(arg1));
}
function __wbg_get_bd8e338fbd5f5cc8(arg0, arg1) {
    const ret = getObject(arg0)[arg1 >>> 0];
    return addHeapObject(ret);
}
function __wbg_length_cd7af8117672b8b8(arg0) {
    const ret = getObject(arg0).length;
    return ret;
}
function __wbg_new_16b304a2cfa7ff4a() {
    const ret = new Array();
    return addHeapObject(ret);
}
function __wbg_newnoargs_e258087cd0daa0ea(arg0, arg1) {
    const ret = new Function(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
}
function __wbg_next_40fc327bfc8770e6(arg0) {
    const ret = getObject(arg0).next;
    return addHeapObject(ret);
}
function __wbg_next_196c84450b364254() { return handleError(function (arg0) {
    const ret = getObject(arg0).next();
    return addHeapObject(ret);
}, arguments) }
function __wbg_done_298b57d23c0fc80c(arg0) {
    const ret = getObject(arg0).done;
    return ret;
}
function __wbg_value_d93c65011f51a456(arg0) {
    const ret = getObject(arg0).value;
    return addHeapObject(ret);
}
function __wbg_iterator_2cee6dadfd956dfa() {
    const ret = Symbol.iterator;
    return addHeapObject(ret);
}
function __wbg_get_e3c254076557e348() { return handleError(function (arg0, arg1) {
    const ret = Reflect.get(getObject(arg0), getObject(arg1));
    return addHeapObject(ret);
}, arguments) }
function __wbg_call_27c0f87801dedf93() { return handleError(function (arg0, arg1) {
    const ret = getObject(arg0).call(getObject(arg1));
    return addHeapObject(ret);
}, arguments) }
function __wbg_new_72fb9a18b5ae2624() {
    const ret = new Object();
    return addHeapObject(ret);
}
function __wbg_length_dee433d4c85c9387(arg0) {
    const ret = getObject(arg0).length;
    return ret;
}
function __wbg_set_d4638f722068f043(arg0, arg1, arg2) {
    getObject(arg0)[arg1 >>> 0] = takeObject(arg2);
}
function __wbg_from_89e3fc3ba5e6fb48(arg0) {
    const ret = Array.from(getObject(arg0));
    return addHeapObject(ret);
}
function __wbg_isArray_2ab64d95e09ea0ae(arg0) {
    const ret = Array.isArray(getObject(arg0));
    return ret;
}
function __wbg_push_a5b05aedc7234f9f(arg0, arg1) {
    const ret = getObject(arg0).push(getObject(arg1));
    return ret;
}
function __wbg_unshift_e22df4b34bcf5070(arg0, arg1) {
    const ret = getObject(arg0).unshift(getObject(arg1));
    return ret;
}
function __wbg_instanceof_ArrayBuffer_836825be07d4c9d2(arg0) {
    let result;
    try {
        result = getObject(arg0) instanceof ArrayBuffer;
    } catch (_) {
        result = false;
    }
    const ret = result;
    return ret;
}
function __wbg_new_28c511d9baebfa89(arg0, arg1) {
    const ret = new Error(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
}
function __wbg_call_b3ca7c6051f9bec1() { return handleError(function (arg0, arg1, arg2) {
    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));
    return addHeapObject(ret);
}, arguments) }
function __wbg_instanceof_Date_f65cf97fb83fc369(arg0) {
    let result;
    try {
        result = getObject(arg0) instanceof Date;
    } catch (_) {
        result = false;
    }
    const ret = result;
    return ret;
}
function __wbg_getTime_2bc4375165f02d15(arg0) {
    const ret = getObject(arg0).getTime();
    return ret;
}
function __wbg_new_cf3ec55744a78578(arg0) {
    const ret = new Date(getObject(arg0));
    return addHeapObject(ret);
}
function __wbg_instanceof_Object_71ca3c0a59266746(arg0) {
    let result;
    try {
        result = getObject(arg0) instanceof Object;
    } catch (_) {
        result = false;
    }
    const ret = result;
    return ret;
}
function __wbg_assign_496d2d14fecafbcf(arg0, arg1) {
    const ret = Object.assign(getObject(arg0), getObject(arg1));
    return addHeapObject(ret);
}
function __wbg_defineProperty_cc00e2de8a0f5141(arg0, arg1, arg2) {
    const ret = Object.defineProperty(getObject(arg0), getObject(arg1), getObject(arg2));
    return addHeapObject(ret);
}
function __wbg_entries_95cc2c823b285a09(arg0) {
    const ret = Object.entries(getObject(arg0));
    return addHeapObject(ret);
}
function __wbg_freeze_cc6bc19f75299986(arg0) {
    const ret = Object.freeze(getObject(arg0));
    return addHeapObject(ret);
}
function __wbg_keys_91e412b4b222659f(arg0) {
    const ret = Object.keys(getObject(arg0));
    return addHeapObject(ret);
}
function __wbg_values_9c75e6e2bfbdb70d(arg0) {
    const ret = Object.values(getObject(arg0));
    return addHeapObject(ret);
}
function __wbg_new_dd6a5dd7b538af21(arg0, arg1) {
    const ret = new RangeError(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
}
function __wbg_apply_0a5aa603881e6d79() { return handleError(function (arg0, arg1, arg2) {
    const ret = Reflect.apply(getObject(arg0), getObject(arg1), getObject(arg2));
    return addHeapObject(ret);
}, arguments) }
function __wbg_deleteProperty_13e721a56f19e842() { return handleError(function (arg0, arg1) {
    const ret = Reflect.deleteProperty(getObject(arg0), getObject(arg1));
    return ret;
}, arguments) }
function __wbg_ownKeys_658942b7f28d1fe9() { return handleError(function (arg0) {
    const ret = Reflect.ownKeys(getObject(arg0));
    return addHeapObject(ret);
}, arguments) }
function __wbg_set_1f9b04f170055d33() { return handleError(function (arg0, arg1, arg2) {
    const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));
    return ret;
}, arguments) }
function __wbg_buffer_12d079cc21e14bdb(arg0) {
    const ret = getObject(arg0).buffer;
    return addHeapObject(ret);
}
function __wbg_concat_3de229fe4fe90fea(arg0, arg1) {
    const ret = getObject(arg0).concat(getObject(arg1));
    return addHeapObject(ret);
}
function __wbg_slice_52fb626ffdc8da8f(arg0, arg1, arg2) {
    const ret = getObject(arg0).slice(arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
}
function __wbg_for_27c67e2dbdce22f6(arg0, arg1) {
    const ret = Symbol.for(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
}
function __wbg_toString_7df3c77999517c20(arg0) {
    const ret = getObject(arg0).toString();
    return addHeapObject(ret);
}
function __wbg_self_ce0dbfc45cf2f5be() { return handleError(function () {
    const ret = self.self;
    return addHeapObject(ret);
}, arguments) }
function __wbg_window_c6fb939a7f436783() { return handleError(function () {
    const ret = window.window;
    return addHeapObject(ret);
}, arguments) }
function __wbg_globalThis_d1e6af4856ba331b() { return handleError(function () {
    const ret = globalThis.globalThis;
    return addHeapObject(ret);
}, arguments) }
function __wbg_global_207b558942527489() { return handleError(function () {
    const ret = global.global;
    return addHeapObject(ret);
}, arguments) }
function __wbg_newwithbyteoffsetandlength_aa4a17c33a06e5cb(arg0, arg1, arg2) {
    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
}
function __wbg_new_63b92bc8671ed464(arg0) {
    const ret = new Uint8Array(getObject(arg0));
    return addHeapObject(ret);
}
function __wbg_set_a47bac70306a19a7(arg0, arg1, arg2) {
    getObject(arg0).set(getObject(arg1), arg2 >>> 0);
}
function __wbg_length_c20a40f15020d68a(arg0) {
    const ret = getObject(arg0).length;
    return ret;
}
function __wbg_instanceof_Uint8Array_2b3bbecd033d19f6(arg0) {
    let result;
    try {
        result = getObject(arg0) instanceof Uint8Array;
    } catch (_) {
        result = false;
    }
    const ret = result;
    return ret;
}
function __wbg_newwithlength_e9b4878cebadb3d3(arg0) {
    const ret = new Uint8Array(arg0 >>> 0);
    return addHeapObject(ret);
}
function __wbg_subarray_a1f73cd4b5b42fe1(arg0, arg1, arg2) {
    const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
}
function __wbindgen_debug_string(arg0, arg1) {
    const ret = debugString(getObject(arg1));
    const ptr1 = passStringToWasm0(ret, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
}
function __wbindgen_throw(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
}
function __wbindgen_memory() {
    const ret = wasm$1.memory;
    return addHeapObject(ret);
}

URL = globalThis.URL;
const __vite__wasmModule = await __vite__initWasm({ "./automerge_wasm_bg.js": { "__wbindgen_object_drop_ref": __wbindgen_object_drop_ref,
"__wbindgen_string_get": __wbindgen_string_get,
"__wbindgen_error_new": __wbindgen_error_new,
"__wbindgen_string_new": __wbindgen_string_new,
"__wbindgen_number_new": __wbindgen_number_new,
"__wbindgen_object_clone_ref": __wbindgen_object_clone_ref,
"__wbindgen_number_get": __wbindgen_number_get,
"__wbindgen_is_undefined": __wbindgen_is_undefined,
"__wbindgen_boolean_get": __wbindgen_boolean_get,
"__wbindgen_is_null": __wbindgen_is_null,
"__wbindgen_is_string": __wbindgen_is_string,
"__wbindgen_is_function": __wbindgen_is_function,
"__wbindgen_is_object": __wbindgen_is_object,
"__wbindgen_is_array": __wbindgen_is_array,
"__wbindgen_json_serialize": __wbindgen_json_serialize,
"__wbg_new_abda76e883ba8a5f": __wbg_new_abda76e883ba8a5f,
"__wbg_stack_658279fe44541cf6": __wbg_stack_658279fe44541cf6,
"__wbg_error_f851667af71bcfc6": __wbg_error_f851667af71bcfc6,
"__wbindgen_jsval_loose_eq": __wbindgen_jsval_loose_eq,
"__wbg_String_91fba7ded13ba54c": __wbg_String_91fba7ded13ba54c,
"__wbindgen_bigint_from_i64": __wbindgen_bigint_from_i64,
"__wbindgen_bigint_from_u64": __wbindgen_bigint_from_u64,
"__wbg_set_20cbc34131e76824": __wbg_set_20cbc34131e76824,
"__wbg_getRandomValues_3aa56aa6edec874c": __wbg_getRandomValues_3aa56aa6edec874c,
"__wbg_randomFillSync_5c9c955aa56b6049": __wbg_randomFillSync_5c9c955aa56b6049,
"__wbg_crypto_1d1f22824a6a080c": __wbg_crypto_1d1f22824a6a080c,
"__wbg_process_4a72847cc503995b": __wbg_process_4a72847cc503995b,
"__wbg_versions_f686565e586dd935": __wbg_versions_f686565e586dd935,
"__wbg_node_104a2ff8d6ea03a2": __wbg_node_104a2ff8d6ea03a2,
"__wbg_require_cca90b1a94a0255b": __wbg_require_cca90b1a94a0255b,
"__wbg_msCrypto_eb05e62b530a1508": __wbg_msCrypto_eb05e62b530a1508,
"__wbg_log_5bb5f88f245d7762": __wbg_log_5bb5f88f245d7762,
"__wbg_log_1746d5c75ec89963": __wbg_log_1746d5c75ec89963,
"__wbg_get_bd8e338fbd5f5cc8": __wbg_get_bd8e338fbd5f5cc8,
"__wbg_length_cd7af8117672b8b8": __wbg_length_cd7af8117672b8b8,
"__wbg_new_16b304a2cfa7ff4a": __wbg_new_16b304a2cfa7ff4a,
"__wbg_newnoargs_e258087cd0daa0ea": __wbg_newnoargs_e258087cd0daa0ea,
"__wbg_next_40fc327bfc8770e6": __wbg_next_40fc327bfc8770e6,
"__wbg_next_196c84450b364254": __wbg_next_196c84450b364254,
"__wbg_done_298b57d23c0fc80c": __wbg_done_298b57d23c0fc80c,
"__wbg_value_d93c65011f51a456": __wbg_value_d93c65011f51a456,
"__wbg_iterator_2cee6dadfd956dfa": __wbg_iterator_2cee6dadfd956dfa,
"__wbg_get_e3c254076557e348": __wbg_get_e3c254076557e348,
"__wbg_call_27c0f87801dedf93": __wbg_call_27c0f87801dedf93,
"__wbg_new_72fb9a18b5ae2624": __wbg_new_72fb9a18b5ae2624,
"__wbg_length_dee433d4c85c9387": __wbg_length_dee433d4c85c9387,
"__wbg_set_d4638f722068f043": __wbg_set_d4638f722068f043,
"__wbg_from_89e3fc3ba5e6fb48": __wbg_from_89e3fc3ba5e6fb48,
"__wbg_isArray_2ab64d95e09ea0ae": __wbg_isArray_2ab64d95e09ea0ae,
"__wbg_push_a5b05aedc7234f9f": __wbg_push_a5b05aedc7234f9f,
"__wbg_unshift_e22df4b34bcf5070": __wbg_unshift_e22df4b34bcf5070,
"__wbg_instanceof_ArrayBuffer_836825be07d4c9d2": __wbg_instanceof_ArrayBuffer_836825be07d4c9d2,
"__wbg_new_28c511d9baebfa89": __wbg_new_28c511d9baebfa89,
"__wbg_call_b3ca7c6051f9bec1": __wbg_call_b3ca7c6051f9bec1,
"__wbg_instanceof_Date_f65cf97fb83fc369": __wbg_instanceof_Date_f65cf97fb83fc369,
"__wbg_getTime_2bc4375165f02d15": __wbg_getTime_2bc4375165f02d15,
"__wbg_new_cf3ec55744a78578": __wbg_new_cf3ec55744a78578,
"__wbg_instanceof_Object_71ca3c0a59266746": __wbg_instanceof_Object_71ca3c0a59266746,
"__wbg_assign_496d2d14fecafbcf": __wbg_assign_496d2d14fecafbcf,
"__wbg_defineProperty_cc00e2de8a0f5141": __wbg_defineProperty_cc00e2de8a0f5141,
"__wbg_entries_95cc2c823b285a09": __wbg_entries_95cc2c823b285a09,
"__wbg_freeze_cc6bc19f75299986": __wbg_freeze_cc6bc19f75299986,
"__wbg_keys_91e412b4b222659f": __wbg_keys_91e412b4b222659f,
"__wbg_values_9c75e6e2bfbdb70d": __wbg_values_9c75e6e2bfbdb70d,
"__wbg_new_dd6a5dd7b538af21": __wbg_new_dd6a5dd7b538af21,
"__wbg_apply_0a5aa603881e6d79": __wbg_apply_0a5aa603881e6d79,
"__wbg_deleteProperty_13e721a56f19e842": __wbg_deleteProperty_13e721a56f19e842,
"__wbg_ownKeys_658942b7f28d1fe9": __wbg_ownKeys_658942b7f28d1fe9,
"__wbg_set_1f9b04f170055d33": __wbg_set_1f9b04f170055d33,
"__wbg_buffer_12d079cc21e14bdb": __wbg_buffer_12d079cc21e14bdb,
"__wbg_concat_3de229fe4fe90fea": __wbg_concat_3de229fe4fe90fea,
"__wbg_slice_52fb626ffdc8da8f": __wbg_slice_52fb626ffdc8da8f,
"__wbg_for_27c67e2dbdce22f6": __wbg_for_27c67e2dbdce22f6,
"__wbg_toString_7df3c77999517c20": __wbg_toString_7df3c77999517c20,
"__wbg_self_ce0dbfc45cf2f5be": __wbg_self_ce0dbfc45cf2f5be,
"__wbg_window_c6fb939a7f436783": __wbg_window_c6fb939a7f436783,
"__wbg_globalThis_d1e6af4856ba331b": __wbg_globalThis_d1e6af4856ba331b,
"__wbg_global_207b558942527489": __wbg_global_207b558942527489,
"__wbg_newwithbyteoffsetandlength_aa4a17c33a06e5cb": __wbg_newwithbyteoffsetandlength_aa4a17c33a06e5cb,
"__wbg_new_63b92bc8671ed464": __wbg_new_63b92bc8671ed464,
"__wbg_set_a47bac70306a19a7": __wbg_set_a47bac70306a19a7,
"__wbg_length_c20a40f15020d68a": __wbg_length_c20a40f15020d68a,
"__wbg_instanceof_Uint8Array_2b3bbecd033d19f6": __wbg_instanceof_Uint8Array_2b3bbecd033d19f6,
"__wbg_newwithlength_e9b4878cebadb3d3": __wbg_newwithlength_e9b4878cebadb3d3,
"__wbg_subarray_a1f73cd4b5b42fe1": __wbg_subarray_a1f73cd4b5b42fe1,
"__wbindgen_debug_string": __wbindgen_debug_string,
"__wbindgen_throw": __wbindgen_throw,
"__wbindgen_memory": __wbindgen_memory } }, __vite__wasmUrl);
const memory = __vite__wasmModule.memory;
const __wbg_syncstate_free = __vite__wasmModule.__wbg_syncstate_free;
const syncstate_sharedHeads = __vite__wasmModule.syncstate_sharedHeads;
const syncstate_lastSentHeads = __vite__wasmModule.syncstate_lastSentHeads;
const syncstate_set_lastSentHeads = __vite__wasmModule.syncstate_set_lastSentHeads;
const syncstate_set_sentHashes = __vite__wasmModule.syncstate_set_sentHashes;
const syncstate_clone = __vite__wasmModule.syncstate_clone;
const __wbg_automerge_free = __vite__wasmModule.__wbg_automerge_free;
const automerge_new = __vite__wasmModule.automerge_new;
const automerge_clone = __vite__wasmModule.automerge_clone;
const automerge_fork = __vite__wasmModule.automerge_fork;
const automerge_pendingOps = __vite__wasmModule.automerge_pendingOps;
const automerge_commit = __vite__wasmModule.automerge_commit;
const automerge_merge = __vite__wasmModule.automerge_merge;
const automerge_rollback = __vite__wasmModule.automerge_rollback;
const automerge_keys = __vite__wasmModule.automerge_keys;
const automerge_text = __vite__wasmModule.automerge_text;
const automerge_spans = __vite__wasmModule.automerge_spans;
const automerge_splice = __vite__wasmModule.automerge_splice;
const automerge_updateText = __vite__wasmModule.automerge_updateText;
const automerge_updateSpans = __vite__wasmModule.automerge_updateSpans;
const automerge_push = __vite__wasmModule.automerge_push;
const automerge_pushObject = __vite__wasmModule.automerge_pushObject;
const automerge_insert = __vite__wasmModule.automerge_insert;
const automerge_splitBlock = __vite__wasmModule.automerge_splitBlock;
const automerge_joinBlock = __vite__wasmModule.automerge_joinBlock;
const automerge_updateBlock = __vite__wasmModule.automerge_updateBlock;
const automerge_getBlock = __vite__wasmModule.automerge_getBlock;
const automerge_insertObject = __vite__wasmModule.automerge_insertObject;
const automerge_put = __vite__wasmModule.automerge_put;
const automerge_putObject = __vite__wasmModule.automerge_putObject;
const automerge_increment = __vite__wasmModule.automerge_increment;
const automerge_get = __vite__wasmModule.automerge_get;
const automerge_getWithType = __vite__wasmModule.automerge_getWithType;
const automerge_objInfo = __vite__wasmModule.automerge_objInfo;
const automerge_getAll = __vite__wasmModule.automerge_getAll;
const automerge_enableFreeze = __vite__wasmModule.automerge_enableFreeze;
const automerge_registerDatatype = __vite__wasmModule.automerge_registerDatatype;
const automerge_applyPatches = __vite__wasmModule.automerge_applyPatches;
const automerge_applyAndReturnPatches = __vite__wasmModule.automerge_applyAndReturnPatches;
const automerge_diffIncremental = __vite__wasmModule.automerge_diffIncremental;
const automerge_updateDiffCursor = __vite__wasmModule.automerge_updateDiffCursor;
const automerge_resetDiffCursor = __vite__wasmModule.automerge_resetDiffCursor;
const automerge_diff = __vite__wasmModule.automerge_diff;
const automerge_isolate = __vite__wasmModule.automerge_isolate;
const automerge_integrate = __vite__wasmModule.automerge_integrate;
const automerge_length = __vite__wasmModule.automerge_length;
const automerge_delete = __vite__wasmModule.automerge_delete;
const automerge_save = __vite__wasmModule.automerge_save;
const automerge_saveIncremental = __vite__wasmModule.automerge_saveIncremental;
const automerge_saveSince = __vite__wasmModule.automerge_saveSince;
const automerge_saveNoCompress = __vite__wasmModule.automerge_saveNoCompress;
const automerge_saveAndVerify = __vite__wasmModule.automerge_saveAndVerify;
const automerge_loadIncremental = __vite__wasmModule.automerge_loadIncremental;
const automerge_applyChanges = __vite__wasmModule.automerge_applyChanges;
const automerge_getChanges = __vite__wasmModule.automerge_getChanges;
const automerge_getChangeByHash = __vite__wasmModule.automerge_getChangeByHash;
const automerge_getDecodedChangeByHash = __vite__wasmModule.automerge_getDecodedChangeByHash;
const automerge_getChangesAdded = __vite__wasmModule.automerge_getChangesAdded;
const automerge_getHeads = __vite__wasmModule.automerge_getHeads;
const automerge_getActorId = __vite__wasmModule.automerge_getActorId;
const automerge_getLastLocalChange = __vite__wasmModule.automerge_getLastLocalChange;
const automerge_dump = __vite__wasmModule.automerge_dump;
const automerge_getMissingDeps = __vite__wasmModule.automerge_getMissingDeps;
const automerge_receiveSyncMessage = __vite__wasmModule.automerge_receiveSyncMessage;
const automerge_generateSyncMessage = __vite__wasmModule.automerge_generateSyncMessage;
const automerge_toJS = __vite__wasmModule.automerge_toJS;
const automerge_materialize = __vite__wasmModule.automerge_materialize;
const automerge_getCursor = __vite__wasmModule.automerge_getCursor;
const automerge_getCursorPosition = __vite__wasmModule.automerge_getCursorPosition;
const automerge_emptyChange = __vite__wasmModule.automerge_emptyChange;
const automerge_mark = __vite__wasmModule.automerge_mark;
const automerge_unmark = __vite__wasmModule.automerge_unmark;
const automerge_marks = __vite__wasmModule.automerge_marks;
const automerge_marksAt = __vite__wasmModule.automerge_marksAt;
const automerge_hasOurChanges = __vite__wasmModule.automerge_hasOurChanges;
const automerge_topoHistoryTraversal = __vite__wasmModule.automerge_topoHistoryTraversal;
const automerge_stats = __vite__wasmModule.automerge_stats;
const create = __vite__wasmModule.create;
const load = __vite__wasmModule.load;
const encodeChange = __vite__wasmModule.encodeChange;
const decodeChange = __vite__wasmModule.decodeChange;
const initSyncState = __vite__wasmModule.initSyncState;
const importSyncState = __vite__wasmModule.importSyncState;
const exportSyncState = __vite__wasmModule.exportSyncState;
const encodeSyncMessage = __vite__wasmModule.encodeSyncMessage;
const decodeSyncMessage = __vite__wasmModule.decodeSyncMessage;
const encodeSyncState = __vite__wasmModule.encodeSyncState;
const decodeSyncState = __vite__wasmModule.decodeSyncState;
const __wbindgen_malloc = __vite__wasmModule.__wbindgen_malloc;
const __wbindgen_realloc = __vite__wasmModule.__wbindgen_realloc;
const __wbindgen_add_to_stack_pointer = __vite__wasmModule.__wbindgen_add_to_stack_pointer;
const __wbindgen_free = __vite__wasmModule.__wbindgen_free;
const __wbindgen_exn_store = __vite__wasmModule.__wbindgen_exn_store;

const wasm = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  __wbg_automerge_free,
  __wbg_syncstate_free,
  __wbindgen_add_to_stack_pointer,
  __wbindgen_exn_store,
  __wbindgen_free,
  __wbindgen_malloc,
  __wbindgen_realloc,
  automerge_applyAndReturnPatches,
  automerge_applyChanges,
  automerge_applyPatches,
  automerge_clone,
  automerge_commit,
  automerge_delete,
  automerge_diff,
  automerge_diffIncremental,
  automerge_dump,
  automerge_emptyChange,
  automerge_enableFreeze,
  automerge_fork,
  automerge_generateSyncMessage,
  automerge_get,
  automerge_getActorId,
  automerge_getAll,
  automerge_getBlock,
  automerge_getChangeByHash,
  automerge_getChanges,
  automerge_getChangesAdded,
  automerge_getCursor,
  automerge_getCursorPosition,
  automerge_getDecodedChangeByHash,
  automerge_getHeads,
  automerge_getLastLocalChange,
  automerge_getMissingDeps,
  automerge_getWithType,
  automerge_hasOurChanges,
  automerge_increment,
  automerge_insert,
  automerge_insertObject,
  automerge_integrate,
  automerge_isolate,
  automerge_joinBlock,
  automerge_keys,
  automerge_length,
  automerge_loadIncremental,
  automerge_mark,
  automerge_marks,
  automerge_marksAt,
  automerge_materialize,
  automerge_merge,
  automerge_new,
  automerge_objInfo,
  automerge_pendingOps,
  automerge_push,
  automerge_pushObject,
  automerge_put,
  automerge_putObject,
  automerge_receiveSyncMessage,
  automerge_registerDatatype,
  automerge_resetDiffCursor,
  automerge_rollback,
  automerge_save,
  automerge_saveAndVerify,
  automerge_saveIncremental,
  automerge_saveNoCompress,
  automerge_saveSince,
  automerge_spans,
  automerge_splice,
  automerge_splitBlock,
  automerge_stats,
  automerge_text,
  automerge_toJS,
  automerge_topoHistoryTraversal,
  automerge_unmark,
  automerge_updateBlock,
  automerge_updateDiffCursor,
  automerge_updateSpans,
  automerge_updateText,
  create,
  decodeChange,
  decodeSyncMessage,
  decodeSyncState,
  encodeChange,
  encodeSyncMessage,
  encodeSyncState,
  exportSyncState,
  importSyncState,
  initSyncState,
  load,
  memory,
  syncstate_clone,
  syncstate_lastSentHeads,
  syncstate_set_lastSentHeads,
  syncstate_set_sentHashes,
  syncstate_sharedHeads
}, Symbol.toStringTag, { value: 'Module' }));

__wbg_set_wasm(wasm);

const api = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Automerge,
  SyncState,
  TextRepresentation,
  __wbg_String_91fba7ded13ba54c,
  __wbg_apply_0a5aa603881e6d79,
  __wbg_assign_496d2d14fecafbcf,
  __wbg_buffer_12d079cc21e14bdb,
  __wbg_call_27c0f87801dedf93,
  __wbg_call_b3ca7c6051f9bec1,
  __wbg_concat_3de229fe4fe90fea,
  __wbg_crypto_1d1f22824a6a080c,
  __wbg_defineProperty_cc00e2de8a0f5141,
  __wbg_deleteProperty_13e721a56f19e842,
  __wbg_done_298b57d23c0fc80c,
  __wbg_entries_95cc2c823b285a09,
  __wbg_error_f851667af71bcfc6,
  __wbg_for_27c67e2dbdce22f6,
  __wbg_freeze_cc6bc19f75299986,
  __wbg_from_89e3fc3ba5e6fb48,
  __wbg_getRandomValues_3aa56aa6edec874c,
  __wbg_getTime_2bc4375165f02d15,
  __wbg_get_bd8e338fbd5f5cc8,
  __wbg_get_e3c254076557e348,
  __wbg_globalThis_d1e6af4856ba331b,
  __wbg_global_207b558942527489,
  __wbg_instanceof_ArrayBuffer_836825be07d4c9d2,
  __wbg_instanceof_Date_f65cf97fb83fc369,
  __wbg_instanceof_Object_71ca3c0a59266746,
  __wbg_instanceof_Uint8Array_2b3bbecd033d19f6,
  __wbg_isArray_2ab64d95e09ea0ae,
  __wbg_iterator_2cee6dadfd956dfa,
  __wbg_keys_91e412b4b222659f,
  __wbg_length_c20a40f15020d68a,
  __wbg_length_cd7af8117672b8b8,
  __wbg_length_dee433d4c85c9387,
  __wbg_log_1746d5c75ec89963,
  __wbg_log_5bb5f88f245d7762,
  __wbg_msCrypto_eb05e62b530a1508,
  __wbg_new_16b304a2cfa7ff4a,
  __wbg_new_28c511d9baebfa89,
  __wbg_new_63b92bc8671ed464,
  __wbg_new_72fb9a18b5ae2624,
  __wbg_new_abda76e883ba8a5f,
  __wbg_new_cf3ec55744a78578,
  __wbg_new_dd6a5dd7b538af21,
  __wbg_newnoargs_e258087cd0daa0ea,
  __wbg_newwithbyteoffsetandlength_aa4a17c33a06e5cb,
  __wbg_newwithlength_e9b4878cebadb3d3,
  __wbg_next_196c84450b364254,
  __wbg_next_40fc327bfc8770e6,
  __wbg_node_104a2ff8d6ea03a2,
  __wbg_ownKeys_658942b7f28d1fe9,
  __wbg_process_4a72847cc503995b,
  __wbg_push_a5b05aedc7234f9f,
  __wbg_randomFillSync_5c9c955aa56b6049,
  __wbg_require_cca90b1a94a0255b,
  __wbg_self_ce0dbfc45cf2f5be,
  __wbg_set_1f9b04f170055d33,
  __wbg_set_20cbc34131e76824,
  __wbg_set_a47bac70306a19a7,
  __wbg_set_d4638f722068f043,
  __wbg_set_wasm,
  __wbg_slice_52fb626ffdc8da8f,
  __wbg_stack_658279fe44541cf6,
  __wbg_subarray_a1f73cd4b5b42fe1,
  __wbg_toString_7df3c77999517c20,
  __wbg_unshift_e22df4b34bcf5070,
  __wbg_value_d93c65011f51a456,
  __wbg_values_9c75e6e2bfbdb70d,
  __wbg_versions_f686565e586dd935,
  __wbg_window_c6fb939a7f436783,
  __wbindgen_bigint_from_i64,
  __wbindgen_bigint_from_u64,
  __wbindgen_boolean_get,
  __wbindgen_debug_string,
  __wbindgen_error_new,
  __wbindgen_is_array,
  __wbindgen_is_function,
  __wbindgen_is_null,
  __wbindgen_is_object,
  __wbindgen_is_string,
  __wbindgen_is_undefined,
  __wbindgen_json_serialize,
  __wbindgen_jsval_loose_eq,
  __wbindgen_memory,
  __wbindgen_number_get,
  __wbindgen_number_new,
  __wbindgen_object_clone_ref,
  __wbindgen_object_drop_ref,
  __wbindgen_string_get,
  __wbindgen_string_new,
  __wbindgen_throw,
  create: create$1,
  decodeChange: decodeChange$1,
  decodeSyncMessage: decodeSyncMessage$1,
  decodeSyncState: decodeSyncState$1,
  encodeChange: encodeChange$1,
  encodeSyncMessage: encodeSyncMessage$1,
  encodeSyncState: encodeSyncState$1,
  exportSyncState: exportSyncState$1,
  importSyncState: importSyncState$1,
  initSyncState: initSyncState$1,
  load: load$1
}, Symbol.toStringTag, { value: 'Module' }));

//@ts-ignore
UseApi(api);

init();

// https://github.com/maxogden/websocket-stream/blob/48dc3ddf943e5ada668c31ccd94e9186f02fafbd/ws-fallback.js

var ws = null;

if (typeof WebSocket !== 'undefined') {
  ws = WebSocket;
} else if (typeof MozWebSocket !== 'undefined') {
  ws = MozWebSocket;
} else if (typeof global !== 'undefined') {
  ws = global.WebSocket || global.MozWebSocket;
} else if (typeof window !== 'undefined') {
  ws = window.WebSocket || window.MozWebSocket;
} else if (typeof self !== 'undefined') {
  ws = self.WebSocket || self.MozWebSocket;
}

const WebSocket$1 = ws;

// TYPE GUARDS
const isPeerMessage = (message) => message.type === "peer";
const isErrorMessage = (message) => message.type === "error";

const ProtocolV1 = "1";

/* c8 ignore start */
function assert(value, message = "Assertion failed") {
    if (value === false || value === null || value === undefined) {
        const error = new Error(trimLines(message));
        error.stack = removeLine(error.stack, "assert.ts");
        throw error;
    }
}
const trimLines = (s) => s
    .split("\n")
    .map(s => s.trim())
    .join("\n");
const removeLine = (s = "", targetText) => s
    .split("\n")
    .filter(line => !line.includes(targetText))
    .join("\n");
/* c8 ignore end */

/**
 * This incantation deals with websocket sending the whole underlying buffer even if we just have a
 * uint8array view on it
 */
const toArrayBuffer = (bytes) => {
    const { buffer, byteOffset, byteLength } = bytes;
    return buffer.slice(byteOffset, byteOffset + byteLength);
};

class WebSocketNetworkAdapter extends NetworkAdapter {
    socket;
}
class BrowserWebSocketClientAdapter extends WebSocketNetworkAdapter {
    url;
    retryInterval;
    #isReady = false;
    #retryIntervalId;
    #log = debug("automerge-repo:websocket:browser");
    remotePeerId; // this adapter only connects to one remote client at a time
    constructor(url, retryInterval = 5000) {
        super();
        this.url = url;
        this.retryInterval = retryInterval;
        this.#log = this.#log.extend(url);
    }
    connect(peerId, peerMetadata) {
        if (!this.socket || !this.peerId) {
            // first time connecting
            this.#log("connecting");
            this.peerId = peerId;
            this.peerMetadata = peerMetadata ?? {};
        }
        else {
            this.#log("reconnecting");
            assert(peerId === this.peerId);
            // Remove the old event listeners before creating a new connection.
            this.socket.removeEventListener("open", this.onOpen);
            this.socket.removeEventListener("close", this.onClose);
            this.socket.removeEventListener("message", this.onMessage);
            this.socket.removeEventListener("error", this.onError);
        }
        // Wire up retries
        if (!this.#retryIntervalId)
            this.#retryIntervalId = setInterval(() => {
                this.connect(peerId, peerMetadata);
            }, this.retryInterval);
        this.socket = new WebSocket$1(this.url);
        this.socket.binaryType = "arraybuffer";
        this.socket.addEventListener("open", this.onOpen);
        this.socket.addEventListener("close", this.onClose);
        this.socket.addEventListener("message", this.onMessage);
        this.socket.addEventListener("error", this.onError);
        // Mark this adapter as ready if we haven't received an ack in 1 second.
        // We might hear back from the other end at some point but we shouldn't
        // hold up marking things as unavailable for any longer
        setTimeout(() => this.#ready(), 1000);
        this.join();
    }
    onOpen = () => {
        this.#log("open");
        clearInterval(this.#retryIntervalId);
        this.#retryIntervalId = undefined;
        this.join();
    };
    // When a socket closes, or disconnects, remove it from the array.
    onClose = () => {
        this.#log("close");
        if (this.remotePeerId)
            this.emit("peer-disconnected", { peerId: this.remotePeerId });
        if (this.retryInterval > 0 && !this.#retryIntervalId)
            // try to reconnect
            setTimeout(() => {
                assert(this.peerId);
                return this.connect(this.peerId, this.peerMetadata);
            }, this.retryInterval);
    };
    onMessage = (event) => {
        this.receiveMessage(event.data);
    };
    /** The websocket error handler signature is different on node and the browser.  */
    onError = (event // node
    ) => {
        if ("error" in event) {
            // (node)
            if (event.error.code !== "ECONNREFUSED") {
                /* c8 ignore next */
                throw event.error;
            }
        }
        this.#log("Connection failed, retrying...");
    };
    #ready() {
        if (this.#isReady)
            return;
        this.#isReady = true;
        this.emit("ready", { network: this });
    }
    join() {
        assert(this.peerId);
        assert(this.socket);
        if (this.socket.readyState === WebSocket$1.OPEN) {
            this.send(joinMessage(this.peerId, this.peerMetadata));
        }
    }
    disconnect() {
        assert(this.peerId);
        assert(this.socket);
        this.send({ type: "leave", senderId: this.peerId });
    }
    send(message) {
        if ("data" in message && message.data?.byteLength === 0)
            throw new Error("Tried to send a zero-length message");
        assert(this.peerId);
        assert(this.socket);
        if (this.socket.readyState !== WebSocket$1.OPEN)
            throw new Error(`Websocket not ready (${this.socket.readyState})`);
        const encoded = encode(message);
        this.socket.send(toArrayBuffer(encoded));
    }
    peerCandidate(remotePeerId, peerMetadata) {
        assert(this.socket);
        this.#ready();
        this.remotePeerId = remotePeerId;
        this.emit("peer-candidate", {
            peerId: remotePeerId,
            peerMetadata,
        });
    }
    receiveMessage(messageBytes) {
        const message = decode(new Uint8Array(messageBytes));
        assert(this.socket);
        if (messageBytes.byteLength === 0)
            throw new Error("received a zero-length message");
        if (isPeerMessage(message)) {
            const { peerMetadata } = message;
            this.#log(`peer: ${message.senderId}`);
            this.peerCandidate(message.senderId, peerMetadata);
        }
        else if (isErrorMessage(message)) {
            this.#log(`error: ${message.message}`);
        }
        else {
            this.emit("message", message);
        }
    }
}
function joinMessage(senderId, peerMetadata) {
    return {
        type: "join",
        senderId,
        peerMetadata,
        supportedProtocolVersions: [ProtocolV1],
    };
}

debug("WebsocketServer");

/**
 * This module provides a storage adapter for IndexedDB.
 *
 * @packageDocumentation
 */
class IndexedDBStorageAdapter {
    database;
    store;
    dbPromise;
    /** Create a new {@link IndexedDBStorageAdapter}.
     * @param database - The name of the database to use. Defaults to "automerge".
     * @param store - The name of the object store to use. Defaults to "documents".
     */
    constructor(database = "automerge", store = "documents") {
        this.database = database;
        this.store = store;
        this.dbPromise = this.createDatabasePromise();
    }
    createDatabasePromise() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.database, 1);
            request.onerror = () => {
                reject(request.error);
            };
            request.onupgradeneeded = event => {
                const db = event.target.result;
                db.createObjectStore(this.store);
            };
            request.onsuccess = event => {
                const db = event.target.result;
                resolve(db);
            };
        });
    }
    async load(keyArray) {
        const db = await this.dbPromise;
        const transaction = db.transaction(this.store);
        const objectStore = transaction.objectStore(this.store);
        const request = objectStore.get(keyArray);
        return new Promise((resolve, reject) => {
            transaction.onerror = () => {
                reject(request.error);
            };
            request.onsuccess = event => {
                const result = event.target.result;
                if (result && typeof result === "object" && "binary" in result) {
                    resolve(result.binary);
                }
                else {
                    resolve(undefined);
                }
            };
        });
    }
    async save(keyArray, binary) {
        const db = await this.dbPromise;
        const transaction = db.transaction(this.store, "readwrite");
        const objectStore = transaction.objectStore(this.store);
        objectStore.put({ key: keyArray, binary: binary }, keyArray);
        return new Promise((resolve, reject) => {
            transaction.onerror = () => {
                reject(transaction.error);
            };
            transaction.oncomplete = () => {
                resolve();
            };
        });
    }
    async remove(keyArray) {
        const db = await this.dbPromise;
        const transaction = db.transaction(this.store, "readwrite");
        const objectStore = transaction.objectStore(this.store);
        objectStore.delete(keyArray);
        return new Promise((resolve, reject) => {
            transaction.onerror = () => {
                reject(transaction.error);
            };
            transaction.oncomplete = () => {
                resolve();
            };
        });
    }
    async loadRange(keyPrefix) {
        const db = await this.dbPromise;
        const lowerBound = keyPrefix;
        const upperBound = [...keyPrefix, "\uffff"];
        const range = IDBKeyRange.bound(lowerBound, upperBound);
        const transaction = db.transaction(this.store);
        const objectStore = transaction.objectStore(this.store);
        const request = objectStore.openCursor(range);
        const result = [];
        return new Promise((resolve, reject) => {
            transaction.onerror = () => {
                reject(request.error);
            };
            request.onsuccess = event => {
                const cursor = event.target.result;
                if (cursor) {
                    result.push({
                        data: cursor.value.binary,
                        key: cursor.key,
                    });
                    cursor.continue();
                }
                else {
                    resolve(result);
                }
            };
        });
    }
    async removeRange(keyPrefix) {
        const db = await this.dbPromise;
        const lowerBound = keyPrefix;
        const upperBound = [...keyPrefix, "\uffff"];
        const range = IDBKeyRange.bound(lowerBound, upperBound);
        const transaction = db.transaction(this.store, "readwrite");
        const objectStore = transaction.objectStore(this.store);
        objectStore.delete(range);
        return new Promise((resolve, reject) => {
            transaction.onerror = () => {
                reject(transaction.error);
            };
            transaction.oncomplete = () => {
                resolve();
            };
        });
    }
}

const $RAW = Symbol("store-raw"),
  $NODE = Symbol("store-node"),
  $HAS = Symbol("store-has"),
  $SELF = Symbol("store-self");
function wrap$1(value) {
  let p = value[$PROXY];
  if (!p) {
    Object.defineProperty(value, $PROXY, {
      value: (p = new Proxy(value, proxyTraps$1))
    });
    if (!Array.isArray(value)) {
      const keys = Object.keys(value),
        desc = Object.getOwnPropertyDescriptors(value);
      for (let i = 0, l = keys.length; i < l; i++) {
        const prop = keys[i];
        if (desc[prop].get) {
          Object.defineProperty(value, prop, {
            enumerable: desc[prop].enumerable,
            get: desc[prop].get.bind(p)
          });
        }
      }
    }
  }
  return p;
}
function isWrappable(obj) {
  let proto;
  return (
    obj != null &&
    typeof obj === "object" &&
    (obj[$PROXY] ||
      !(proto = Object.getPrototypeOf(obj)) ||
      proto === Object.prototype ||
      Array.isArray(obj))
  );
}
function unwrap(item, set = new Set()) {
  let result, unwrapped, v, prop;
  if ((result = item != null && item[$RAW])) return result;
  if (!isWrappable(item) || set.has(item)) return item;
  if (Array.isArray(item)) {
    if (Object.isFrozen(item)) item = item.slice(0);
    else set.add(item);
    for (let i = 0, l = item.length; i < l; i++) {
      v = item[i];
      if ((unwrapped = unwrap(v, set)) !== v) item[i] = unwrapped;
    }
  } else {
    if (Object.isFrozen(item)) item = Object.assign({}, item);
    else set.add(item);
    const keys = Object.keys(item),
      desc = Object.getOwnPropertyDescriptors(item);
    for (let i = 0, l = keys.length; i < l; i++) {
      prop = keys[i];
      if (desc[prop].get) continue;
      v = item[prop];
      if ((unwrapped = unwrap(v, set)) !== v) item[prop] = unwrapped;
    }
  }
  return item;
}
function getNodes(target, symbol) {
  let nodes = target[symbol];
  if (!nodes)
    Object.defineProperty(target, symbol, {
      value: (nodes = Object.create(null))
    });
  return nodes;
}
function getNode(nodes, property, value) {
  if (nodes[property]) return nodes[property];
  const [s, set] = createSignal(value, {
    equals: false,
    internal: true
  });
  s.$ = set;
  return (nodes[property] = s);
}
function proxyDescriptor$1(target, property) {
  const desc = Reflect.getOwnPropertyDescriptor(target, property);
  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE)
    return desc;
  delete desc.value;
  delete desc.writable;
  desc.get = () => target[$PROXY][property];
  return desc;
}
function trackSelf(target) {
  getListener() && getNode(getNodes(target, $NODE), $SELF)();
}
function ownKeys(target) {
  trackSelf(target);
  return Reflect.ownKeys(target);
}
const proxyTraps$1 = {
  get(target, property, receiver) {
    if (property === $RAW) return target;
    if (property === $PROXY) return receiver;
    if (property === $TRACK) {
      trackSelf(target);
      return receiver;
    }
    const nodes = getNodes(target, $NODE);
    const tracked = nodes[property];
    let value = tracked ? tracked() : target[property];
    if (property === $NODE || property === $HAS || property === "__proto__") return value;
    if (!tracked) {
      const desc = Object.getOwnPropertyDescriptor(target, property);
      if (
        getListener() &&
        (typeof value !== "function" || target.hasOwnProperty(property)) &&
        !(desc && desc.get)
      )
        value = getNode(nodes, property, value)();
    }
    return isWrappable(value) ? wrap$1(value) : value;
  },
  has(target, property) {
    if (
      property === $RAW ||
      property === $PROXY ||
      property === $TRACK ||
      property === $NODE ||
      property === $HAS ||
      property === "__proto__"
    )
      return true;
    getListener() && getNode(getNodes(target, $HAS), property)();
    return property in target;
  },
  set() {
    return true;
  },
  deleteProperty() {
    return true;
  },
  ownKeys: ownKeys,
  getOwnPropertyDescriptor: proxyDescriptor$1
};
function setProperty(state, property, value, deleting = false) {
  if (!deleting && state[property] === value) return;
  const prev = state[property],
    len = state.length;
  if (value === undefined) {
    delete state[property];
    if (state[$HAS] && state[$HAS][property] && prev !== undefined) state[$HAS][property].$();
  } else {
    state[property] = value;
    if (state[$HAS] && state[$HAS][property] && prev === undefined) state[$HAS][property].$();
  }
  let nodes = getNodes(state, $NODE),
    node;
  if ((node = getNode(nodes, property, prev))) node.$(() => value);
  if (Array.isArray(state) && state.length !== len) {
    for (let i = state.length; i < len; i++) (node = nodes[i]) && node.$();
    (node = getNode(nodes, "length", len)) && node.$(state.length);
  }
  (node = nodes[$SELF]) && node.$();
}
function mergeStoreNode(state, value) {
  const keys = Object.keys(value);
  for (let i = 0; i < keys.length; i += 1) {
    const key = keys[i];
    setProperty(state, key, value[key]);
  }
}
function updateArray(current, next) {
  if (typeof next === "function") next = next(current);
  next = unwrap(next);
  if (Array.isArray(next)) {
    if (current === next) return;
    let i = 0,
      len = next.length;
    for (; i < len; i++) {
      const value = next[i];
      if (current[i] !== value) setProperty(current, i, value);
    }
    setProperty(current, "length", len);
  } else mergeStoreNode(current, next);
}
function updatePath(current, path, traversed = []) {
  let part,
    prev = current;
  if (path.length > 1) {
    part = path.shift();
    const partType = typeof part,
      isArray = Array.isArray(current);
    if (Array.isArray(part)) {
      for (let i = 0; i < part.length; i++) {
        updatePath(current, [part[i]].concat(path), traversed);
      }
      return;
    } else if (isArray && partType === "function") {
      for (let i = 0; i < current.length; i++) {
        if (part(current[i], i)) updatePath(current, [i].concat(path), traversed);
      }
      return;
    } else if (isArray && partType === "object") {
      const { from = 0, to = current.length - 1, by = 1 } = part;
      for (let i = from; i <= to; i += by) {
        updatePath(current, [i].concat(path), traversed);
      }
      return;
    } else if (path.length > 1) {
      updatePath(current[part], path, [part].concat(traversed));
      return;
    }
    prev = current[part];
    traversed = [part].concat(traversed);
  }
  let value = path[0];
  if (typeof value === "function") {
    value = value(prev, traversed);
    if (value === prev) return;
  }
  if (part === undefined && value == undefined) return;
  value = unwrap(value);
  if (part === undefined || (isWrappable(prev) && isWrappable(value) && !Array.isArray(value))) {
    mergeStoreNode(prev, value);
  } else setProperty(current, part, value);
}
function createStore(...[store, options]) {
  const unwrappedStore = unwrap(store || {});
  const isArray = Array.isArray(unwrappedStore);
  const wrappedStore = wrap$1(unwrappedStore);
  function setStore(...args) {
    batch(() => {
      isArray && args.length === 1
        ? updateArray(unwrappedStore, args[0])
        : updatePath(unwrappedStore, args);
    });
  }
  return [wrappedStore, setStore];
}

const $ROOT = Symbol("store-root");
function applyState(target, parent, property, merge, key) {
  const previous = parent[property];
  if (target === previous) return;
  const isArray = Array.isArray(target);
  if (
    property !== $ROOT &&
    (!isWrappable(target) ||
      !isWrappable(previous) ||
      isArray !== Array.isArray(previous) ||
      (key && target[key] !== previous[key]))
  ) {
    setProperty(parent, property, target);
    return;
  }
  if (isArray) {
    if (
      target.length &&
      previous.length &&
      (!merge || (key && target[0] && target[0][key] != null))
    ) {
      let i, j, start, end, newEnd, item, newIndicesNext, keyVal;
      for (
        start = 0, end = Math.min(previous.length, target.length);
        start < end &&
        (previous[start] === target[start] ||
          (key && previous[start] && target[start] && previous[start][key] === target[start][key]));
        start++
      ) {
        applyState(target[start], previous, start, merge, key);
      }
      const temp = new Array(target.length),
        newIndices = new Map();
      for (
        end = previous.length - 1, newEnd = target.length - 1;
        end >= start &&
        newEnd >= start &&
        (previous[end] === target[newEnd] ||
          (key && previous[start] && target[start] && previous[end][key] === target[newEnd][key]));
        end--, newEnd--
      ) {
        temp[newEnd] = previous[end];
      }
      if (start > newEnd || start > end) {
        for (j = start; j <= newEnd; j++) setProperty(previous, j, target[j]);
        for (; j < target.length; j++) {
          setProperty(previous, j, temp[j]);
          applyState(target[j], previous, j, merge, key);
        }
        if (previous.length > target.length) setProperty(previous, "length", target.length);
        return;
      }
      newIndicesNext = new Array(newEnd + 1);
      for (j = newEnd; j >= start; j--) {
        item = target[j];
        keyVal = key && item ? item[key] : item;
        i = newIndices.get(keyVal);
        newIndicesNext[j] = i === undefined ? -1 : i;
        newIndices.set(keyVal, j);
      }
      for (i = start; i <= end; i++) {
        item = previous[i];
        keyVal = key && item ? item[key] : item;
        j = newIndices.get(keyVal);
        if (j !== undefined && j !== -1) {
          temp[j] = previous[i];
          j = newIndicesNext[j];
          newIndices.set(keyVal, j);
        }
      }
      for (j = start; j < target.length; j++) {
        if (j in temp) {
          setProperty(previous, j, temp[j]);
          applyState(target[j], previous, j, merge, key);
        } else setProperty(previous, j, target[j]);
      }
    } else {
      for (let i = 0, len = target.length; i < len; i++) {
        applyState(target[i], previous, i, merge, key);
      }
    }
    if (previous.length > target.length) setProperty(previous, "length", target.length);
    return;
  }
  const targetKeys = Object.keys(target);
  for (let i = 0, len = targetKeys.length; i < len; i++) {
    applyState(target[targetKeys[i]], previous, targetKeys[i], merge, key);
  }
  const previousKeys = Object.keys(previous);
  for (let i = 0, len = previousKeys.length; i < len; i++) {
    if (target[previousKeys[i]] === undefined) setProperty(previous, previousKeys[i], undefined);
  }
}
function reconcile(value, options = {}) {
  const { merge, key = "id" } = options,
    v = unwrap(value);
  return state => {
    if (!isWrappable(state) || !isWrappable(v)) return v;
    const res = applyState(
      v,
      {
        [$ROOT]: state
      },
      $ROOT,
      merge,
      key
    );
    return res === undefined ? state : res;
  };
}
const producers = new WeakMap();
const setterTraps = {
  get(target, property) {
    if (property === $RAW) return target;
    const value = target[property];
    let proxy;
    return isWrappable(value)
      ? producers.get(value) ||
          (producers.set(value, (proxy = new Proxy(value, setterTraps))), proxy)
      : value;
  },
  set(target, property, value) {
    setProperty(target, property, unwrap(value));
    return true;
  },
  deleteProperty(target, property) {
    setProperty(target, property, undefined, true);
    return true;
  }
};
function produce(fn) {
  return state => {
    if (isWrappable(state)) {
      let proxy;
      if (!(proxy = producers.get(state))) {
        producers.set(state, (proxy = new Proxy(state, setterTraps)));
      }
      fn(proxy);
    }
    return state;
  };
}

// src/cookies.ts

// src/tools.ts
var addClearMethod = (storage) => {
  if (typeof storage.clear === "function") {
    return storage;
  }
  storage.clear = () => {
    let key;
    while (key = storage.key(0)) {
      storage.removeItem(key);
    }
  };
  return storage;
};
var methodKeys = ["clear", "getItem", "getAll", "setItem", "removeItem", "key", "getLength"];
var addWithOptionsMethod = (storage) => {
  storage.withOptions = (options) => methodKeys.reduce(
    (wrapped, key) => {
      if (typeof storage[key] === "function") {
        wrapped[key] = (...args) => {
          args[storage[key].length - 1] = options;
          return storage[key](...args);
        };
      }
      return wrapped;
    },
    {
      get length() {
        return storage.length;
      },
      withOptions: (options2) => storage.withOptions(options2)
    }
  );
  return storage;
};

// src/cookies.ts
var cookiePropertyMap = {
  domain: "Domain",
  expires: "Expires",
  path: "Path",
  secure: "Secure",
  httpOnly: "HttpOnly",
  maxAge: "Max-Age",
  sameSite: "SameSite"
};
function serializeCookieOptions(options) {
  if (!options) return "";
  const result = Object.entries(options).map(([key, value]) => {
    const serializedKey = cookiePropertyMap[key];
    if (!serializedKey) return void 0;
    if (value instanceof Date) return `${serializedKey}=${value.toUTCString()}`;
    if (typeof value === "boolean") return value ? `${serializedKey}` : void 0;
    return `${serializedKey}=${value}`;
  }).filter((v) => !!v);
  return result.length != 0 ? `; ${result.join("; ")}` : "";
}
function deserializeCookieOptions(cookie, key) {
  const found = cookie.match(`(^|;)\\s*${key}\\s*=\\s*([^;]+)`)?.pop();
  return found != null ? decodeURIComponent(found) : null;
}
var cookieStorage = addWithOptionsMethod(
  addClearMethod({
    _read: () => document.cookie,
    _write: (key, value, options) => {
      document.cookie = `${key}=${value}${serializeCookieOptions(options)}`;
    },
    getItem: (key, options) => deserializeCookieOptions(cookieStorage._read(options), key),
    setItem: (key, value, options) => {
      cookieStorage._write(
        key,
        value.replace(/[\u00c0-\uffff\&;]/g, (c) => encodeURIComponent(c)),
        options
      );
    },
    removeItem: (key, options) => {
      cookieStorage._write(key, "deleted", {
        ...options,
        expires: /* @__PURE__ */ new Date(0)
      });
    },
    key: (index, options) => {
      let key = null;
      let count = 0;
      cookieStorage._read(options).replace(/(?:^|;)\s*(.+?)\s*=\s*[^;]+/g, (_, found) => {
        if (!key && found && count++ === index) {
          key = found;
        }
        return "";
      });
      return key;
    },
    getLength: (options) => {
      let length = 0;
      cookieStorage._read(options).replace(/(?:^|;)\s*.+?\s*=\s*[^;]+/g, (found) => {
        length += found ? 1 : 0;
        return "";
      });
      return length;
    },
    get length() {
      return this.getLength();
    }
  })
);
function makePersisted(signal, options = {}) {
  const storage = options.storage || globalThis.localStorage;
  const name = options.name || `storage-${createUniqueId()}`;
  if (!storage) {
    return [signal[0], signal[1], null];
  }
  const storageOptions = options.storageOptions;
  const serialize = options.serialize || JSON.stringify.bind(JSON);
  const deserialize = options.deserialize || JSON.parse.bind(JSON);
  const init = storage.getItem(name, storageOptions);
  const set = typeof signal[0] === "function" ? (data) => {
    try {
      const value = deserialize(data);
      signal[1](() => value);
    } catch (e) {
    }
  } : (data) => {
    try {
      const value = deserialize(data);
      signal[1](reconcile(value));
    } catch (e) {
    }
  };
  let unchanged = true;
  if (init instanceof Promise) init.then((data) => unchanged && data && set(data));
  else if (init) set(init);
  if (typeof options.sync?.[0] === "function") {
    const get = typeof signal[0] === "function" ? signal[0] : () => signal[0];
    options.sync[0]((data) => {
      if (data.key !== name || (data.url || globalThis.location.href) !== globalThis.location.href || data.newValue === serialize(untrack(get))) {
        return;
      }
      set(data.newValue);
    });
  }
  return [
    signal[0],
    typeof signal[0] === "function" ? (value) => {
      const output = signal[1](value);
      const serialized = value != null ? serialize(output) : value;
      options.sync?.[1](name, serialized);
      if (serialized != null) storage.setItem(name, serialized, storageOptions);
      else storage.removeItem(name, storageOptions);
      unchanged = false;
      return output;
    } : (...args) => {
      signal[1](...args);
      const value = serialize(untrack(() => signal[0]));
      options.sync?.[1](name, value);
      storage.setItem(name, value, storageOptions);
      unchanged = false;
    },
    init
  ];
}

var webaudioTinysynth = {exports: {}};

var hasRequiredWebaudioTinysynth;

function requireWebaudioTinysynth () {
	if (hasRequiredWebaudioTinysynth) return webaudioTinysynth.exports;
	hasRequiredWebaudioTinysynth = 1;
	(function (module) {
		function WebAudioTinySynth(opt){
		  this.__proto__ = this.sy =
		  /* webaudio-tynysynth core object */
		  {
		    is:"webaudio-tinysynth",
		    properties:{
		      masterVol:  {type:Number, value:0.5, observer:"setMasterVol"},
		      reverbLev:  {type:Number, value:0.3, observer:"setReverbLev"},
		      quality:    {type:Number, value:1, observer:"setQuality"},
		      debug:      {type:Number, value:0},
		      src:        {type:String, value:null, observer:"loadMIDIUrl"},
		      loop:       {type:Number, value:0},
		      internalcontext: {type:Number, value:1},
		      tsmode:     {type:Number, value:0},
		      voices:     {type:Number, value:64},
		      useReverb:  {type:Number, value:1},
		      /**/
		    },
		    /**/
		    program:[
		// 1-8 : Piano
		      {name:"Acoustic Grand Piano"},    {name:"Bright Acoustic Piano"},
		      {name:"Electric Grand Piano"},    {name:"Honky-tonk Piano"},
		      {name:"Electric Piano 1"},        {name:"Electric Piano 2"},
		      {name:"Harpsichord"},             {name:"Clavi"},
		/* 9-16 : Chromatic Perc*/
		      {name:"Celesta"},                 {name:"Glockenspiel"},
		      {name:"Music Box"},               {name:"Vibraphone"},
		      {name:"Marimba"},                 {name:"Xylophone"},
		      {name:"Tubular Bells"},           {name:"Dulcimer"},
		/* 17-24 : Organ */
		      {name:"Drawbar Organ"},           {name:"Percussive Organ"},
		      {name:"Rock Organ"},              {name:"Church Organ"},
		      {name:"Reed Organ"},              {name:"Accordion"},
		      {name:"Harmonica"},               {name:"Tango Accordion"},
		/* 25-32 : Guitar */
		      {name:"Acoustic Guitar (nylon)"}, {name:"Acoustic Guitar (steel)"},
		      {name:"Electric Guitar (jazz)"},  {name:"Electric Guitar (clean)"},
		      {name:"Electric Guitar (muted)"}, {name:"Overdriven Guitar"},
		      {name:"Distortion Guitar"},       {name:"Guitar harmonics"},
		/* 33-40 : Bass */
		      {name:"Acoustic Bass"},           {name:"Electric Bass (finger)"},
		      {name:"Electric Bass (pick)"},    {name:"Fretless Bass"},
		      {name:"Slap Bass 1"},             {name:"Slap Bass 2"},
		      {name:"Synth Bass 1"},            {name:"Synth Bass 2"},
		/* 41-48 : Strings */
		      {name:"Violin"},                  {name:"Viola"},
		      {name:"Cello"},                   {name:"Contrabass"},
		      {name:"Tremolo Strings"},         {name:"Pizzicato Strings"},
		      {name:"Orchestral Harp"},         {name:"Timpani"},
		/* 49-56 : Ensamble */
		      {name:"String Ensemble 1"},       {name:"String Ensemble 2"},
		      {name:"SynthStrings 1"},          {name:"SynthStrings 2"},
		      {name:"Choir Aahs"},              {name:"Voice Oohs"},
		      {name:"Synth Voice"},             {name:"Orchestra Hit"},
		/* 57-64 : Brass */
		      {name:"Trumpet"},                 {name:"Trombone"},
		      {name:"Tuba"},                    {name:"Muted Trumpet"},
		      {name:"French Horn"},             {name:"Brass Section"},
		      {name:"SynthBrass 1"},            {name:"SynthBrass 2"},
		/* 65-72 : Reed */
		      {name:"Soprano Sax"},             {name:"Alto Sax"},
		      {name:"Tenor Sax"},               {name:"Baritone Sax"},
		      {name:"Oboe"},                    {name:"English Horn"},
		      {name:"Bassoon"},                 {name:"Clarinet"},
		/* 73-80 : Pipe */
		      {name:"Piccolo"},                 {name:"Flute"},
		      {name:"Recorder"},                {name:"Pan Flute"},
		      {name:"Blown Bottle"},            {name:"Shakuhachi"},
		      {name:"Whistle"},                 {name:"Ocarina"},
		/* 81-88 : SynthLead */
		      {name:"Lead 1 (square)"},         {name:"Lead 2 (sawtooth)"},
		      {name:"Lead 3 (calliope)"},       {name:"Lead 4 (chiff)"},
		      {name:"Lead 5 (charang)"},        {name:"Lead 6 (voice)"},
		      {name:"Lead 7 (fifths)"},         {name:"Lead 8 (bass + lead)"},
		/* 89-96 : SynthPad */
		      {name:"Pad 1 (new age)"},         {name:"Pad 2 (warm)"},
		      {name:"Pad 3 (polysynth)"},       {name:"Pad 4 (choir)"},
		      {name:"Pad 5 (bowed)"},           {name:"Pad 6 (metallic)"},
		      {name:"Pad 7 (halo)"},            {name:"Pad 8 (sweep)"},
		/* 97-104 : FX */
		      {name:"FX 1 (rain)"},             {name:"FX 2 (soundtrack)"},
		      {name:"FX 3 (crystal)"},          {name:"FX 4 (atmosphere)"},
		      {name:"FX 5 (brightness)"},       {name:"FX 6 (goblins)"},
		      {name:"FX 7 (echoes)"},           {name:"FX 8 (sci-fi)"},
		/* 105-112 : Ethnic */
		      {name:"Sitar"},                   {name:"Banjo"},
		      {name:"Shamisen"},                {name:"Koto"},
		      {name:"Kalimba"},                 {name:"Bag pipe"},
		      {name:"Fiddle"},                  {name:"Shanai"},
		/* 113-120 : Percussive */
		      {name:"Tinkle Bell"},             {name:"Agogo"},
		      {name:"Steel Drums"},             {name:"Woodblock"},
		      {name:"Taiko Drum"},              {name:"Melodic Tom"},
		      {name:"Synth Drum"},              {name:"Reverse Cymbal"},
		/* 121-128 : SE */
		      {name:"Guitar Fret Noise"},       {name:"Breath Noise"},
		      {name:"Seashore"},                {name:"Bird Tweet"},
		      {name:"Telephone Ring"},          {name:"Helicopter"},
		      {name:"Applause"},                {name:"Gunshot"},
		    ],
		    drummap:[
		// 35
		      {name:"Acoustic Bass Drum"},  {name:"Bass Drum 1"},      {name:"Side Stick"},     {name:"Acoustic Snare"},
		      {name:"Hand Clap"},           {name:"Electric Snare"},   {name:"Low Floor Tom"},  {name:"Closed Hi Hat"},
		      {name:"High Floor Tom"},      {name:"Pedal Hi-Hat"},     {name:"Low Tom"},        {name:"Open Hi-Hat"},
		      {name:"Low-Mid Tom"},         {name:"Hi-Mid Tom"},       {name:"Crash Cymbal 1"}, {name:"High Tom"},
		      {name:"Ride Cymbal 1"},       {name:"Chinese Cymbal"},   {name:"Ride Bell"},      {name:"Tambourine"},
		      {name:"Splash Cymbal"},       {name:"Cowbell"},          {name:"Crash Cymbal 2"}, {name:"Vibraslap"},
		      {name:"Ride Cymbal 2"},       {name:"Hi Bongo"},         {name:"Low Bongo"},      {name:"Mute Hi Conga"},
		      {name:"Open Hi Conga"},       {name:"Low Conga"},        {name:"High Timbale"},   {name:"Low Timbale"},
		      {name:"High Agogo"},          {name:"Low Agogo"},        {name:"Cabasa"},         {name:"Maracas"},
		      {name:"Short Whistle"},       {name:"Long Whistle"},     {name:"Short Guiro"},    {name:"Long Guiro"},
		      {name:"Claves"},              {name:"Hi Wood Block"},    {name:"Low Wood Block"}, {name:"Mute Cuica"},
		      {name:"Open Cuica"},          {name:"Mute Triangle"},    {name:"Open Triangle"},
		    ],
		    program1:[
		      // 1-8 : Piano
		      [{w:"sine",v:.4,d:0.7,r:0.1,},{w:"triangle",v:3,d:0.7,s:0.1,g:1,a:0.01,k:-1.2}],
		      [{w:"triangle",v:0.4,d:0.7,r:0.1,},{w:"triangle",v:4,t:3,d:0.4,s:0.1,g:1,k:-1,a:0.01,}],
		      [{w:"sine",d:0.7,r:0.1,},{w:"triangle",v:4,f:2,d:0.5,s:0.5,g:1,k:-1}],
		      [{w:"sine",d:0.7,v:0.2,},{w:"triangle",v:4,t:3,f:2,d:0.3,g:1,k:-1,a:0.01,s:0.5,}],
		      [{w:"sine",v:0.35,d:0.7,},{w:"sine",v:3,t:7,f:1,d:1,s:1,g:1,k:-.7}],
		      [{w:"sine",v:0.35,d:0.7,},{w:"sine",v:8,t:7,f:1,d:0.5,s:1,g:1,k:-.7}],
		      [{w:"sawtooth",v:0.34,d:2,},{w:"sine",v:8,f:0.1,d:2,s:1,r:2,g:1,}],
		      [{w:"triangle",v:0.34,d:1.5,},{w:"square",v:6,f:0.1,d:1.5,s:0.5,r:2,g:1,}],
		      /* 9-16 : Chromatic Perc*/
		      [{w:"sine",d:0.3,r:0.3,},{w:"sine",v:7,t:11,d:0.03,g:1,}],
		      [{w:"sine",d:0.3,r:0.3,},{w:"sine",v:11,t:6,d:0.2,s:0.4,g:1,}],
		      [{w:"sine",v:0.2,d:0.3,r:0.3,},{w:"sine",v:11,t:5,d:0.1,s:0.4,g:1,}],
		      [{w:"sine",v:0.2,d:0.6,r:0.6,},{w:"triangle",v:11,t:5,f:1,s:0.5,g:1,}],
		      [{w:"sine",v:0.3,d:0.2,r:0.2,},{w:"sine",v:6,t:5,d:0.02,g:1,}],
		      [{w:"sine",v:0.3,d:0.2,r:0.2,},{w:"sine",v:7,t:11,d:0.03,g:1,}],
		      [{w:"sine",v:0.2,d:1,r:1,},{w:"sine",v:11,t:3.5,d:1,r:1,g:1,}],
		      [{w:"triangle",v:0.2,d:0.5,r:0.2,},{w:"sine",v:6,t:2.5,d:0.2,s:0.1,r:0.2,g:1,}],
		      /* 17-24 : Organ */
		      [{w:"w9999",v:0.22,s:0.9,},{w:"w9999",v:0.22,t:2,f:2,s:0.9,}],
		      [{w:"w9999",v:0.2,s:1,},{w:"sine",v:11,t:6,f:2,s:0.1,g:1,h:0.006,r:0.002,d:0.002,},{w:"w9999",v:0.2,t:2,f:1,h:0,s:1,}],
		      [{w:"w9999",v:0.2,d:0.1,s:0.9,},{w:"w9999",v:0.25,t:4,f:2,s:0.5,}],
		      [{w:"w9999",v:0.3,a:0.04,s:0.9,},{w:"w9999",v:0.2,t:8,f:2,a:0.04,s:0.9,}],
		      [{w:"sine",v:0.2,a:0.02,d:0.05,s:1,},{w:"sine",v:6,t:3,f:1,a:0.02,d:0.05,s:1,g:1,}],
		      [{w:"triangle",v:0.2,a:0.02,d:0.05,s:0.8,},{w:"square",v:7,t:3,f:1,d:0.05,s:1.5,g:1,}],
		      [{w:"square",v:0.2,a:0.02,d:0.2,s:0.5,},{w:"square",v:1,d:0.03,s:2,g:1,}],
		      [{w:"square",v:0.2,a:0.02,d:0.1,s:0.8,},{w:"square",v:1,a:0.3,d:0.1,s:2,g:1,}],
		      /* 25-32 : Guitar */
		      [{w:"sine",v:0.3,d:0.5,f:1,},{w:"triangle",v:5,t:3,f:-1,d:1,s:0.1,g:1,}],
		      [{w:"sine",v:0.4,d:0.6,f:1,},{w:"triangle",v:12,t:3,d:0.6,s:0.1,g:1,f:-1,}],
		      [{w:"triangle",v:0.3,d:1,f:1,},{w:"triangle",v:6,f:-1,d:0.4,s:0.5,g:1,t:3,}],
		      [{w:"sine",v:0.3,d:1,f:-1,},{w:"triangle",v:11,f:1,d:0.4,s:0.5,g:1,t:3,}],
		      [{w:"sine",v:0.4,d:0.1,r:0.01},{w:"sine",v:7,g:1,}],
		      [{w:"triangle",v:0.4,d:1,f:1,},{w:"square",v:4,f:-1,d:1,s:0.7,g:1,}],//[{w:"triangle",v:0.35,d:1,f:1,},{w:"square",v:7,f:-1,d:0.3,s:0.5,g:1,}],
		      [{w:"triangle",v:0.35,d:1,f:1,},{w:"square",v:7,f:-1,d:0.3,s:0.5,g:1,}],//[{w:"triangle",v:0.4,d:1,f:1,},{w:"square",v:4,f:-1,d:1,s:0.7,g:1,}],//[{w:"triangle",v:0.4,d:1,},{w:"square",v:4,f:2,d:1,s:0.7,g:1,}],
		      [{w:"sine",v:0.2,t:1.5,a:0.005,h:0.2,d:0.6,},{w:"sine",v:11,t:5,f:2,d:1,s:0.5,g:1,}],
		      /* 33-40 : Bass */
		      [{w:"sine",d:0.3,},{w:"sine",v:4,t:3,d:1,s:1,g:1,}],
		      [{w:"sine",d:0.3,},{w:"sine",v:4,t:3,d:1,s:1,g:1,}],
		      [{w:"w9999",d:0.3,v:0.7,s:0.5,},{w:"sawtooth",v:1.2,d:0.02,s:0.5,g:1,h:0,r:0.02,}],
		      [{w:"sine",d:0.3,},{w:"sine",v:4,t:3,d:1,s:1,g:1,}],
		      [{w:"triangle",v:0.3,t:2,d:1,},{w:"triangle",v:15,t:2.5,d:0.04,s:0.1,g:1,}],
		      [{w:"triangle",v:0.3,t:2,d:1,},{w:"triangle",v:15,t:2.5,d:0.04,s:0.1,g:1,}],
		      [{w:"triangle",d:0.7,},{w:"square",v:0.4,t:0.5,f:1,d:0.2,s:10,g:1,}],
		      [{w:"triangle",d:0.7,},{w:"square",v:0.4,t:0.5,f:1,d:0.2,s:10,g:1,}],
		      /* 41-48 : Strings */
		      [{w:"sawtooth",v:0.4,a:0.1,d:11,},{w:"sine",v:5,d:11,s:0.2,g:1,}],
		      [{w:"sawtooth",v:0.4,a:0.1,d:11,},{w:"sine",v:5,d:11,s:0.2,g:1,}],
		      [{w:"sawtooth",v:0.4,a:0.1,d:11,},{w:"sine",v:5,t:0.5,d:11,s:0.2,g:1,}],
		      [{w:"sawtooth",v:0.4,a:0.1,d:11,},{w:"sine",v:5,t:0.5,d:11,s:0.2,g:1,}],
		      [{w:"sine",v:0.4,a:0.1,d:11,},{w:"sine",v:6,f:2.5,d:0.05,s:1.1,g:1,}],
		      [{w:"sine",v:0.3,d:0.1,r:0.1,},{w:"square",v:4,t:3,d:1,s:0.2,g:1,}],
		      [{w:"sine",v:0.3,d:0.5,r:0.5,},{w:"sine",v:7,t:2,f:2,d:1,r:1,g:1,}],
		      [{w:"triangle",v:0.6,h:0.03,d:0.3,r:0.3,t:0.5,},{w:"n0",v:8,t:1.5,d:0.08,r:0.08,g:1,}],
		      /* 49-56 : Ensamble */
		      [{w:"sawtooth",v:0.3,a:0.03,s:0.5,},{w:"sawtooth",v:0.2,t:2,f:2,d:1,s:2,}],
		      [{w:"sawtooth",v:0.3,f:-2,a:0.03,s:0.5,},{w:"sawtooth",v:0.2,t:2,f:2,d:1,s:2,}],
		      [{w:"sawtooth",v:0.2,a:0.02,s:1,},{w:"sawtooth",v:0.2,t:2,f:2,a:1,d:1,s:1,}],
		      [{w:"sawtooth",v:0.2,a:0.02,s:1,},{w:"sawtooth",v:0.2,f:2,a:0.02,d:1,s:1,}],
		      [{w:"triangle",v:0.3,a:0.03,s:1,},{w:"sine",v:3,t:5,f:1,d:1,s:1,g:1,}],
		      [{w:"sine",v:0.4,a:0.03,s:0.9,},{w:"sine",v:1,t:2,f:3,d:0.03,s:0.2,g:1,}],
		      [{w:"triangle",v:0.6,a:0.05,s:0.5,},{w:"sine",v:1,f:0.8,d:0.2,s:0.2,g:1,}],
		      [{w:"square",v:0.15,a:0.01,d:0.2,r:0.2,t:0.5,h:0.03,},{w:"square",v:4,f:0.5,d:0.2,r:11,a:0.01,g:1,h:0.02,},{w:"square",v:0.15,t:4,f:1,a:0.02,d:0.15,r:0.15,h:0.03,},{g:3,w:"square",v:4,f:-0.5,a:0.01,h:0.02,d:0.15,r:11,}],
		      /* 57-64 : Brass */
		      [{w:"square",v:0.2,a:0.01,d:1,s:0.6,r:0.04,},{w:"sine",v:1,d:0.1,s:4,g:1,}],
		      [{w:"square",v:0.2,a:0.02,d:1,s:0.5,r:0.08,},{w:"sine",v:1,d:0.1,s:4,g:1,}],
		      [{w:"square",v:0.2,a:0.04,d:1,s:0.4,r:0.08,},{w:"sine",v:1,d:0.1,s:4,g:1,}],
		      [{w:"square",v:0.15,a:0.04,s:1,},{w:"sine",v:2,d:0.1,g:1,}],
		      [{w:"square",v:0.2,a:0.02,d:1,s:0.5,r:0.08,},{w:"sine",v:1,d:0.1,s:4,g:1,}],
		      [{w:"square",v:0.2,a:0.02,d:1,s:0.6,r:0.08,},{w:"sine",v:1,f:0.2,d:0.1,s:4,g:1,}],
		      [{w:"square",v:0.2,a:0.02,d:0.5,s:0.7,r:0.08,},{w:"sine",v:1,d:0.1,s:4,g:1,}],
		      [{w:"square",v:0.2,a:0.02,d:1,s:0.5,r:0.08,},{w:"sine",v:1,d:0.1,s:4,g:1,}],
		      /* 65-72 : Reed */
		      [{w:"square",v:0.2,a:0.02,d:2,s:0.6,},{w:"sine",v:2,d:1,g:1,}],
		      [{w:"square",v:0.2,a:0.02,d:2,s:0.6,},{w:"sine",v:2,d:1,g:1,}],
		      [{w:"square",v:0.2,a:0.02,d:1,s:0.6,},{w:"sine",v:2,d:1,g:1,}],
		      [{w:"square",v:0.2,a:0.02,d:1,s:0.6,},{w:"sine",v:2,d:1,g:1,}],
		      [{w:"sine",v:0.4,a:0.02,d:0.7,s:0.5,},{w:"square",v:5,t:2,d:0.2,s:0.5,g:1,}],
		      [{w:"sine",v:0.3,a:0.05,d:0.2,s:0.8,},{w:"sawtooth",v:6,f:0.1,d:0.1,s:0.3,g:1,}],
		      [{w:"sine",v:0.3,a:0.03,d:0.2,s:0.4,},{w:"square",v:7,f:0.2,d:1,s:0.1,g:1,}],
		      [{w:"square",v:0.2,a:0.05,d:0.1,s:0.8,},{w:"square",v:4,d:0.1,s:1.1,g:1,}],
		      /* 73-80 : Pipe */
		      [{w:"sine",a:0.02,d:2,},{w:"sine",v:6,t:2,d:0.04,g:1,}],
		      [{w:"sine",v:0.7,a:0.03,d:0.4,s:0.4,},{w:"sine",v:4,t:2,f:0.2,d:0.4,g:1,}],
		      [{w:"sine",v:0.7,a:0.02,d:0.4,s:0.6,},{w:"sine",v:3,t:2,d:0,s:1,g:1,}],
		      [{w:"sine",v:0.4,a:0.06,d:0.3,s:0.3,},{w:"sine",v:7,t:2,d:0.2,s:0.2,g:1,}],
		      [{w:"sine",a:0.02,d:0.3,s:0.3,},{w:"sawtooth",v:3,t:2,d:0.3,g:1,}],
		      [{w:"sine",v:0.4,a:0.02,d:2,s:0.1,},{w:"sawtooth",v:8,t:2,f:1,d:0.5,g:1,}],
		      [{w:"sine",v:0.7,a:0.03,d:0.5,s:0.3,},{w:"sine",v:0.003,t:0,f:4,d:0.1,s:0.002,g:1,}],
		      [{w:"sine",v:0.7,a:0.02,d:2,},{w:"sine",v:1,t:2,f:1,d:0.02,g:1,}],
		      /* 81-88 : SynthLead */
		      [{w:"square",v:0.3,d:1,s:0.5,},{w:"square",v:1,f:0.2,d:1,s:0.5,g:1,}],
		      [{w:"sawtooth",v:0.3,d:2,s:0.5,},{w:"square",v:2,f:0.1,s:0.5,g:1,}],
		      [{w:"triangle",v:0.5,a:0.05,d:2,s:0.6,},{w:"sine",v:4,t:2,g:1,}],
		      [{w:"triangle",v:0.3,a:0.01,d:2,s:0.3,},{w:"sine",v:22,t:2,f:1,d:0.03,s:0.2,g:1,}],
		      [{w:"sawtooth",v:0.3,d:1,s:0.5,},{w:"sine",v:11,t:11,a:0.2,d:0.05,s:0.3,g:1,}],
		      [{w:"sine",v:0.3,a:0.06,d:1,s:0.5,},{w:"sine",v:7,f:1,d:1,s:0.2,g:1,}],
		      [{w:"sawtooth",v:0.3,a:0.03,d:0.7,s:0.3,r:0.2,},{w:"sawtooth",v:0.3,t:0.75,d:0.7,a:0.1,s:0.3,r:0.2,}],
		      [{w:"triangle",v:0.3,a:0.01,d:0.7,s:0.5,},{w:"square",v:5,t:0.5,d:0.7,s:0.5,g:1,}],
		      /* 89-96 : SynthPad */
		      [{w:"triangle",v:0.3,a:0.02,d:0.3,s:0.3,r:0.3,},{w:"square",v:3,t:4,f:1,a:0.02,d:0.1,s:1,g:1,},{w:"triangle",v:0.08,t:0.5,a:0.1,h:0,d:0.1,s:0.5,r:0.1,b:0,c:0,}],
		      [{w:"sine",v:0.3,a:0.05,d:1,s:0.7,r:0.3,},{w:"sine",v:2,f:1,d:0.3,s:1,g:1,}],
		      [{w:"square",v:0.3,a:0.03,d:0.5,s:0.3,r:0.1,},{w:"square",v:4,f:1,a:0.03,d:0.1,g:1,}],
		      [{w:"triangle",v:0.3,a:0.08,d:1,s:0.3,r:0.1,},{w:"square",v:2,f:1,d:0.3,s:0.3,g:1,t:4,a:0.08,}],
		      [{w:"sine",v:0.3,a:0.05,d:1,s:0.3,r:0.1,},{w:"sine",v:0.1,t:2.001,f:1,d:1,s:50,g:1,}],
		      [{w:"triangle",v:0.3,a:0.03,d:0.7,s:0.3,r:0.2,},{w:"sine",v:12,t:7,f:1,d:0.5,s:1.7,g:1,}],
		      [{w:"sine",v:0.3,a:0.05,d:1,s:0.3,r:0.1,},{w:"sawtooth",v:22,t:6,d:0.06,s:0.3,g:1,}],
		      [{w:"triangle",v:0.3,a:0.05,d:11,r:0.3,},{w:"triangle",v:1,d:1,s:8,g:1,}],
		      /* 97-104 : FX */
		      [{w:"sawtooth",v:0.3,d:4,s:0.8,r:0.1,},{w:"square",v:1,t:2,f:8,a:1,d:1,s:1,r:0.1,g:1,}],
		      [{w:"triangle",v:0.3,d:1,s:0.5,t:0.8,a:0.2,p:1.25,q:0.2,},{w:"sawtooth",v:0.2,a:0.2,d:0.3,s:1,t:1.2,p:1.25,q:0.2,}],
		      [{w:"sine",v:0.3,d:1,s:0.3,},{w:"square",v:22,t:11,d:0.5,s:0.1,g:1,}],
		      [{w:"sawtooth",v:0.3,a:0.04,d:1,s:0.8,r:0.1,},{w:"square",v:1,t:0.5,d:1,s:2,g:1,}],
		      [{w:"triangle",v:0.3,d:1,s:0.3,},{w:"sine",v:22,t:6,d:0.6,s:0.05,g:1,}],
		      [{w:"sine",v:0.6,a:0.1,d:0.05,s:0.4,},{w:"sine",v:5,t:5,f:1,d:0.05,s:0.3,g:1,}],
		      [{w:"sine",a:0.1,d:0.05,s:0.4,v:0.8,},{w:"sine",v:5,t:5,f:1,d:0.05,s:0.3,g:1,}],
		      [{w:"square",v:0.3,a:0.1,d:0.1,s:0.4,},{w:"square",v:1,f:1,d:0.3,s:0.1,g:1,}],
		      /* 105-112 : Ethnic */
		      [{w:"sawtooth",v:0.3,d:0.5,r:0.5,},{w:"sawtooth",v:11,t:5,d:0.05,g:1,}],
		      [{w:"square",v:0.3,d:0.2,r:0.2,},{w:"square",v:7,t:3,d:0.05,g:1,}],
		      [{w:"triangle",d:0.2,r:0.2,},{w:"square",v:9,t:3,d:0.1,r:0.1,g:1,}],
		      [{w:"triangle",d:0.3,r:0.3,},{w:"square",v:6,t:3,d:1,r:1,g:1,}],
		      [{w:"triangle",v:0.4,d:0.2,r:0.2,},{w:"square",v:22,t:12,d:0.1,r:0.1,g:1,}],
		      [{w:"sine",v:0.25,a:0.02,d:0.05,s:0.8,},{w:"square",v:1,t:2,d:0.03,s:11,g:1,}],
		      [{w:"sine",v:0.3,a:0.05,d:11,},{w:"square",v:7,t:3,f:1,s:0.7,g:1,}],
		      [{w:"square",v:0.3,a:0.05,d:0.1,s:0.8,},{w:"square",v:4,d:0.1,s:1.1,g:1,}],
		      /* 113-120 : Percussive */
		      [{w:"sine",v:0.4,d:0.3,r:0.3,},{w:"sine",v:7,t:9,d:0.1,r:0.1,g:1,}],
		      [{w:"sine",v:0.7,d:0.1,r:0.1,},{w:"sine",v:22,t:7,d:0.05,g:1,}],
		      [{w:"sine",v:0.6,d:0.15,r:0.15,},{w:"square",v:11,t:3.2,d:0.1,r:0.1,g:1,}],
		      [{w:"sine",v:0.8,d:0.07,r:0.07,},{w:"square",v:11,t:7,r:0.01,g:1,}],
		      [{w:"triangle",v:0.7,t:0.5,d:0.2,r:0.2,p:0.95,},{w:"n0",v:9,g:1,d:0.2,r:0.2,}],
		      [{w:"sine",v:0.7,d:0.1,r:0.1,p:0.9,},{w:"square",v:14,t:2,d:0.005,r:0.005,g:1,}],
		      [{w:"square",d:0.15,r:0.15,p:0.5,},{w:"square",v:4,t:5,d:0.001,r:0.001,g:1,}],
		      [{w:"n1",v:0.3,a:1,s:1,d:0.15,r:0,t:0.5,}],
		      /* 121-128 : SE */
		      [{w:"sine",t:12.5,d:0,r:0,p:0.5,v:0.3,h:0.2,q:0.5,},{g:1,w:"sine",v:1,t:2,d:0,r:0,s:1,},{g:1,w:"n0",v:0.2,t:2,a:0.6,h:0,d:0.1,r:0.1,b:0,c:0,}],
		      [{w:"n0",v:0.2,a:0.05,h:0.02,d:0.02,r:0.02,}],
		      [{w:"n0",v:0.4,a:1,d:1,t:0.25,}],
		      [{w:"sine",v:0.3,a:0.1,d:1,s:0.5,},{w:"sine",v:4,t:0,f:1.5,d:1,s:1,r:0.1,g:1,},{g:1,w:"sine",v:4,t:0,f:2,a:0.6,h:0,d:0.1,s:1,r:0.1,b:0,c:0,}],
		      [{w:"square",v:0.3,t:0.25,d:11,s:1,},{w:"square",v:12,t:0,f:8,d:1,s:1,r:11,g:1,}],
		      [{w:"n0",v:0.4,t:0.5,a:1,d:11,s:1,r:0.5,},{w:"square",v:1,t:0,f:14,d:1,s:1,r:11,g:1,}],
		      [{w:"sine",t:0,f:1221,a:0.2,d:1,r:0.25,s:1,},{g:1,w:"n0",v:3,t:0.5,d:1,s:1,r:1,}],
		      [{w:"sine",d:0.4,r:0.4,p:0.1,t:2.5,v:1,},{w:"n0",v:12,t:2,d:1,r:1,g:1,}],
		    ],
		    program0:[
		// 1-8 : Piano
		      [{w:"triangle",v:.5,d:.7}],                   [{w:"triangle",v:.5,d:.7}],
		      [{w:"triangle",v:.5,d:.7}],                   [{w:"triangle",v:.5,d:.7}],
		      [{w:"triangle",v:.5,d:.7}],                   [{w:"triangle",v:.5,d:.7}],
		      [{w:"sawtooth",v:.3,d:.7}],                   [{w:"sawtooth",v:.3,d:.7}],
		/* 9-16 : Chromatic Perc*/
		      [{w:"sine",v:.5,d:.3,r:.3}],                  [{w:"triangle",v:.5,d:.3,r:.3}],
		      [{w:"square",v:.2,d:.3,r:.3}],                [{w:"square",v:.2,d:.3,r:.3}],
		      [{w:"sine",v:.5,d:.1,r:.1}],                  [{w:"sine",v:.5,d:.1,r:.1}],
		      [{w:"square",v:.2,d:1,r:1}],                  [{w:"sawtooth",v:.3,d:.7,r:.7}],
		/* 17-24 : Organ */
		      [{w:"sine",v:0.5,a:0.01,s:1}],                [{w:"sine",v:0.7,d:0.02,s:0.7}],
		      [{w:"square",v:.2,s:1}],                      [{w:"triangle",v:.5,a:.01,s:1}],
		      [{w:"square",v:.2,a:.02,s:1}],                [{w:"square",v:0.2,a:0.02,s:1}],
		      [{w:"square",v:0.2,a:0.02,s:1}],              [{w:"square",v:.2,a:.05,s:1}],
		/* 25-32 : Guitar */
		      [{w:"triangle",v:.5,d:.5}],                   [{w:"square",v:.2,d:.6}],
		      [{w:"square",v:.2,d:.6}],                     [{w:"triangle",v:.8,d:.6}],
		      [{w:"triangle",v:.4,d:.05}],                  [{w:"square",v:.2,d:1}],
		      [{w:"square",v:.2,d:1}],                      [{w:"sine",v:.4,d:.6}],
		/* 33-40 : Bass */
		      [{w:"triangle",v:.7,d:.4}],                   [{w:"triangle",v:.7,d:.7}],
		      [{w:"triangle",v:.7,d:.7}],                   [{w:"triangle",v:.7,d:.7}],
		      [{w:"square",v:.3,d:.2}],                     [{w:"square",v:.3,d:.2}],
		      [{w:"square",v:.3,d:.1,s:.2}],                [{w:"sawtooth",v:.4,d:.1,s:.2}],
		/* 41-48 : Strings */
		      [{w:"sawtooth",v:.2,a:.02,s:1}],              [{w:"sawtooth",v:.2,a:.02,s:1}],
		      [{w:"sawtooth",v:.2,a:.02,s:1}],              [{w:"sawtooth",v:.2,a:.02,s:1}],
		      [{w:"sawtooth",v:.2,a:.02,s:1}],              [{w:"sawtooth",v:.3,d:.1}],
		      [{w:"sawtooth",v:.3,d:.5,r:.5}],              [{w:"triangle",v:.6,d:.1,r:.1,h:0.03,p:0.8}],
		/* 49-56 : Ensamble */
		      [{w:"sawtooth",v:.2,a:.02,s:1}],              [{w:"sawtooth",v:.2,a:.02,s:1}],
		      [{w:"sawtooth",v:.2,a:.02,s:1}],              [{w:"sawtooth",v:.2,a:.02,s:1}],
		      [{w:"triangle",v:.3,a:.03,s:1}],              [{w:"sine",v:.3,a:.03,s:1}],
		      [{w:"triangle",v:.3,a:.05,s:1}],              [{w:"sawtooth",v:.5,a:.01,d:.1}],
		/* 57-64 : Brass */
		      [{w:"square",v:.3,a:.05,d:.2,s:.6}],          [{w:"square",v:.3,a:.05,d:.2,s:.6}],
		      [{w:"square",v:.3,a:.05,d:.2,s:.6}],          [{w:"square",v:0.2,a:.05,d:0.01,s:1}],
		      [{w:"square",v:.3,a:.05,s:1}],                [{w:"square",v:.3,s:.7}],
		      [{w:"square",v:.3,s:.7}],                     [{w:"square",v:.3,s:.7}],
		/* 65-72 : Reed */
		      [{w:"square",v:.3,a:.02,d:2}],                [{w:"square",v:.3,a:.02,d:2}],
		      [{w:"square",v:.3,a:.03,d:2}],                [{w:"square",v:.3,a:.04,d:2}],
		      [{w:"square",v:.3,a:.02,d:2}],                [{w:"square",v:.3,a:.05,d:2}],
		      [{w:"square",v:.3,a:.03,d:2}],                [{w:"square",v:.3,a:.03,d:2}],
		/* 73-80 : Pipe */
		      [{w:"sine",v:.7,a:.02,d:2}],                  [{w:"sine",v:.7,a:.02,d:2}],
		      [{w:"sine",v:.7,a:.02,d:2}],                  [{w:"sine",v:.7,a:.02,d:2}],
		      [{w:"sine",v:.7,a:.02,d:2}],                  [{w:"sine",v:.7,a:.02,d:2}],
		      [{w:"sine",v:.7,a:.02,d:2}],                  [{w:"sine",v:.7,a:.02,d:2}],
		/* 81-88 : SynthLead */
		      [{w:"square",v:.3,s:.7}],                     [{w:"sawtooth",v:.4,s:.7}],
		      [{w:"triangle",v:.5,s:.7}],                   [{w:"sawtooth",v:.4,s:.7}],
		      [{w:"sawtooth",v:.4,d:12}],                   [{w:"sine",v:.4,a:.06,d:12}],
		      [{w:"sawtooth",v:.4,d:12}],                   [{w:"sawtooth",v:.4,d:12}],
		/* 89-96 : SynthPad */
		      [{w:"sawtooth",v:.3,d:12}],                   [{w:"triangle",v:.5,d:12}],
		      [{w:"square",v:.3,d:12}],                     [{w:"triangle",v:.5,a:.08,d:11}],
		      [{w:"sawtooth",v:.5,a:.05,d:11}],             [{w:"sawtooth",v:.5,d:11}],
		      [{w:"triangle",v:.5,d:11}],                   [{w:"triangle",v:.5,d:11}],
		/* 97-104 : FX */
		      [{w:"triangle",v:.5,d:11}],                   [{w:"triangle",v:.5,d:11}],
		      [{w:"square",v:.3,d:11}],                     [{w:"sawtooth",v:0.5,a:0.04,d:11}],
		      [{w:"sawtooth",v:.5,d:11}],                   [{w:"triangle",v:.5,a:.8,d:11}],
		      [{w:"triangle",v:.5,d:11}],                   [{w:"square",v:.3,d:11}],
		/* 105-112 : Ethnic */
		      [{w:"sawtooth",v:.3,d:1,r:1}],                [{w:"sawtooth",v:.5,d:.3}],
		      [{w:"sawtooth",v:.5,d:.3,r:.3}],              [{w:"sawtooth",v:.5,d:.3,r:.3}],
		      [{w:"square",v:.3,d:.2,r:.2}],                [{w:"square",v:.3,a:.02,d:2}],
		      [{w:"sawtooth",v:.2,a:.02,d:.7}],             [{w:"triangle",v:.5,d:1}],
		/* 113-120 : Percussive */
		      [{w:"sawtooth",v:.3,d:.3,r:.3}],              [{w:"sine",v:.8,d:.1,r:.1}],
		      [{w:"square",v:.2,d:.1,r:.1,p:1.05}],         [{w:"sine",v:.8,d:.05,r:.05}],
		      [{w:"triangle",v:0.5,d:0.1,r:0.1,p:0.96}],    [{w:"triangle",v:0.5,d:0.1,r:0.1,p:0.97}],
		      [{w:"square",v:.3,d:.1,r:.1,}],               [{w:"n1",v:0.3,a:1,s:1,d:0.15,r:0,t:0.5,}],
		/* 121-128 : SE */
		      [{w:"triangle",v:0.5,d:0.03,t:0,f:1332,r:0.001,p:1.1}],
		      [{w:"n0",v:0.2,t:0.1,d:0.02,a:0.05,h:0.02,r:0.02}],
		      [{w:"n0",v:0.4,a:1,d:1,t:0.25,}],
		      [{w:"sine",v:0.3,a:0.8,d:1,t:0,f:1832}],
		      [{w:"triangle",d:0.5,t:0,f:444,s:1,}],
		      [{w:"n0",v:0.4,d:1,t:0,f:22,s:1,}],
		      [{w:"n0",v:0.5,a:0.2,d:11,t:0,f:44}],
		      [{w:"n0",v:0.5,t:0.25,d:0.4,r:0.4}],
		    ],
		    drummap1:[
		/*35*/  [{w:"triangle",t:0,f:70,v:1,d:0.05,h:0.03,p:0.9,q:0.1,},{w:"n0",g:1,t:6,v:17,r:0.01,h:0,p:0,}],
		        [{w:"triangle",t:0,f:88,v:1,d:0.05,h:0.03,p:0.5,q:0.1,},{w:"n0",g:1,t:5,v:42,r:0.01,h:0,p:0,}],
		        [{w:"n0",f:222,p:0,t:0,r:0.01,h:0,}],
		        [{w:"triangle",v:0.3,f:180,d:0.05,t:0,h:0.03,p:0.9,q:0.1,},{w:"n0",v:0.6,t:0,f:70,h:0.02,r:0.01,p:0,},{g:1,w:"square",v:2,t:0,f:360,r:0.01,b:0,c:0,}],
		        [{w:"square",f:1150,v:0.34,t:0,r:0.03,h:0.025,d:0.03,},{g:1,w:"n0",t:0,f:13,h:0.025,d:0.1,s:1,r:0.1,v:1,}],
		/*40*/  [{w:"triangle",f:200,v:1,d:0.06,t:0,r:0.06,},{w:"n0",g:1,t:0,f:400,v:12,r:0.02,d:0.02,}],
		        [{w:"triangle",f:100,v:0.9,d:0.12,h:0.02,p:0.5,t:0,r:0.12,},{g:1,w:"n0",v:5,t:0.4,h:0.015,d:0.005,r:0.005,}],
		        [{w:"n1",f:390,v:0.25,r:0.01,t:0,}],
		        [{w:"triangle",f:120,v:0.9,d:0.12,h:0.02,p:0.5,t:0,r:0.12,},{g:1,w:"n0",v:5,t:0.5,h:0.015,d:0.005,r:0.005,}],
		        [{w:"n1",v:0.25,f:390,r:0.03,t:0,h:0.005,d:0.03,}],
		/*45*/  [{w:"triangle",f:140,v:0.9,d:0.12,h:0.02,p:0.5,t:0,r:0.12,},{g:1,w:"n0",v:5,t:0.3,h:0.015,d:0.005,r:0.005,}],
		        [{w:"n1",v:0.25,f:390,t:0,d:0.2,r:0.2,},{w:"n0",v:0.3,t:0,c:0,f:440,h:0.005,d:0.05,}],
		        [{w:"triangle",f:155,v:0.9,d:0.12,h:0.02,p:0.5,t:0,r:0.12,},{g:1,w:"n0",v:5,t:0.3,h:0.015,d:0.005,r:0.005,}],
		        [{w:"triangle",f:180,v:0.9,d:0.12,h:0.02,p:0.5,t:0,r:0.12,},{g:1,w:"n0",v:5,t:0.3,h:0.015,d:0.005,r:0.005,}],
		        [{w:"n1",v:0.3,f:1200,d:0.2,r:0.2,h:0.05,t:0,},{w:"n1",t:0,v:1,d:0.1,r:0.1,p:1.2,f:440,}],
		/*50*/  [{w:"triangle",f:220,v:0.9,d:0.12,h:0.02,p:0.5,t:0,r:0.12,},{g:1,w:"n0",v:5,t:0.3,h:0.015,d:0.005,r:0.005,}],
		        [{w:"n1",f:500,v:0.15,d:0.4,r:0.4,h:0,t:0,},{w:"n0",v:0.1,t:0,r:0.01,f:440,}],
		        [{w:"n1",v:0.3,f:800,d:0.2,r:0.2,h:0.05,t:0,},{w:"square",t:0,v:1,d:0.1,r:0.1,p:0.1,f:220,g:1,}],
		        [{w:"sine",f:1651,v:0.15,d:0.2,r:0.2,h:0,t:0,},{w:"sawtooth",g:1,t:1.21,v:7.2,d:0.1,r:11,h:1,},{g:1,w:"n0",v:3.1,t:0.152,d:0.002,r:0.002,}],
		        null,
		/*55*/  [{w:"n1",v:.3,f:1200,d:0.2,r:0.2,h:0.05,t:0,},{w:"n1",t:0,v:1,d:0.1,r:0.1,p:1.2,f:440,}],
		        null,
		        [{w:"n1",v:0.3,f:555,d:0.25,r:0.25,h:0.05,t:0,},{w:"n1",t:0,v:1,d:0.1,r:0.1,f:440,a:0.005,h:0.02,}],
		        [{w:"sawtooth",f:776,v:0.2,d:0.3,t:0,r:0.3,},{g:1,w:"n0",v:2,t:0,f:776,a:0.005,h:0.02,d:0.1,s:1,r:0.1,c:0,},{g:11,w:"sine",v:0.1,t:0,f:22,d:0.3,r:0.3,b:0,c:0,}],
		        [{w:"n1",f:440,v:0.15,d:0.4,r:0.4,h:0,t:0,},{w:"n0",v:0.4,t:0,r:0.01,f:440,}],
		/*60*/  null,null,null,null,null,
		/*65*/  null,null,null,null,null,
		/*70*/  null,null,null,null,null,
		/*75*/  null,null,null,null,null,
		/*80*/  [{w:"sine",f:1720,v:0.3,d:0.02,t:0,r:0.02,},{w:"square",g:1,t:0,f:2876,v:6,d:0.2,s:1,r:0.2,}],
		        [{w:"sine",f:1720,v:0.3,d:0.25,t:0,r:0.25,},{w:"square",g:1,t:0,f:2876,v:6,d:0.2,s:1,r:0.2,}],
		    ],
		    drummap0:[
		/*35*/[{w:"triangle",t:0,f:110,v:1,d:0.05,h:0.02,p:0.1,}],
		      [{w:"triangle",t:0,f:150,v:0.8,d:0.1,p:0.1,h:0.02,r:0.01,}],
		      [{w:"n0",f:392,v:0.5,d:0.01,p:0,t:0,r:0.05}],
		      [{w:"n0",f:33,d:0.05,t:0,}],
		      [{w:"n0",f:100,v:0.7,d:0.03,t:0,r:0.03,h:0.02,}],
		/*40*/[{w:"n0",f:44,v:0.7,d:0.02,p:0.1,t:0,h:0.02,}],
		      [{w:"triangle",f:240,v:0.9,d:0.1,h:0.02,p:0.1,t:0,}],
		      [{w:"n0",f:440,v:0.2,r:0.01,t:0,}],
		      [{w:"triangle",f:270,v:0.9,d:0.1,h:0.02,p:0.1,t:0,}],
		      [{w:"n0",f:440,v:0.2,d:0.04,r:0.04,t:0,}],
		/*45*/[{w:"triangle",f:300,v:0.9,d:0.1,h:0.02,p:0.1,t:0,}],
		      [{w:"n0",f:440,v:0.2,d:0.1,r:0.1,h:0.02,t:0,}],
		      [{w:"triangle",f:320,v:0.9,d:0.1,h:0.02,p:0.1,t:0,}],
		      [{w:"triangle",f:360,v:0.9,d:0.1,h:0.02,p:0.1,t:0,}],
		      [{w:"n0",f:150,v:0.2,d:0.1,r:0.1,h:0.05,t:0,p:0.1,}],
		/*50*/[{w:"triangle",f:400,v:0.9,d:0.1,h:0.02,p:0.1,t:0,}],
		      [{w:"n0",f:150,v:0.2,d:0.1,r:0.01,h:0.05,t:0,p:0.1}],
		      [{w:"n0",f:150,v:0.2,d:0.1,r:0.01,h:0.05,t:0,p:0.1}],
		      [{w:"n0",f:440,v:0.3,d:0.1,p:0.9,t:0,r:0.1,}],
		      [{w:"n0",f:200,v:0.2,d:0.05,p:0.9,t:0,}],
		/*55*/[{w:"n0",f:440,v:0.3,d:0.12,p:0.9,t:0,}],
		      [{w:"sine",f:800,v:0.4,d:0.06,t:0,}],
		      [{w:"n0",f:150,v:0.2,d:0.1,r:0.01,h:0.05,t:0,p:0.1}],
		      [{w:"n0",f:33,v:0.3,d:0.2,p:0.9,t:0,}],
		      [{w:"n0",f:300,v:0.3,d:0.14,p:0.9,t:0,}],
		/*60*/[{w:"sine",f:200,d:0.06,t:0,}],
		      [{w:"sine",f:150,d:0.06,t:0,}],
		      [{w:"sine",f:300,t:0,}],
		      [{w:"sine",f:300,d:0.06,t:0,}],
		      [{w:"sine",f:250,d:0.06,t:0,}],
		/*65*/[{w:"square",f:300,v:.3,d:.06,p:.8,t:0,}],
		      [{w:"square",f:260,v:.3,d:.06,p:.8,t:0,}],
		      [{w:"sine",f:850,v:.5,d:.07,t:0,}],
		      [{w:"sine",f:790,v:.5,d:.07,t:0,}],
		      [{w:"n0",f:440,v:0.3,a:0.05,t:0,}],
		/*70*/[{w:"n0",f:440,v:0.3,a:0.05,t:0,}],
		      [{w:"triangle",f:1800,v:0.4,p:0.9,t:0,h:0.03,}],
		      [{w:"triangle",f:1800,v:0.3,p:0.9,t:0,h:0.13,}],
		      [{w:"n0",f:330,v:0.3,a:0.02,t:0,r:0.01,}],
		      [{w:"n0",f:330,v:0.3,a:0.02,t:0,h:0.04,r:0.01,}],
		/*75*/[{w:"n0",f:440,v:0.3,t:0,}],
		      [{w:"sine",f:800,t:0,}],
		      [{w:"sine",f:700,t:0,}],
		      [{w:"n0",f:330,v:0.3,t:0,}],
		      [{w:"n0",f:330,v:0.3,t:0,h:0.1,r:0.01,p:0.7,}],
		/*80*/[{w:"sine",t:0,f:1200,v:0.3,r:0.01,}],
		      [{w:"sine",t:0,f:1200,v:0.3,d:0.2,r:0.2,}],

		    ],
		    /**/
		    ready:function(){
		      var i;
		      this.pg=[]; this.vol=[]; this.ex=[]; this.bend=[]; this.rpnidx=[]; this.brange=[];
		      this.sustain=[]; this.notetab=[]; this.rhythm=[];
		      this.maxTick=0, this.playTick=0, this.playing=0; this.releaseRatio=3.5;
		      for(var i=0;i<16;++i){
		        this.pg[i]=0; this.vol[i]=3*100*100/(127*127);
		        this.bend[i]=0; this.brange[i]=0x100;
		        this.rhythm[i]=0;
		      }
		      this.rhythm[9]=1;
		      /**/
		      this.preroll=0.2;
		      this.relcnt=0;
		      setInterval(
		        function(){
		          if(++this.relcnt>=3){
		            this.relcnt=0;
		            for(var i=this.notetab.length-1;i>=0;--i){
		              var nt=this.notetab[i];
		              if(this.actx.currentTime>nt.e){
		                this._pruneNote(nt);
		                this.notetab.splice(i,1);
		              }
		            }
		            /**/
		          }
		          if(this.playing && this.song.ev.length>0){
		            var e=this.song.ev[this.playIndex];
		            while(this.actx.currentTime+this.preroll>this.playTime){
		              if(e.m[0]==0xff51){
		                this.song.tempo=e.m[1];
		                this.tick2Time=4*60/this.song.tempo/this.song.timebase;
		              }
		              else
		                this.send(e.m,this.playTime);
		              ++this.playIndex;
		              if(this.playIndex>=this.song.ev.length){
		                if(this.loop){
		                  e=this.song.ev[this.playIndex=0];
		                  this.playTick=e.t;
		                }
		                else {
		                  this.playTick=this.maxTick;
		                  this.playing=0;
		                  break;
		                }
		              }
		              else {
		                e=this.song.ev[this.playIndex];
		                this.playTime+=(e.t-this.playTick)*this.tick2Time;
		                this.playTick=e.t;
		              }
		            }
		          }
		        }.bind(this),60
		      );
		      // console.log("internalcontext:"+this.internalcontext)
		      if(this.internalcontext){
		        window.AudioContext = window.AudioContext || window.webkitAudioContext;
		        this.setAudioContext(new AudioContext());
		      }
		      this.isReady=1;
		    },
		    setMasterVol:function(v){
		      if(v!=undefined)
		        this.masterVol=v;
		      if(this.out)
		        this.out.gain.value=this.masterVol;
		    },
		    setReverbLev:function(v){
		      if(v!=undefined)
		        this.reverbLev=v;
		      var r=parseFloat(this.reverbLev);
		      if(this.rev&&!isNaN(r))
		        this.rev.gain.value=r*8;
		    },
		    setLoop:function(f){
		      this.loop=f;
		    },
		    setVoices:function(v){
		      this.voices=v;
		    },
		    getPlayStatus:function(){
		      return {play:this.playing, maxTick:this.maxTick, curTick:this.playTick};
		    },
		    locateMIDI:function(tick){
		      var i,p=this.playing;
		      this.stopMIDI();
		      for(i=0;i<this.song.ev.length && tick>this.song.ev[i].t;++i){
		        var m=this.song.ev[i];
		        var ch=m.m[0]&0xf;
		        switch(m.m[0]&0xf0){
		        case 0xb0:
		          switch(m.m[1]){
		          case 1:  this.setModulation(ch,m.m[2]); break;
		          case 7:  this.setChVol(ch,m.m[2]); break;
		          case 10: this.setPan(ch,m.m[2]); break;
		          case 11: this.setExpression(ch,m.m[2]); break;
		          case 64: this.setSustain(ch,m.m[2]); break;
		          }
		          break;
		        case 0xc0: this.pg[m.m[0]&0x0f]=m.m[1]; break;
		        }
		        if(m.m[0]==0xff51)
		          this.song.tempo=m.m[1];
		      }
		      if(!this.song.ev[i]){
		        this.playIndex=0;
		        this.playTick=this.maxTick;
		      }
		      else {
		        this.playIndex=i;
		        this.playTick=this.song.ev[i].t;
		      }
		      if(p)
		        this.playMIDI();
		    },
		    getTimbreName:function(m,n){
		      if(m==0)
		        return this.program[n].name;
		      else
		        return this.drummap[n-35].name;
		    },
		    loadMIDIUrl:function(url){
		      if(!url)
		        return;
		      var xhr=new XMLHttpRequest();
		      xhr.open("GET",url,true);
		      xhr.responseType="arraybuffer";
		      xhr.loadMIDI=this.loadMIDI.bind(this);
		      xhr.onload=function(e){
		        if(this.status==200){
		          this.loadMIDI(this.response);
		        }
		      };
		      xhr.send();
		    },
		    reset:function(){
		      for(var i=0;i<16;++i){
		        this.setProgram(i,0);
		        this.setBendRange(i,0x100);
		        this.setChVol(i,100);
		        this.setPan(i,64);
		        this.resetAllControllers(i);
		        this.allSoundOff(i);
		        this.rhythm[i]=0;
		      }
		      this.rhythm[9]=1;
		    },
		    stopMIDI:function(){
		      this.playing=0;
		      for(var i=0;i<16;++i)
		        this.allSoundOff(i);
		    },
		    playMIDI:function(){
		      if(!this.song)
		        return;
		      var dummy=this.actx.createOscillator();
		      dummy.connect(this.actx.destination);
		      dummy.frequency.value=0;
		      dummy.start(0);
		      dummy.stop(this.actx.currentTime+0.001);
		      if(this.playTick>=this.maxTick)
		        this.playTick=0,this.playIndex=0;
		      this.playTime=this.actx.currentTime+.1;
		      this.tick2Time=4*60/this.song.tempo/this.song.timebase;
		      this.playing=1;
		    },
		    loadMIDI:function(data){
		      function Get2(s, i) { return (s[i]<<8) + s[i+1]; }
		      function Get3(s, i) { return (s[i]<<16) + (s[i+1]<<8) + s[i+2]; }
		      function Get4(s, i) { return (s[i]<<24) + (s[i+1]<<16) + (s[i+2]<<8) + s[i+3]; }
		      function GetStr(s, i, len) {
		        return String.fromCharCode.apply(null,s.slice(i,i+len));
		      }
		      function Delta(s, i) {
		        var v, d;
		        v = 0;
		        datalen = 1;
		        while((d = s[i]) & 0x80) {
		          v = (v<<7) + (d&0x7f);
		          ++datalen;
		          ++i;
		        }
		        return (v<<7)+d;
		      }
		      function Msg(song,tick,s,i){
		        var v=s[i];
		        datalen=1;
		        if((v&0x80)==0)
		          v=runst,datalen=0;
		        runst=v;
		        switch(v&0xf0){
		        case 0xc0: case 0xd0:
		          song.ev.push({t:tick,m:[v,s[i+datalen]]});
		          datalen+=1;
		          break;
		        case 0xf0:
		          switch(v) {
		          case 0xf0:
		          case 0xf7:
		            var len=Delta(s,i+1);
		            datastart=1+datalen;
		            var exd=Array.from(s.slice(i+datastart,i+datastart+len));
		            exd.unshift(0xf0);
		            song.ev.push({t:tick,m:exd});
		/*
		            var sysex=[];
		            for(var jj=0;jj<len;++jj)
		              sysex.push(s[i+datastart+jj].toString(16));
		            console.log(sysex);
		*/
		            datalen+=len+1;
		            break;
		          case 0xff:
		            var len = Delta(s, i + 2);
		            datastart = 2+datalen;
		            datalen = len+datalen+2;
		            switch(s[i+1]) {
		            case 0x02: song.copyright+=GetStr(s, i + datastart, datalen - 3); break;
		            case 0x01: case 0x03: case 0x04: case 0x09:
		              song.text=GetStr(s, i + datastart, datalen - datastart);
		              break;
		            case 0x2f:
		              return 1;
		            case 0x51:
		              var val = Math.floor(60000000 / Get3(s, i + 3));
		              song.ev.push({t:tick, m:[0xff51, val]});
		              break;
		            }
		            break;
		          }
		          break;
		        default:
		          song.ev.push({t:tick,m:[v,s[i+datalen],s[i+datalen+1]]});
		          datalen+=2;
		        }
		        return 0;
		      }
		      this.stopMIDI();
		      var s=new Uint8Array(data);
		      var datalen = 0, datastart = 0, runst = 0x90;
		      var idx = 0;
		      var hd = s.slice(0,  4);
		      if(hd.toString()!="77,84,104,100")  //MThd
		        return;
		      var len = Get4(s, 4);
		      Get2(s, 8);
		      var numtrk = Get2(s, 10);
		      this.maxTick=0;
		      var tb = Get2(s, 12)*4;
		      idx = (len + 8);
		      this.song={copyright:"",text:"",tempo:120,timebase:tb,ev:[]};
		      for(var tr=0;tr<numtrk;++tr){
		        hd=s.slice(idx, idx+4);
		        len=Get4(s, idx+4);
		        if(hd.toString()=="77,84,114,107") {//MTrk
		          var tick = 0;
		          var j = 0;
		          this.notetab.length = 0;
		          for(;;) {
		            tick += Delta(s, idx + 8 + j);
		            j += datalen;
		            var e = Msg(this.song, tick, s, idx + 8 + j);
		            j += datalen;
		            if(e)
		              break;
		          }
		          if(tick>this.maxTick)
		            this.maxTick=tick;
		        }
		        idx += (len+8);
		      }
		      this.song.ev.sort(function(x,y){return x.t-y.t});
		      this.reset();
		      this.locateMIDI(0);
		    },
		    setQuality:function(q){
		      var i;
		      if(q!=undefined)
		        this.quality=q;
		      for(i=0;i<128;++i)
		        this.setTimbre(0,i,this.program0[i]);
		      for(i=0;i<this.drummap0.length;++i)
		        this.setTimbre(1,i+35,this.drummap0[i]);
		      if(this.quality){
		        for(i=0;i<this.program1.length;++i)
		          this.setTimbre(0,i,this.program1[i]);
		        for(i=0;i<this.drummap.length;++i){
		          if(this.drummap1[i])
		            this.setTimbre(1,i+35,this.drummap1[i]);
		        }
		      }
		    },
		    setTimbre:function(m,n,p){
		      var defp={g:0,w:"sine",t:1,f:0,v:0.5,a:0,h:0.01,d:0.01,s:0,r:0.05,p:1,q:1,k:0};
		      function filldef(p){
		        for(n=0;n<p.length;++n){
		          for(k in defp){
		            if(!p[n].hasOwnProperty(k) || typeof(p[n][k])=="undefined")
		              p[n][k]=defp[k];
		          }
		        }
		        return p;
		      }
		      if(m && n>=35 && n<=81)
		        this.drummap[n-35].p=filldef(p);
		      if(m==0 && n>=0 && n<=127)
		        this.program[n].p=filldef(p);
		    },
		    _pruneNote:function(nt){
		      for(var k=nt.o.length-1;k>=0;--k){
		        if(nt.o[k].frequency)
		          this.chmod[nt.ch].disconnect(nt.o[k].detune);
		        nt.o[k].disconnect();
		        if(nt.o[k].frequency)
		          nt.o[k].frequency.cancelScheduledValues(0);
		        else
		          nt.o[k].playbackRate.cancelScheduledValues(0);
		        nt.o[k].stop(0);
		      }
		      for(var k=nt.g.length-1;k>=0;--k){
		        nt.g[k].disconnect();
		        nt.g[k].gain.cancelScheduledValues(0);
		      }
		    },
		    _limitVoices:function(ch,n){
		      this.notetab.sort(function(n1,n2){
		        if(n1.f!=n2.f) return n1.f-n2.f;
		        if(n1.e!=n2.e) return n2.e-n1.e;
		        return n2.t-n1.t;
		      });
		      for(var i=this.notetab.length-1;i>=0;--i){
		        var nt=this.notetab[i];
		        if(this.actx.currentTime>nt.e || i>=(this.voices-1)){
		          this._pruneNote(nt);
		          this.notetab.splice(i,1);
		        }
		      }
		    },
		    _note:function(t,ch,n,v,p){
		      var o=[],g=[],vp=[],fp=[],r=[],i,out,sc,pn;
		      var f=440*Math.pow(2,(n-69)/12);
		      this._limitVoices(ch,n);
		      for(i=0;i<p.length;++i){
		        pn=p[i];
		        var dt=t+pn.a+pn.h;
		        if(pn.g==0)
		          out=this.chvol[ch], sc=v*v/16384, fp[i]=f*pn.t+pn.f;
		        else if(pn.g>10)
		          out=g[pn.g-11].gain, sc=1, fp[i]=fp[pn.g-11]*pn.t+pn.f;
		        else if(o[pn.g-1].frequency)
		          out=o[pn.g-1].frequency, sc=fp[pn.g-1], fp[i]=fp[pn.g-1]*pn.t+pn.f;
		        else
		          out=o[pn.g-1].playbackRate, sc=fp[pn.g-1]/440, fp[i]=fp[pn.g-1]*pn.t+pn.f;
		        switch(pn.w[0]){
		        case "n":
		          o[i]=this.actx.createBufferSource();
		          o[i].buffer=this.noiseBuf[pn.w];
		          o[i].loop=true;
		          o[i].playbackRate.value=fp[i]/440;
		          if(pn.p!=1)
		            this._setParamTarget(o[i].playbackRate,fp[i]/440*pn.p,t,pn.q);
		          break;
		        default:
		          o[i]=this.actx.createOscillator();
		          o[i].frequency.value=fp[i];
		          if(pn.p!=1)
		            this._setParamTarget(o[i].frequency,fp[i]*pn.p,t,pn.q);
		          if(pn.w[0]=="w")
		            o[i].setPeriodicWave(this.wave[pn.w]);
		          else
		            o[i].type=pn.w;
		          this.chmod[ch].connect(o[i].detune);
		          o[i].detune.value=this.bend[ch];
		          break;
		        }
		        g[i]=this.actx.createGain();
		        r[i]=pn.r;
		        o[i].connect(g[i]); g[i].connect(out);
		        vp[i]=sc*pn.v;
		        if(pn.k)
		          vp[i]*=Math.pow(2,(n-60)/12*pn.k);
		        if(pn.a){
		          g[i].gain.value=0;
		          g[i].gain.setValueAtTime(0,t);
		          g[i].gain.linearRampToValueAtTime(vp[i],t+pn.a);
		        }
		        else
		          g[i].gain.setValueAtTime(vp[i],t);
		        this._setParamTarget(g[i].gain,pn.s*vp[i],dt,pn.d);
		        o[i].start(t);
		        if(this.rhythm[ch])
		          o[i].stop(t+p[0].d*this.releaseRatio);
		      }
		      if(!this.rhythm[ch])
		        this.notetab.push({t:t,e:99999,ch:ch,n:n,o:o,g:g,t2:t+pn.a,v:vp,r:r,f:0});
		    },
		    _setParamTarget:function(p,v,t,d){
		      if(d!=0)
		        p.setTargetAtTime(v,t,d);
		      else
		        p.setValueAtTime(v,t);
		    },
		    _releaseNote:function(nt,t){
		      if(nt.ch!=9){
		        for(var k=nt.g.length-1;k>=0;--k){
		          nt.g[k].gain.cancelScheduledValues(t);
		          if(t==nt.t2)
		            nt.g[k].gain.setValueAtTime(nt.v[k],t);
		          else if(t<nt.t2)
		            nt.g[k].gain.setValueAtTime(nt.v[k]*(t-nt.t)/(nt.t2-nt.t),t);
		          this._setParamTarget(nt.g[k].gain,0,t,nt.r[k]);
		        }
		      }
		      nt.e=t+nt.r[0]*this.releaseRatio;
		      nt.f=1;
		    },
		    setModulation:function(ch,v,t){
		      this.chmod[ch].gain.setValueAtTime(v*100/127,this._tsConv(t));
		    },
		    setChVol:function(ch,v,t){
		      this.vol[ch]=3*v*v/(127*127);
		      this.chvol[ch].gain.setValueAtTime(this.vol[ch]*this.ex[ch],this._tsConv(t));
		    },
		    setPan:function(ch,v,t){
		      if(this.chpan[ch])
		        this.chpan[ch].pan.setValueAtTime((v-64)/64,this._tsConv(t));
		    },
		    setExpression:function(ch,v,t){
		      this.ex[ch]=v*v/(127*127);
		      this.chvol[ch].gain.setValueAtTime(this.vol[ch]*this.ex[ch],this._tsConv(t));
		    },
		    setSustain:function(ch,v,t){
		      this.sustain[ch]=v;
		      t=this._tsConv(t);
		      if(v<64){
		        for(var i=this.notetab.length-1;i>=0;--i){
		          var nt=this.notetab[i];
		          if(t>=nt.t && nt.ch==ch && nt.f==1)
		            this._releaseNote(nt,t);
		        }
		      }
		    },
		    allSoundOff:function(ch){
		      for(var i=this.notetab.length-1;i>=0;--i){
		        var nt=this.notetab[i];
		        if(nt.ch==ch){
		          this._pruneNote(nt);
		          this.notetab.splice(i,1);
		        }
		      }
		    },
		    resetAllControllers:function(ch){
		      this.bend[ch]=0; this.ex[ch]=1.0;
		      this.rpnidx[ch]=0x3fff; this.sustain[ch]=0;
		      if(this.chvol[ch]){
		        this.chvol[ch].gain.value=this.vol[ch]*this.ex[ch];
		        this.chmod[ch].gain.value=0;
		      }
		    },
		    setBendRange:function(ch,v){
		      this.brange[ch]=v;
		    },
		    setProgram:function(ch,v){
		      if(this.debug)
		        console.log("Pg("+ch+")="+v);
		      this.pg[ch]=v;
		    },
		    setBend:function(ch,v,t){
		      t=this._tsConv(t);
		      var br=this.brange[ch]*100/127;
		      this.bend[ch]=(v-8192)*br/8192;
		      for(var i=this.notetab.length-1;i>=0;--i){
		        var nt=this.notetab[i];
		        if(nt.ch==ch){
		          for(var k=nt.o.length-1;k>=0;--k){
		            if(nt.o[k].frequency)
		              nt.o[k].detune.setValueAtTime(this.bend[ch],t);
		          }
		        }
		      }
		    },
		    noteOn:function(ch,n,v,t){
		      if(v==0){
		        this.noteOff(ch,n,t);
		        return;
		      }
		      t=this._tsConv(t);
		      if(this.rhythm[ch]){
		        if(n>=35&&n<=81)
		          this._note(t,ch,n,v,this.drummap[n-35].p);
		        return;
		      }
		      this._note(t,ch,n,v,this.program[this.pg[ch]].p);
		    },
		    noteOff:function(ch,n,t){
		      if(this.rhythm[ch])
		        return;
		      t=this._tsConv(t);
		      for(var i=this.notetab.length-1;i>=0;--i){
		        var nt=this.notetab[i];
		        if(t>=nt.t && nt.ch==ch && nt.n==n && nt.f==0){
		          nt.f=1;
		          if(this.sustain[ch]<64)
		            this._releaseNote(nt,t);
		        }
		      }
		    },
		    _tsConv:function(t){
		      if(t==undefined||t<=0){
		        t=0;
		        if(this.actx)
		          t=this.actx.currentTime;
		      }
		      else {
		        if(this.tsmode)
		          t=t*.001-this.tsdiff;
		      }
		      return t;
		    },
		    setTsMode:function(tsmode){
		      this.tsmode=tsmode;
		    },
		    send:function(msg,t){    /* send midi message */
		      var ch=msg[0]&0xf;
		      var cmd=msg[0]&~0xf;
		      if(cmd<0x80||cmd>=0x100)
		        return;
		      switch(cmd){
		      case 0xb0:  /* ctl change */
		        switch(msg[1]){
		        case 1:  this.setModulation(ch,msg[2],t); break;
		        case 7:  this.setChVol(ch,msg[2],t); break;
		        case 10: this.setPan(ch,msg[2],t); break;
		        case 11: this.setExpression(ch,msg[2],t); break;
		        case 64: this.setSustain(ch,msg[2],t); break;
		        case 98:  case 98: this.rpnidx[ch]=0x3fff; break; /* nrpn lsb/msb */
		        case 100: this.rpnidx[ch]=(this.rpnidx[ch]&0x380)|msg[2]; break; /* rpn lsb */
		        case 101: this.rpnidx[ch]=(this.rpnidx[ch]&0x7f)|(msg[2]<<7); break; /* rpn msb */
		        case 6:  /* data entry msb */
		          if(this.rpnidx[ch]==0)
		            this.brange[ch]=(msg[2]<<7)+(this.brange[ch]&0x7f);
		          break;
		        case 38:  /* data entry lsb */
		          if(this.rpnidx[ch]==0)
		            this.brange[ch]=(this.brange[ch]&0x380)|msg[2];
		          break;
		        case 120:  /* all sound off */
		        case 123:  /* all notes off */
		        case 124: case 125: case 126: case 127: /* omni off/on mono/poly */
		          this.allSoundOff(ch);
		          break;
		        case 121: this.resetAllControllers(ch); break;
		        }
		        break;
		      case 0xc0: this.setProgram(ch,msg[1]); break;
		      case 0xe0: this.setBend(ch,(msg[1]+(msg[2]<<7)),t); break;
		      case 0x90: this.noteOn(ch,msg[1],msg[2],t); break;
		      case 0x80: this.noteOff(ch,msg[1],t); break;
		      case 0xf0:
		        if(msg[0]!=254 && this.debug){
		          var ds=[];
		          for(var ii=0;ii<msg.length;++ii)
		            ds.push(msg[ii].toString(16));
		          console.log(ds);
		        }
		        if(msg[1]==0x41&&msg[2]==0x10&&msg[3]==0x42&&msg[4]==0x12&&msg[5]==0x40){
		          if((msg[6]&0xf0)==0x10&&msg[7]==0x15){
		            var ch=[9,0,1,2,3,4,5,6,7,8,10,11,12,13,14,15][msg[6]&0xf];
		            this.rhythm[ch]=msg[8];
		//            console.log("UseForRhythmPart("+ch+")="+msg[8]);
		          }
		        }
		        break;
		      }
		    },
		    _createWave:function(w){
		      var imag=new Float32Array(w.length);
		      var real=new Float32Array(w.length);
		      for(var i=1;i<w.length;++i)
		        imag[i]=w[i];
		      return this.actx.createPeriodicWave(real,imag);
		    },
		    getAudioContext:function(){
		      return this.actx;
		    },
		    setAudioContext:function(actx,dest){
		      this.audioContext=this.actx=actx;
		      this.dest=dest;
		      if(!dest)
		        this.dest=actx.destination;
		      this.tsdiff=performance.now()*.001-this.actx.currentTime;
		      // console.log("TSDiff:"+this.tsdiff);
		      this.out=this.actx.createGain();
		      this.comp=this.actx.createDynamicsCompressor();
		      var blen=this.actx.sampleRate*.5|0;
		      this.convBuf=this.actx.createBuffer(2,blen,this.actx.sampleRate);
		      this.noiseBuf={};
		      this.noiseBuf.n0=this.actx.createBuffer(1,blen,this.actx.sampleRate);
		      this.noiseBuf.n1=this.actx.createBuffer(1,blen,this.actx.sampleRate);
		      var d1=this.convBuf.getChannelData(0);
		      var d2=this.convBuf.getChannelData(1);
		      var dn=this.noiseBuf.n0.getChannelData(0);
		      var dr=this.noiseBuf.n1.getChannelData(0);
		      for(var i=0;i<blen;++i){
		        if(i/blen<Math.random()){
		          d1[i]=Math.exp(-3*i/blen)*(Math.random()-.5)*.5;
		          d2[i]=Math.exp(-3*i/blen)*(Math.random()-.5)*.5;
		        }
		        dn[i]=Math.random()*2-1;
		      }
		      for(var jj=0;jj<64;++jj){
		        var r1=Math.random()*10+1;
		        var r2=Math.random()*10+1;
		        for(i=0;i<blen;++i){
		          var dd=Math.sin((i/blen)*2*Math.PI*440*r1)*Math.sin((i/blen)*2*Math.PI*440*r2);
		          dr[i]+=dd/8;
		        }
		      }
		      if(this.useReverb){
		        this.conv=this.actx.createConvolver();
		        this.conv.buffer=this.convBuf;
		        this.rev=this.actx.createGain();
		        this.rev.gain.value=this.reverbLev;
		        this.out.connect(this.conv);
		        this.conv.connect(this.rev);
		        this.rev.connect(this.comp);
		      }
		      this.setMasterVol();
		      this.out.connect(this.comp);
		      this.comp.connect(this.dest);
		      this.chvol=[]; this.chmod=[]; this.chpan=[];
		      this.wave={"w9999":this._createWave("w9999")};
		      this.lfo=this.actx.createOscillator();
		      this.lfo.frequency.value=5;
		      this.lfo.start(0);
		      for(i=0;i<16;++i){
		        this.chvol[i]=this.actx.createGain();
		        if(this.actx.createStereoPanner){
		          this.chpan[i]=this.actx.createStereoPanner();
		          this.chvol[i].connect(this.chpan[i]);
		          this.chpan[i].connect(this.out);
		        }
		        else {
		          this.chpan[i]=null;
		          this.chvol[i].connect(this.out);
		        }
		        this.chmod[i]=this.actx.createGain();
		        this.lfo.connect(this.chmod[i]);
		        this.pg[i]=0;
		        this.resetAllControllers(i);
		      }
		      this.setReverbLev();
		      this.reset();
		      this.send([0x90,60,1]);
		      this.send([0x90,60,0]);
		    },
		  }
		/* webaudio-tinysynth coreobject */

		;
		  for(var k in this.sy.properties)
		    this[k]=this.sy.properties[k].value;
		  this.setQuality(1);
		  if(opt){
		    if(opt.useReverb!=undefined)
		      this.useReverb=opt.useReverb;
		    if(opt.quality!=undefined)
		      this.setQuality(opt.quality);
		    if(opt.voices!=undefined)
		      this.setVoices(opt.voices);
		  }
		  this.ready();
		}


		module.exports = WebAudioTinySynth;
		// Original source: https://raw.githubusercontent.com/g200kg/webaudio-tinysynth/master/webaudio-tinysynth.js 
	} (webaudioTinysynth));
	return webaudioTinysynth.exports;
}

var webaudioInstruments;
var hasRequiredWebaudioInstruments;

function requireWebaudioInstruments () {
	if (hasRequiredWebaudioInstruments) return webaudioInstruments;
	hasRequiredWebaudioInstruments = 1;

	var Synth = requireWebaudioTinysynth();

	webaudioInstruments = Player;


	function Player(audioContext, destination) {


	    // params
	    var instMin = 0;
	    var instMax = 127;
	    var drumMin = 35;
	    var drumMax = 81;



	    // internals
	    var synth = new Synth({
	        useReverb: 1,
	        quality: 1,
	        voices: 32,
	    });

	    if (audioContext) {
	        synth.setAudioContext(audioContext, destination);
	    }



	    // merge instruments and drums into one big list
	    var instCt = instMax - instMin + 1;
	    var drumCt = drumMax - drumMin + 1;
	    var names = [];
	    for (var i = 0; i < instCt; i++) names.push(synth.getTimbreName(0, i + instMin));
	    for (var j = 0; j < drumCt; j++) names.push(synth.getTimbreName(1, j + drumMin));




	    // Properties
	    this._synth = synth;
	    this.names = names;




	    // API

	    this.setQuality = function (q) {
	        synth.setQuality(q ? 1 : 0);
	    };

	    this.getCurrentTime = function () {
	        return synth.actx.currentTime
	    };

	    this.play = function (inst, note, vel, delay, duration, channel, attack) {
	        inst = inst || 0;
	        if (inst < 0 || inst > instMax + drumCt) throw 'Invalid instrument'
	        note = note || 60;
	        delay = delay || 0;
	        if (isNaN(vel)) vel = 0.5;
	        if (isNaN(duration)) duration = 0.5;
	        if (delay < 0) delay = 0;
	        play_impl(inst, note, vel, delay, duration, channel, attack);
	    };


	    function play_impl(inst, note, vel, delay, duration, channel, attack) {
	        var isDrums = (inst >= instCt);
	        // use passed-in channel value, defaulting to 0
	        channel = channel | 0;
	        if (isDrums) {
	            // drums use channel 9, and determine instrument based on the note
	            channel = 9;
	            note = inst + drumMin - instCt;
	        } else {
	            inst -= instMin;
	            synth.setProgram(channel, inst);
	        }
	        // play the note
	        var t = synth.actx.currentTime;
	        var intVel = (127 * vel) | 0;

	        // console.log([
	        //     'playing: ch=', channel,
	        //     '   inst=', inst,
	        //     '   note=', note,
	        //     '   intVel=', intVel,
	        //     '   delay=', delay,
	        // ].join(''))

	        var prog = synth.program[synth.pg[channel]].p;

	        if (note > 127) {
	            // assume note is a frequency in Hz if it's above 127
	            overrideParameter(prog, 'f', note);
	            overrideParameter(prog, 't', 0);
	        }
	        if (attack) overrideParameter(prog, 'a', attack);

	        // actual play command
	        synth.noteOn(channel, note, intVel, t + delay);
	        synth.noteOff(channel, note, t + delay + duration);

	        // undo overrides
	        if (note > 127) {
	            undoOverride(prog, 'f');
	            undoOverride(prog, 't');
	        }
	        if (attack) undoOverride(prog, 'a');

	    }





	    // temporarily override a program's parameters, for *source* oscillators
	    // e.g. override(0, 'f', 500) sets oscillator.f = 500 
	    // for all (oscillator.g==0), and caches overriden values

	    function overrideParameter(prog, param, value) {
	        var cache = overridden[param] || [0, 0, 0, 0, 0];
	        for (var i = 0; i < prog.length; i++) {
	            var osc = prog[i];
	            if (osc.g !== 0) continue
	            cache[i] = osc[param];
	            osc[param] = value;
	        }
	        overridden[param] = cache;
	    }
	    var overridden = {};

	    // undoes previous
	    function undoOverride(prog, param) {
	        var cache = overridden[param];
	        for (var i = 0; i < prog.length; i++) {
	            var osc = prog[i];
	            if (osc.g !== 0) continue
	            osc[param] = cache[i];
	        }
	    }





	}
	return webaudioInstruments;
}

var webaudioInstrumentsExports = requireWebaudioInstruments();
const Instruments = /*@__PURE__*/getDefaultExportFromCjs(webaudioInstrumentsExports);

/**
 * WEBMIDI.js v3.1.12
 * A JavaScript library to kickstart your MIDI projects
 * https://webmidijs.org
 * Build generated on November 22nd, 2024.
 *
 *  Copyright 2015-2024, Jean-Philippe Ct.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

/* Version: 3.1.12 - November 22, 2024 18:55:09 */
/**
 * The `EventEmitter` class provides methods to implement the _observable_ design pattern. This
 * pattern allows one to _register_ a function to execute when a specific event is _emitted_ by the
 * emitter.
 *
 * It is intended to be an abstract class meant to be extended by (or mixed into) other objects.
 */
class EventEmitter {

  /**
   * Creates a new `EventEmitter`object.
   *
   * @param {boolean} [eventsSuspended=false] Whether the `EventEmitter` is initially in a suspended
   * state (i.e. not executing callbacks).
   */
  constructor(eventsSuspended = false) {

    /**
     * An object containing a property for each event with at least one registered listener. Each
     * event property contains an array of all the [`Listener`]{@link Listener} objects registered
     * for the event.
     *
     * @type {Object}
     * @readonly
     */
    this.eventMap = {};

    /**
     * Whether or not the execution of callbacks is currently suspended for this emitter.
     *
     * @type {boolean}
     */
    this.eventsSuspended = eventsSuspended == true ? true : false;

  }

  /**
   * The callback function is executed when the associated event is triggered via [`emit()`](#emit).
   * The [`emit()`](#emit) method relays all additional arguments it received to the callback
   * functions. Since [`emit()`](#emit) can be passed a variable number of arguments, it is up to
   * the developer to make sure the arguments match those of the associated callback. In addition,
   * the callback also separately receives all the arguments present in the listener's
   * [`arguments`](Listener#arguments) property. This makes it easy to pass data from where the
   * listener is added to where the listener is executed.
   *
   * @callback EventEmitter~callback
   * @param {...*} [args] A variable number of arguments matching the ones (if any) that were passed
   * to the [`emit()`](#emit) method (except, the first one) followed by the arguments found in the
   * listener's [`arguments`](Listener#arguments) array.
   */

  /**
   * Adds a listener for the specified event. It returns the [`Listener`]{@link Listener} object
   * that was created and attached to the event.
   *
   * To attach a global listener that will be triggered for any events, use
   * [`EventEmitter.ANY_EVENT`]{@link #ANY_EVENT} as the first parameter. Note that a global
   * listener will also be triggered by non-registered events.
   *
   * @param {string|Symbol} event The event to listen to.
   * @param {EventEmitter~callback} callback The callback function to execute when the event occurs.
   * @param {Object} [options={}]
   * @param {Object} [options.context=this] The value of `this` in the callback function.
   * @param {boolean} [options.prepend=false] Whether the listener should be added at the beginning
   * of the listeners array and thus executed first.
   * @param {number} [options.duration=Infinity] The number of milliseconds before the listener
   * automatically expires.
   * @param {number} [options.remaining=Infinity] The number of times after which the callback
   * should automatically be removed.
   * @param {array} [options.arguments] An array of arguments which will be passed separately to the
   * callback function. This array is stored in the [`arguments`]{@link Listener#arguments}
   * property of the [`Listener`]{@link Listener} object and can be retrieved or modified as
   * desired.
   *
   * @returns {Listener} The newly created [`Listener`]{@link Listener} object.
   *
   * @throws {TypeError} The `event` parameter must be a string or
   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT}.
   * @throws {TypeError} The `callback` parameter must be a function.
   */
  addListener(event, callback, options = {}) {

    if (
      (typeof event === "string" && event.length < 1) ||
      (event instanceof String && event.length < 1) ||
      (typeof event !== "string" && !(event instanceof String) && event !== EventEmitter.ANY_EVENT)
    ) {
      throw new TypeError("The 'event' parameter must be a string or EventEmitter.ANY_EVENT.");
    }

    if (typeof callback !== "function") throw new TypeError("The callback must be a function.");

    const listener = new Listener(event, this, callback, options);

    if (!this.eventMap[event]) this.eventMap[event] = [];

    if (options.prepend) {
      this.eventMap[event].unshift(listener);
    } else {
      this.eventMap[event].push(listener);
    }

    return listener;

  }

  /**
   * Adds a one-time listener for the specified event. The listener will be executed once and then
   * destroyed. It returns the [`Listener`]{@link Listener} object that was created and attached
   * to the event.
   *
   * To attach a global listener that will be triggered for any events, use
   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} as the first parameter. Note that a
   * global listener will also be triggered by non-registered events.
   *
   * @param {string|Symbol} event The event to listen to
   * @param {EventEmitter~callback} callback The callback function to execute when the event occurs
   * @param {Object} [options={}]
   * @param {Object} [options.context=this] The context to invoke the callback function in.
   * @param {boolean} [options.prepend=false] Whether the listener should be added at the beginning
   * of the listeners array and thus executed first.
   * @param {number} [options.duration=Infinity] The number of milliseconds before the listener
   * automatically expires.
   * @param {array} [options.arguments] An array of arguments which will be passed separately to the
   * callback function. This array is stored in the [`arguments`]{@link Listener#arguments}
   * property of the [`Listener`]{@link Listener} object and can be retrieved or modified as
   * desired.
   *
   * @returns {Listener} The newly created [`Listener`]{@link Listener} object.
   *
   * @throws {TypeError} The `event` parameter must be a string or
   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT}.
   * @throws {TypeError} The `callback` parameter must be a function.
   */
  addOneTimeListener(event, callback, options = {}) {
    options.remaining = 1;
    this.addListener(event, callback, options);
  }

  /**
   * Identifier to use when adding or removing a listener that should be triggered when any events
   * occur.
   *
   * @type {Symbol}
   */
  static get ANY_EVENT() {
    return Symbol.for("Any event");
  }

  /**
   * Returns `true` if the specified event has at least one registered listener. If no event is
   * specified, the method returns `true` if any event has at least one listener registered (this
   * includes global listeners registered to
   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT}).
   *
   * Note: to specifically check for global listeners added with
   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT}, use
   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} as the parameter.
   *
   * @param {string|Symbol} [event=(any event)] The event to check
   * @param {function|Listener} [callback=(any callback)] The actual function that was added to the
   * event or the {@link Listener} object returned by `addListener()`.
   * @returns {boolean}
   */
  hasListener(event, callback) {

    if (event === undefined) {

      // Check for ANY_EVENT
      if (
        this.eventMap[EventEmitter.ANY_EVENT] && this.eventMap[EventEmitter.ANY_EVENT].length > 0
      ) {
        return true;
      }

      // Check for any regular events
      return Object.entries(this.eventMap).some(([, value]) => {
        return value.length > 0;
      });

    } else {

      if (this.eventMap[event] && this.eventMap[event].length > 0) {

        if (callback instanceof Listener) {
          let result = this.eventMap[event].filter(listener => listener === callback);
          return result.length > 0;
        } else if (typeof callback === "function") {
          let result = this.eventMap[event].filter(listener => listener.callback === callback);
          return result.length > 0;
        } else if (callback != undefined) {
          return false;
        }

        return true;

      } else {
        return false;
      }


    }

  }

  /**
   * An array of all the unique event names for which the emitter has at least one registered
   * listener.
   *
   * Note: this excludes global events registered with
   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} because they are not tied to a
   * specific event.
   *
   * @type {string[]}
   * @readonly
   */
  get eventNames() {
    return Object.keys(this.eventMap);
  }

  /**
   * Returns an array of all the [`Listener`]{@link Listener} objects that have been registered for
   * a specific event.
   *
   * Please note that global events (those added with
   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT}) are not returned for "regular"
   * events. To get the list of global listeners, specifically use
   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} as the parameter.
   *
   * @param {string|Symbol} event The event to get listeners for.
   * @returns {Listener[]} An array of [`Listener`]{@link Listener} objects.
   */
  getListeners(event) {
    return this.eventMap[event] || [];
  }

  /**
   * Suspends execution of all callbacks functions registered for the specified event type.
   *
   * You can suspend execution of callbacks registered with
   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} by passing
   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} to `suspendEvent()`. Beware that this
   * will not suspend all callbacks but only those registered with
   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT}. While this may seem counter-intuitive
   * at first glance, it allows the selective suspension of global listeners while leaving other
   * listeners alone. If you truly want to suspends all callbacks for a specific
   * [`EventEmitter`]{@link EventEmitter}, simply set its `eventsSuspended` property to `true`.
   *
   * @param {string|Symbol} event The event name (or `EventEmitter.ANY_EVENT`) for which to suspend
   * execution of all callback functions.
   */
  suspendEvent(event) {
    this.getListeners(event).forEach(listener => {
      listener.suspended = true;
    });
  }

  /**
   * Resumes execution of all suspended callback functions registered for the specified event type.
   *
   * You can resume execution of callbacks registered with
   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} by passing
   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} to `unsuspendEvent()`. Beware that
   * this will not resume all callbacks but only those registered with
   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT}. While this may seem
   * counter-intuitive, it allows the selective unsuspension of global listeners while leaving other
   * callbacks alone.
   *
   * @param {string|Symbol} event The event name (or `EventEmitter.ANY_EVENT`) for which to resume
   * execution of all callback functions.
   */
  unsuspendEvent(event) {
    this.getListeners(event).forEach(listener => {
      listener.suspended = false;
    });
  }

  /**
   * Returns the number of listeners registered for a specific event.
   *
   * Please note that global events (those added with
   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT}) do not count towards the remaining
   * number for a "regular" event. To get the number of global listeners, specifically use
   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} as the parameter.
   *
   * @param {string|Symbol} event The event which is usually a string but can also be the special
   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} symbol.
   * @returns {number} An integer representing the number of listeners registered for the specified
   * event.
   */
  getListenerCount(event) {
    return this.getListeners(event).length;
  }

  /**
   * Executes the callback function of all the [`Listener`]{@link Listener} objects registered for
   * a given event. The callback functions are passed the additional arguments passed to `emit()`
   * (if any) followed by the arguments present in the [`arguments`](Listener#arguments) property of
   * the [`Listener`](Listener) object (if any).
   *
   * If the [`eventsSuspended`]{@link #eventsSuspended} property is `true` or the
   * [`Listener.suspended`]{@link Listener#suspended} property is `true`, the callback functions
   * will not be executed.
   *
   * This function returns an array containing the return values of each of the callbacks.
   *
   * It should be noted that the regular listeners are triggered first followed by the global
   * listeners (those added with [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT}).
   *
   * @param {string} event The event
   * @param {...*} args Arbitrary number of arguments to pass along to the callback functions
   *
   * @returns {Array} An array containing the return value of each of the executed listener
   * functions.
   *
   * @throws {TypeError} The `event` parameter must be a string.
   */
  emit(event, ...args) {

    if (typeof event !== "string" && !(event instanceof String)) {
      throw new TypeError("The 'event' parameter must be a string.");
    }

    if (this.eventsSuspended) return;

    // We collect return values from all listeners here
    let results = [];

    // We must make sure that we do not have undefined otherwise concat() will add an undefined
    // entry in the array.
    let listeners = this.eventMap[EventEmitter.ANY_EVENT] || [];
    if (this.eventMap[event]) listeners = listeners.concat(this.eventMap[event]);

    listeners.forEach(listener => {

      // This is the per-listener suspension check
      if (listener.suspended) return;

      let params = [...args];
      if (Array.isArray(listener.arguments)) params = params.concat(listener.arguments);

      if (listener.remaining > 0) {
        results.push(listener.callback.apply(listener.context, params));
        listener.count++;
      }

      if (--listener.remaining < 1) listener.remove();

    });

    return results;

  }

  /**
   * Removes all the listeners that were added to the object upon which the method is called and
   * that match the specified criterias. If no parameters are passed, all listeners added to this
   * object will be removed. If only the `event` parameter is passed, all listeners for that event
   * will be removed from that object. You can remove global listeners by using
   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} as the first parameter.
   *
   * To use more granular options, you must at least define the `event`. Then, you can specify the
   * callback to match or one or more of the additional options.
   *
   * @param {string} [event] The event name.
   * @param {EventEmitter~callback} [callback] Only remove the listeners that match this exact
   * callback function.
   * @param {Object} [options]
   * @param {*} [options.context] Only remove the listeners that have this exact context.
   * @param {number} [options.remaining] Only remove the listener if it has exactly that many
   * remaining times to be executed.
   */
  removeListener(event, callback, options = {}) {

    if (event === undefined) {
      this.eventMap = {};
      return;
    } else if (!this.eventMap[event]) {
      return;
    }

    // Find listeners that do not match the criterias (those are the ones we will keep)
    let listeners = this.eventMap[event].filter(listener => {

      return (callback && listener.callback !== callback) ||
        (options.remaining && options.remaining !== listener.remaining) ||
        (options.context && options.context !== listener.context);

    });

    if (listeners.length) {
      this.eventMap[event] = listeners;
    } else {
      delete this.eventMap[event];
    }

  }

  /**
   * The `waitFor()` method is an async function which returns a promise. The promise is fulfilled
   * when the specified event occurs. The event can be a regular event or
   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} (if you want to resolve as soon as any
   * event is emitted).
   *
   * If the `duration` option is set, the promise will only be fulfilled if the event is emitted
   * within the specified duration. If the event has not been fulfilled after the specified
   * duration, the promise is rejected. This makes it super easy to wait for an event and timeout
   * after a certain time if the event is not triggered.
   *
   * @param {string|Symbol} event The event to wait for
   * @param {Object} [options={}]
   * @param {number} [options.duration=Infinity] The number of milliseconds to wait before the
   * promise is automatically rejected.
   */
  async waitFor(event, options = {}) {

    options.duration = parseInt(options.duration);
    if (isNaN(options.duration) || options.duration <= 0) options.duration = Infinity;

    return new Promise((resolve, reject) => {

      let timeout;

      let listener = this.addListener(event, () => {
        clearTimeout(timeout);
        resolve();
      }, {remaining: 1});

      if (options.duration !== Infinity) {
        timeout = setTimeout(() => {
          listener.remove();
          reject("The duration expired before the event was emitted.");
        }, options.duration);
      }

    });

  }

  /**
   * The number of unique events that have registered listeners.
   *
   * Note: this excludes global events registered with
   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} because they are not tied to a
   * specific event.
   *
   * @type {number}
   * @readonly
   */
  get eventCount() {
    return Object.keys(this.eventMap).length;
  }

}

/**
 * The `Listener` class represents a single event listener object. Such objects keep all relevant
 * contextual information such as the event being listened to, the object the listener was attached
 * to, the callback function and so on.
 *
 */
class Listener {

  /**
   * Creates a new `Listener` object
   *
   * @param {string|Symbol} event The event being listened to
   * @param {EventEmitter} target The [`EventEmitter`]{@link EventEmitter} object that the listener
   * is attached to.
   * @param {EventEmitter~callback} callback The function to call when the listener is triggered
   * @param {Object} [options={}]
   * @param {Object} [options.context=target] The context to invoke the listener in (a.k.a. the
   * value of `this` inside the callback function).
   * @param {number} [options.remaining=Infinity] The remaining number of times after which the
   * callback should automatically be removed.
   * @param {array} [options.arguments] An array of arguments that will be passed separately to the
   * callback function upon execution. The array is stored in the [`arguments`]{@link #arguments}
   * property and can be retrieved or modified as desired.
   *
   * @throws {TypeError} The `event` parameter must be a string or
   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT}.
   * @throws {ReferenceError} The `target` parameter is mandatory.
   * @throws {TypeError} The `callback` must be a function.
   */
  constructor(event, target, callback, options = {}) {

    if (
      typeof event !== "string" &&
      !(event instanceof String) &&
      event !== EventEmitter.ANY_EVENT
    ) {
      throw new TypeError("The 'event' parameter must be a string or EventEmitter.ANY_EVENT.");
    }

    if (!target) {
      throw new ReferenceError("The 'target' parameter is mandatory.");
    }

    if (typeof callback !== "function") {
      throw new TypeError("The 'callback' must be a function.");
    }

    // Convert single value argument to array
    if (options.arguments !== undefined && !Array.isArray(options.arguments)) {
      options.arguments = [options.arguments];
    }

    // Define default options and merge declared options into them,
    options = Object.assign({
      context: target,
      remaining: Infinity,
      arguments: undefined,
      duration: Infinity,
    }, options);

    // Make sure it is eventually deleted if a duration is supplied
    if (options.duration !== Infinity) {
      setTimeout(() => this.remove(), options.duration);
    }

    /**
     * An array of arguments to pass to the callback function upon execution.
     * @type {array}
     */
    this.arguments = options.arguments;

    /**
     * The callback function to execute.
     * @type {Function}
     */
    this.callback = callback;

    /**
     * The context to execute the callback function in (a.k.a. the value of `this` inside the
     * callback function)
     * @type {Object}
     */
    this.context = options.context;

    /**
     * The number of times the listener function was executed.
     * @type {number}
     */
    this.count = 0;

    /**
     * The event name.
     * @type {string}
     */
    this.event = event;

    /**
     * The remaining number of times after which the callback should automatically be removed.
     * @type {number}
     */
    this.remaining = parseInt(options.remaining) >= 1 ? parseInt(options.remaining) : Infinity;

    /**
     * Whether this listener is currently suspended or not.
     * @type {boolean}
     */
    this.suspended = false;

    /**
     * The object that the event is attached to (or that emitted the event).
     * @type {EventEmitter}
     */
    this.target = target;

  }

  /**
   * Removes the listener from its target.
   */
  remove() {
    this.target.removeListener(
      this.event,
      this.callback,
      {context: this.context, remaining: this.remaining}
    );
  }

}

/**
 * The `Enumerations` class contains enumerations and arrays of elements used throughout the
 * library. All its properties are static and should be referenced using the class name. For
 * example: `Enumerations.CHANNEL_MESSAGES`.
 *
 * @license Apache-2.0
 * @since 3.0.0
 */
class Enumerations {

  /**
   * @enum {Object.<string, number>}
   * @readonly
   * @deprecated since 3.1 (use Enumerations.CHANNEL_MESSAGES instead)
   * @private
   * @static
   */
  static get MIDI_CHANNEL_MESSAGES() {

    if (this.validation) {
      console.warn(
        "The MIDI_CHANNEL_MESSAGES enum has been deprecated. Use the " +
        "Enumerations.CHANNEL_MESSAGES enum instead."
      );
    }

    return Enumerations.CHANNEL_MESSAGES;

  }

  /**
   * Enumeration of all MIDI channel message names and their associated 4-bit numerical value:
   *
   * | Message Name        | Hexadecimal | Decimal |
   * |---------------------|-------------|---------|
   * | `noteoff`           | 0x8         | 8       |
   * | `noteon`            | 0x9         | 9       |
   * | `keyaftertouch`     | 0xA         | 10      |
   * | `controlchange`     | 0xB         | 11      |
   * | `programchange`     | 0xC         | 12      |
   * | `channelaftertouch` | 0xD         | 13      |
   * | `pitchbend`         | 0xE         | 14      |
   *
   * @enum {Object.<string, number>}
   * @readonly
   * @since 3.1
   * @static
   */
  static get CHANNEL_MESSAGES() {

    return {
      noteoff: 0x8,           // 8
      noteon: 0x9,            // 9
      keyaftertouch: 0xA,     // 10
      controlchange: 0xB,     // 11
      programchange: 0xC,     // 12
      channelaftertouch: 0xD, // 13
      pitchbend: 0xE          // 14
    };

  }

  /**
   * A simple array of the 16 valid MIDI channel numbers (`1` to `16`):
   *
   * @type {number[]}
   * @readonly
   * @since 3.1
   * @static
   */
  static get CHANNEL_NUMBERS() {
    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];
  }

  /**
   * @type {number[]}
   * @readonly
   * @deprecated since 3.1 (use Enumerations.CHANNEL_NUMBERS instead)
   * @private
   * @static
   */
  static get MIDI_CHANNEL_NUMBERS() {

    if (this.validation) {
      console.warn(
        "The MIDI_CHANNEL_NUMBERS array has been deprecated. Use the " +
        "Enumerations.CHANNEL_NUMBERS array instead."
      );
    }

    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];

  }

  /**
   * Enumeration of all MIDI channel mode message names and their associated numerical value:
   *
   *
   * | Message Name          | Hexadecimal | Decimal |
   * |-----------------------|-------------|---------|
   * | `allsoundoff`         | 0x78        | 120     |
   * | `resetallcontrollers` | 0x79        | 121     |
   * | `localcontrol`        | 0x7A        | 122     |
   * | `allnotesoff`         | 0x7B        | 123     |
   * | `omnimodeoff`         | 0x7C        | 124     |
   * | `omnimodeon`          | 0x7D        | 125     |
   * | `monomodeon`          | 0x7E        | 126     |
   * | `polymodeon`          | 0x7F        | 127     |
   *
   * @enum {Object.<string, number>}
   * @readonly
   * @since 3.1
   * @static
   */
  static get CHANNEL_MODE_MESSAGES() {

    return {
      allsoundoff: 120,
      resetallcontrollers: 121,
      localcontrol: 122,
      allnotesoff: 123,
      omnimodeoff: 124,
      omnimodeon: 125,
      monomodeon: 126,
      polymodeon: 127
    };

  }

  /**
   * @enum {Object.<string, number>}
   * @deprecated since 3.1 (use Enumerations.CHANNEL_MODE_MESSAGES instead)
   * @private
   * @readonly
   * @static
   */
  static get MIDI_CHANNEL_MODE_MESSAGES() {

    if (this.validation) {
      console.warn(
        "The MIDI_CHANNEL_MODE_MESSAGES enum has been deprecated. Use the " +
        "Enumerations.CHANNEL_MODE_MESSAGES enum instead."
      );
    }

    return Enumerations.CHANNEL_MODE_MESSAGES;

  }

  /**
   * @enum {Object.<string, number>}
   * @readonly
   * @static
   * @private
   * @deprecated since version 3.0.26 (use `CONTROL_CHANGE_MESSAGES` instead)
   */
  static get MIDI_CONTROL_CHANGE_MESSAGES() {

    if (this.validation) {
      console.warn(
        "The MIDI_CONTROL_CHANGE_MESSAGES enum has been deprecated. Use the " +
        "Enumerations.CONTROL_CHANGE_MESSAGES array instead."
      );
    }

    return {

      bankselectcoarse: 0,
      modulationwheelcoarse: 1,
      breathcontrollercoarse: 2,
      controller3: 3,
      footcontrollercoarse: 4,
      portamentotimecoarse: 5,
      dataentrycoarse: 6,
      volumecoarse: 7,
      balancecoarse: 8,
      controller9: 9,
      pancoarse: 10,
      expressioncoarse: 11,
      effectcontrol1coarse: 12,
      effectcontrol2coarse: 13,
      controller14: 14,
      controller15: 15,
      generalpurposeslider1: 16,
      generalpurposeslider2: 17,
      generalpurposeslider3: 18,
      generalpurposeslider4: 19,
      controller20: 20,
      controller21: 21,
      controller22: 22,
      controller23: 23,
      controller24: 24,
      controller25: 25,
      controller26: 26,
      controller27: 27,
      controller28: 28,
      controller29: 29,
      controller30: 30,
      controller31: 31,
      bankselectfine: 32,
      modulationwheelfine: 33,
      breathcontrollerfine: 34,
      controller35: 35,
      footcontrollerfine: 36,
      portamentotimefine: 37,
      dataentryfine: 38,
      volumefine: 39,
      balancefine: 40,
      controller41: 41,
      panfine: 42,
      expressionfine: 43,
      effectcontrol1fine: 44,
      effectcontrol2fine: 45,
      controller46: 46,
      controller47: 47,
      controller48: 48,
      controller49: 49,
      controller50: 50,
      controller51: 51,
      controller52: 52,
      controller53: 53,
      controller54: 54,
      controller55: 55,
      controller56: 56,
      controller57: 57,
      controller58: 58,
      controller59: 59,
      controller60: 60,
      controller61: 61,
      controller62: 62,
      controller63: 63,
      holdpedal: 64,
      portamento: 65,
      sustenutopedal: 66,
      softpedal: 67,
      legatopedal: 68,
      hold2pedal: 69,
      soundvariation: 70,
      resonance: 71,
      soundreleasetime: 72,
      soundattacktime: 73,
      brightness: 74,
      soundcontrol6: 75,
      soundcontrol7: 76,
      soundcontrol8: 77,
      soundcontrol9: 78,
      soundcontrol10: 79,
      generalpurposebutton1: 80,
      generalpurposebutton2: 81,
      generalpurposebutton3: 82,
      generalpurposebutton4: 83,
      controller84: 84,
      controller85: 85,
      controller86: 86,
      controller87: 87,
      controller88: 88,
      controller89: 89,
      controller90: 90,
      reverblevel: 91,
      tremololevel: 92,
      choruslevel: 93,
      celestelevel: 94,
      phaserlevel: 95,
      databuttonincrement: 96,
      databuttondecrement: 97,
      nonregisteredparametercoarse: 98,
      nonregisteredparameterfine: 99,
      registeredparametercoarse: 100,
      registeredparameterfine: 101,
      controller102: 102,
      controller103: 103,
      controller104: 104,
      controller105: 105,
      controller106: 106,
      controller107: 107,
      controller108: 108,
      controller109: 109,
      controller110: 110,
      controller111: 111,
      controller112: 112,
      controller113: 113,
      controller114: 114,
      controller115: 115,
      controller116: 116,
      controller117: 117,
      controller118: 118,
      controller119: 119,
      allsoundoff: 120,
      resetallcontrollers: 121,
      localcontrol: 122,
      allnotesoff: 123,
      omnimodeoff: 124,
      omnimodeon: 125,
      monomodeon: 126,
      polymodeon: 127

    };

  }

  /**
   * An array of objects, ordered by control number, describing control change messages. Each object
   * in the array has 3 properties with some objects having a fourth one (`position`) :
   *
   *  * `number`: MIDI control number (0-127);
   *  * `name`: name of emitted event (eg: `bankselectcoarse`, `choruslevel`, etc) that can be
   *  listened to;
   *  * `description`: user-friendly description of the controller's purpose;
   *  * `position` (optional): whether this controller's value should be considered an `msb` or
   *  `lsb`
   *
   * Not all controllers have a predefined function. For those that don't, `name` is the word
   * "controller" followed by the number (e.g. `controller112`).
   *
   * | Event name                     | Control Number |
   * |--------------------------------|----------------|
   * | `bankselectcoarse`             | 0              |
   * | `modulationwheelcoarse`        | 1              |
   * | `breathcontrollercoarse`       | 2              |
   * | `controller3`                  | 3              |
   * | `footcontrollercoarse`         | 4              |
   * | `portamentotimecoarse`         | 5              |
   * | `dataentrycoarse`              | 6              |
   * | `volumecoarse`                 | 7              |
   * | `balancecoarse`                | 8              |
   * | `controller9`                  | 9              |
   * | `pancoarse`                    | 10             |
   * | `expressioncoarse`             | 11             |
   * | `effectcontrol1coarse`         | 12             |
   * | `effectcontrol2coarse`         | 13             |
   * | `controller14`                 | 14             |
   * | `controller15`                 | 15             |
   * | `generalpurposecontroller1`    | 16             |
   * | `generalpurposecontroller2`    | 17             |
   * | `generalpurposecontroller3`    | 18             |
   * | `generalpurposecontroller4`    | 19             |
   * | `controller20`                 | 20             |
   * | `controller21`                 | 21             |
   * | `controller22`                 | 22             |
   * | `controller23`                 | 23             |
   * | `controller24`                 | 24             |
   * | `controller25`                 | 25             |
   * | `controller26`                 | 26             |
   * | `controller27`                 | 27             |
   * | `controller28`                 | 28             |
   * | `controller29`                 | 29             |
   * | `controller30`                 | 30             |
   * | `controller31`                 | 31             |
   * | `bankselectfine`               | 32             |
   * | `modulationwheelfine`          | 33             |
   * | `breathcontrollerfine`         | 34             |
   * | `controller35`                 | 35             |
   * | `footcontrollerfine`           | 36             |
   * | `portamentotimefine`           | 37             |
   * | `dataentryfine`                | 38             |
   * | `channelvolumefine`            | 39             |
   * | `balancefine`                  | 40             |
   * | `controller41`                 | 41             |
   * | `panfine`                      | 42             |
   * | `expressionfine`               | 43             |
   * | `effectcontrol1fine`           | 44             |
   * | `effectcontrol2fine`           | 45             |
   * | `controller46`                 | 46             |
   * | `controller47`                 | 47             |
   * | `controller48`                 | 48             |
   * | `controller49`                 | 49             |
   * | `controller50`                 | 50             |
   * | `controller51`                 | 51             |
   * | `controller52`                 | 52             |
   * | `controller53`                 | 53             |
   * | `controller54`                 | 54             |
   * | `controller55`                 | 55             |
   * | `controller56`                 | 56             |
   * | `controller57`                 | 57             |
   * | `controller58`                 | 58             |
   * | `controller59`                 | 59             |
   * | `controller60`                 | 60             |
   * | `controller61`                 | 61             |
   * | `controller62`                 | 62             |
   * | `controller63`                 | 63             |
   * | `damperpedal`                  | 64             |
   * | `portamento`                   | 65             |
   * | `sostenuto`                    | 66             |
   * | `softpedal`                    | 67             |
   * | `legatopedal`                  | 68             |
   * | `hold2`                        | 69             |
   * | `soundvariation`               | 70             |
   * | `resonance`                    | 71             |
   * | `releasetime`                  | 72             |
   * | `attacktime`                   | 73             |
   * | `brightness`                   | 74             |
   * | `decaytime`                    | 75             |
   * | `vibratorate`                  | 76             |
   * | `vibratodepth`                 | 77             |
   * | `vibratodelay`                 | 78             |
   * | `controller79`                 | 79             |
   * | `generalpurposecontroller5`    | 80             |
   * | `generalpurposecontroller6`    | 81             |
   * | `generalpurposecontroller7`    | 82             |
   * | `generalpurposecontroller8`    | 83             |
   * | `portamentocontrol`            | 84             |
   * | `controller85`                 | 85             |
   * | `controller86`                 | 86             |
   * | `controller87`                 | 87             |
   * | `highresolutionvelocityprefix` | 88             |
   * | `controller89`                 | 89             |
   * | `controller90`                 | 90             |
   * | `effect1depth`                 | 91             |
   * | `effect2depth`                 | 92             |
   * | `effect3depth`                 | 93             |
   * | `effect4depth`                 | 94             |
   * | `effect5depth`                 | 95             |
   * | `dataincrement`                | 96             |
   * | `datadecrement`                | 97             |
   * | `nonregisteredparameterfine`   | 98             |
   * | `nonregisteredparametercoarse` | 99             |
   * | `nonregisteredparameterfine`   | 100            |
   * | `registeredparametercoarse`    | 101            |
   * | `controller102`                | 102            |
   * | `controller103`                | 103            |
   * | `controller104`                | 104            |
   * | `controller105`                | 105            |
   * | `controller106`                | 106            |
   * | `controller107`                | 107            |
   * | `controller108`                | 108            |
   * | `controller109`                | 109            |
   * | `controller110`                | 110            |
   * | `controller111`                | 111            |
   * | `controller112`                | 112            |
   * | `controller113`                | 113            |
   * | `controller114`                | 114            |
   * | `controller115`                | 115            |
   * | `controller116`                | 116            |
   * | `controller117`                | 117            |
   * | `controller118`                | 118            |
   * | `controller119`                | 119            |
   * | `allsoundoff`                  | 120            |
   * | `resetallcontrollers`          | 121            |
   * | `localcontrol`                 | 122            |
   * | `allnotesoff`                  | 123            |
   * | `omnimodeoff`                  | 124            |
   * | `omnimodeon`                   | 125            |
   * | `monomodeon`                   | 126            |
   * | `polymodeon`                   | 127            |
   *
   * @type {object[]}
   * @readonly
   * @static
   * @since 3.1
   */
  static get CONTROL_CHANGE_MESSAGES() {

    return [
      {
        number: 0,
        name: "bankselectcoarse",
        description: "Bank Select (Coarse)",
        position: "msb"
      },
      {
        number: 1,
        name: "modulationwheelcoarse",
        description: "Modulation Wheel (Coarse)",
        position: "msb"
      },
      {
        number: 2,
        name: "breathcontrollercoarse",
        description: "Breath Controller (Coarse)",
        position: "msb"
      },
      {
        number: 3,
        name: "controller3",
        description: "Undefined",
        position: "msb"
      },
      {
        number: 4,
        name: "footcontrollercoarse",
        description: "Foot Controller (Coarse)",
        position: "msb"
      },
      {
        number: 5,
        name: "portamentotimecoarse",
        description: "Portamento Time (Coarse)",
        position: "msb"
      },
      {
        number: 6,
        name: "dataentrycoarse",
        description: "Data Entry (Coarse)",
        position: "msb"
      },
      {
        number: 7,
        name: "volumecoarse",
        description: "Channel Volume (Coarse)",
        position: "msb"
      },
      {
        number: 8,
        name: "balancecoarse",
        description: "Balance (Coarse)",
        position: "msb"
      },
      {
        number: 9,
        name: "controller9",
        description: "Controller 9 (Coarse)",
        position: "msb"
      },
      {
        number: 10,
        name: "pancoarse",
        description: "Pan (Coarse)",
        position: "msb"
      },
      {
        number: 11,
        name: "expressioncoarse",
        description: "Expression Controller (Coarse)",
        position: "msb"
      },
      {
        number: 12,
        name: "effectcontrol1coarse",
        description: "Effect Control 1 (Coarse)",
        position: "msb"
      },
      {
        number: 13,
        name: "effectcontrol2coarse",
        description: "Effect Control 2 (Coarse)",
        position: "msb"
      },
      {
        number: 14,
        name: "controller14",
        description: "Undefined",
        position: "msb"
      },
      {
        number: 15,
        name: "controller15",
        description: "Undefined",
        position: "msb"
      },
      {
        number: 16,
        name: "generalpurposecontroller1",
        description: "General Purpose Controller 1 (Coarse)",
        position: "msb"
      },
      {
        number: 17,
        name: "generalpurposecontroller2",
        description: "General Purpose Controller 2 (Coarse)",
        position: "msb"
      },
      {
        number: 18,
        name: "generalpurposecontroller3",
        description: "General Purpose Controller 3 (Coarse)",
        position: "msb"
      },
      {
        number: 19,
        name: "generalpurposecontroller4",
        description: "General Purpose Controller 4 (Coarse)",
        position: "msb"
      },
      {
        number: 20,
        name: "controller20",
        description: "Undefined",
        position: "msb"
      },
      {
        number: 21,
        name: "controller21",
        description: "Undefined",
        position: "msb"
      },
      {
        number: 22,
        name: "controller22",
        description: "Undefined",
        position: "msb"
      },
      {
        number: 23,
        name: "controller23",
        description: "Undefined",
        position: "msb"
      },
      {
        number: 24,
        name: "controller24",
        description: "Undefined",
        position: "msb"
      },
      {
        number: 25,
        name: "controller25",
        description: "Undefined",
        position: "msb"
      },
      {
        number: 26,
        name: "controller26",
        description: "Undefined",
        position: "msb"
      },
      {
        number: 27,
        name: "controller27",
        description: "Undefined",
        position: "msb"
      },
      {
        number: 28,
        name: "controller28",
        description: "Undefined",
        position: "msb"
      },
      {
        number: 29,
        name: "controller29",
        description: "Undefined",
        position: "msb"
      },
      {
        number: 30,
        name: "controller30",
        description: "Undefined",
        position: "msb"
      },
      {
        number: 31,
        name: "controller31",
        description: "Undefined",
        position: "msb"
      },
      {
        number: 32,
        name: "bankselectfine",
        description: "Bank Select (Fine)",
        position: "lsb"
      },
      {
        number: 33,
        name: "modulationwheelfine",
        description: "Modulation Wheel (Fine)",
        position: "lsb"
      },
      {
        number: 34,
        name: "breathcontrollerfine",
        description: "Breath Controller (Fine)",
        position: "lsb"
      },
      {
        number: 35,
        name: "controller35",
        description: "Undefined",
        position: "lsb"
      },
      {
        number: 36,
        name: "footcontrollerfine",
        description: "Foot Controller (Fine)",
        position: "lsb"
      },
      {
        number: 37,
        name: "portamentotimefine",
        description: "Portamento Time (Fine)",
        position: "lsb"
      },
      {
        number: 38,
        name: "dataentryfine",
        description: "Data Entry (Fine)",
        position: "lsb"
      },
      {
        number: 39,
        name: "channelvolumefine",
        description: "Channel Volume (Fine)",
        position: "lsb"
      },
      {
        number: 40,
        name: "balancefine",
        description: "Balance (Fine)",
        position: "lsb"
      },
      {
        number: 41,
        name: "controller41",
        description: "Undefined",
        position: "lsb"
      },
      {
        number: 42,
        name: "panfine",
        description: "Pan (Fine)",
        position: "lsb"
      },
      {
        number: 43,
        name: "expressionfine",
        description: "Expression Controller (Fine)",
        position: "lsb"
      },
      {
        number: 44,
        name: "effectcontrol1fine",
        description: "Effect control 1 (Fine)",
        position: "lsb"
      },
      {
        number: 45,
        name: "effectcontrol2fine",
        description: "Effect control 2 (Fine)",
        position: "lsb"
      },
      {
        number: 46,
        name: "controller46",
        description: "Undefined",
        position: "lsb"
      },
      {
        number: 47,
        name: "controller47",
        description: "Undefined",
        position: "lsb"
      },
      {
        number: 48,
        name: "controller48",
        description: "General Purpose Controller 1 (Fine)",
        position: "lsb"
      },
      {
        number: 49,
        name: "controller49",
        description: "General Purpose Controller 2 (Fine)",
        position: "lsb"
      },
      {
        number: 50,
        name: "controller50",
        description: "General Purpose Controller 3 (Fine)",
        position: "lsb"
      },
      {
        number: 51,
        name: "controller51",
        description: "General Purpose Controller 4 (Fine)",
        position: "lsb"
      },
      {
        number: 52,
        name: "controller52",
        description: "Undefined",
        position: "lsb"
      },
      {
        number: 53,
        name: "controller53",
        description: "Undefined",
        position: "lsb"
      },
      {
        number: 54,
        name: "controller54",
        description: "Undefined",
        position: "lsb"
      },
      {
        number: 55,
        name: "controller55",
        description: "Undefined",
        position: "lsb"
      },
      {
        number: 56,
        name: "controller56",
        description: "Undefined",
        position: "lsb"
      },
      {
        number: 57,
        name: "controller57",
        description: "Undefined",
        position: "lsb"
      },
      {
        number: 58,
        name: "controller58",
        description: "Undefined",
        position: "lsb"
      },
      {
        number: 59,
        name: "controller59",
        description: "Undefined",
        position: "lsb"
      },
      {
        number: 60,
        name: "controller60",
        description: "Undefined",
        position: "lsb"
      },
      {
        number: 61,
        name: "controller61",
        description: "Undefined",
        position: "lsb"
      },
      {
        number: 62,
        name: "controller62",
        description: "Undefined",
        position: "lsb"
      },
      {
        number: 63,
        name: "controller63",
        description: "Undefined",
        position: "lsb"
      },
      {
        number: 64,
        name: "damperpedal",
        description: "Damper Pedal On/Off"
      },
      {
        number: 65,
        name: "portamento",
        description: "Portamento On/Off"
      },
      {
        number: 66,
        name: "sostenuto",
        description: "Sostenuto On/Off"
      },
      {
        number: 67,
        name: "softpedal",
        description: "Soft Pedal On/Off"
      },
      {
        number: 68,
        name: "legatopedal",
        description: "Legato Pedal On/Off"
      },
      {
        number: 69,
        name: "hold2",
        description: "Hold 2 On/Off"
      },
      {
        number: 70,
        name: "soundvariation",
        description: "Sound Variation",
        position: "lsb"
      },
      {
        number: 71,
        name: "resonance",
        description: "Resonance",
        position: "lsb"
      },
      {
        number: 72,
        name: "releasetime",
        description: "Release Time",
        position: "lsb"
      },
      {
        number: 73,
        name: "attacktime",
        description: "Attack Time",
        position: "lsb"
      },
      {
        number: 74,
        name: "brightness",
        description: "Brightness",
        position: "lsb"
      },
      {
        number: 75,
        name: "decaytime",
        description: "Decay Time",
        position: "lsb"
      },
      {
        number: 76,
        name: "vibratorate",
        description: "Vibrato Rate",
        position: "lsb"
      },
      {
        number: 77,
        name: "vibratodepth",
        description: "Vibrato Depth",
        position: "lsb"
      },
      {
        number: 78,
        name: "vibratodelay",
        description: "Vibrato Delay",
        position: "lsb"
      },
      {
        number: 79,
        name: "controller79",
        description: "Undefined",
        position: "lsb"
      },
      {
        number: 80,
        name: "generalpurposecontroller5",
        description: "General Purpose Controller 5",
        position: "lsb"
      },
      {
        number: 81,
        name: "generalpurposecontroller6",
        description: "General Purpose Controller 6",
        position: "lsb"
      },
      {
        number: 82,
        name: "generalpurposecontroller7",
        description: "General Purpose Controller 7",
        position: "lsb"
      },
      {
        number: 83,
        name: "generalpurposecontroller8",
        description: "General Purpose Controller 8",
        position: "lsb"
      },
      {
        number: 84,
        name: "portamentocontrol",
        description: "Portamento Control",
        position: "lsb"
      },
      {
        number: 85,
        name: "controller85",
        description: "Undefined"
      },
      {
        number: 86,
        name: "controller86",
        description: "Undefined"
      },
      {
        number: 87,
        name: "controller87",
        description: "Undefined"
      },
      {
        number: 88,
        name: "highresolutionvelocityprefix",
        description: "High Resolution Velocity Prefix",
        position: "lsb"
      },
      {
        number: 89,
        name: "controller89",
        description: "Undefined"
      },
      {
        number: 90,
        name: "controller90",
        description: "Undefined"
      },
      {
        number: 91,
        name: "effect1depth",
        description: "Effects 1 Depth (Reverb Send Level)"
      },
      {
        number: 92,
        name: "effect2depth",
        description: "Effects 2 Depth"
      },
      {
        number: 93,
        name: "effect3depth",
        description: "Effects 3 Depth (Chorus Send Level)"
      },
      {
        number: 94,
        name: "effect4depth",
        description: "Effects 4 Depth"
      },
      {
        number: 95,
        name: "effect5depth",
        description: "Effects 5 Depth"
      },
      {
        number: 96,
        name: "dataincrement",
        description: "Data Increment"
      },
      {
        number: 97,
        name: "datadecrement",
        description: "Data Decrement"
      },
      {
        number: 98,
        name: "nonregisteredparameterfine",
        description: "Non-Registered Parameter Number (Fine)",
        position: "lsb"
      },
      {
        number: 99,
        name: "nonregisteredparametercoarse",
        description: "Non-Registered Parameter Number (Coarse)",
        position: "msb"
      },
      {
        number: 100,
        name: "registeredparameterfine",
        description: "Registered Parameter Number (Fine)",
        position: "lsb"
      },
      {
        number: 101,
        name: "registeredparametercoarse",
        description: "Registered Parameter Number (Coarse)",
        position: "msb"
      },
      {
        number: 102,
        name: "controller102",
        description: "Undefined"
      },
      {
        number: 103,
        name: "controller103",
        description: "Undefined"
      },
      {
        number: 104,
        name: "controller104",
        description: "Undefined"
      },
      {
        number: 105,
        name: "controller105",
        description: "Undefined"
      },
      {
        number: 106,
        name: "controller106",
        description: "Undefined"
      },
      {
        number: 107,
        name: "controller107",
        description: "Undefined"
      },
      {
        number: 108,
        name: "controller108",
        description: "Undefined"
      },
      {
        number: 109,
        name: "controller109",
        description: "Undefined"
      },
      {
        number: 110,
        name: "controller110",
        description: "Undefined"
      },
      {
        number: 111,
        name: "controller111",
        description: "Undefined"
      },
      {
        number: 112,
        name: "controller112",
        description: "Undefined"
      },
      {
        number: 113,
        name: "controller113",
        description: "Undefined"
      },
      {
        number: 114,
        name: "controller114",
        description: "Undefined"
      },
      {
        number: 115,
        name: "controller115",
        description: "Undefined"
      },
      {
        number: 116,
        name: "controller116",
        description: "Undefined"
      },
      {
        number: 117,
        name: "controller117",
        description: "Undefined"
      },
      {
        number: 118,
        name: "controller118",
        description: "Undefined"
      },
      {
        number: 119,
        name: "controller119",
        description: "Undefined"
      },
      {
        number: 120,
        name: "allsoundoff",
        description: "All Sound Off"
      },
      {
        number: 121,
        name: "resetallcontrollers",
        description: "Reset All Controllers"
      },
      {
        number: 122,
        name: "localcontrol",
        description: "Local Control On/Off"
      },
      {
        number: 123,
        name: "allnotesoff",
        description: "All Notes Off"
      },
      {
        number: 124,
        name: "omnimodeoff",
        description: "Omni Mode Off"
      },
      {
        number: 125,
        name: "omnimodeon",
        description: "Omni Mode On"
      },
      {
        number: 126,
        name: "monomodeon",
        description: "Mono Mode On"
      },
      {
        number: 127,
        name: "polymodeon",
        description: "Poly Mode On"
      },
    ];

  }

  /**
   * Enumeration of all MIDI registered parameters and their associated pair of numerical values.
   * MIDI registered parameters extend the original list of control change messages. Currently,
   * there are only a limited number of them:
   *
   *
   * | Control Function             | [LSB, MSB]   |
   * |------------------------------|--------------|
   * | `pitchbendrange`             | [0x00, 0x00] |
   * | `channelfinetuning`          | [0x00, 0x01] |
   * | `channelcoarsetuning`        | [0x00, 0x02] |
   * | `tuningprogram`              | [0x00, 0x03] |
   * | `tuningbank`                 | [0x00, 0x04] |
   * | `modulationrange`            | [0x00, 0x05] |
   * | `azimuthangle`               | [0x3D, 0x00] |
   * | `elevationangle`             | [0x3D, 0x01] |
   * | `gain`                       | [0x3D, 0x02] |
   * | `distanceratio`              | [0x3D, 0x03] |
   * | `maximumdistance`            | [0x3D, 0x04] |
   * | `maximumdistancegain`        | [0x3D, 0x05] |
   * | `referencedistanceratio`     | [0x3D, 0x06] |
   * | `panspreadangle`             | [0x3D, 0x07] |
   * | `rollangle`                  | [0x3D, 0x08] |
   *
   * @enum {Object.<string, number[]>}
   * @readonly
   * @since 3.1
   * @static
   */
  static get REGISTERED_PARAMETERS() {

    return {
      pitchbendrange: [0x00, 0x00],
      channelfinetuning: [0x00, 0x01],
      channelcoarsetuning: [0x00, 0x02],
      tuningprogram: [0x00, 0x03],
      tuningbank: [0x00, 0x04],

      modulationrange: [0x00, 0x05],
      azimuthangle: [0x3D, 0x00],
      elevationangle: [0x3D, 0x01],
      gain: [0x3D, 0x02],
      distanceratio: [0x3D, 0x03],
      maximumdistance: [0x3D, 0x04],
      maximumdistancegain: [0x3D, 0x05],
      referencedistanceratio: [0x3D, 0x06],
      panspreadangle: [0x3D, 0x07],
      rollangle: [0x3D, 0x08]
    };

  }

  /**
   * @enum {Object.<string, number[]>}
   * @readonly
   * @deprecated since 3.1 (use Enumerations.REGISTERED_PARAMETERS instead)
   * @private
   * @static
   */
  static get MIDI_REGISTERED_PARAMETERS() {

    if (this.validation) {
      console.warn(
        "The MIDI_REGISTERED_PARAMETERS enum has been deprecated. Use the " +
        "Enumerations.REGISTERED_PARAMETERS enum instead."
      );
    }

    return Enumerations.MIDI_REGISTERED_PARAMETERS;

  }

  /**
   * Enumeration of all valid MIDI system messages and matching numerical values. This library also
   * uses two additional custom messages.
   *
   * **System Common Messages**
   *
   * | Function               | Hexadecimal | Decimal |
   * |------------------------|-------------|---------|
   * | `sysex`                | 0xF0        |  240    |
   * | `timecode`             | 0xF1        |  241    |
   * | `songposition`         | 0xF2        |  242    |
   * | `songselect`           | 0xF3        |  243    |
   * | `tunerequest`          | 0xF6        |  246    |
   * | `sysexend`             | 0xF7        |  247    |
   *
   * The `sysexend` message is never actually received. It simply ends a sysex stream.
   *
   * **System Real-Time Messages**
   *
   * | Function               | Hexadecimal | Decimal |
   * |------------------------|-------------|---------|
   * | `clock`                | 0xF8        |  248    |
   * | `start`                | 0xFA        |  250    |
   * | `continue`             | 0xFB        |  251    |
   * | `stop`                 | 0xFC        |  252    |
   * | `activesensing`        | 0xFE        |  254    |
   * | `reset`                | 0xFF        |  255    |
   *
   * Values 249 and 253 are relayed by the
   * [Web MIDI API](https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API) but they do not
   * serve any specific purpose. The
   * [MIDI 1.0 spec](https://www.midi.org/specifications/item/table-1-summary-of-midi-message)
   * simply states that they are undefined/reserved.
   *
   * **Custom Messages**
   *
   * These two messages are mostly for internal use. They are not MIDI messages and cannot be sent
   * or forwarded.
   *
   * | Function               | Hexadecimal | Decimal |
   * |------------------------|-------------|---------|
   * | `midimessage`          |             |  0      |
   * | `unknownsystemmessage` |             |  -1     |
   *
   * @enum {Object.<string, number>}
   * @readonly
   * @since 3.1
   * @static
   */
  static get SYSTEM_MESSAGES() {

    return {

      // System common messages
      sysex: 0xF0,            // 240
      timecode: 0xF1,         // 241
      songposition: 0xF2,     // 242
      songselect: 0xF3,       // 243
      tunerequest: 0xF6,      // 246
      tuningrequest: 0xF6,    // for backwards-compatibility (deprecated in version 3.0)
      sysexend: 0xF7,         // 247 (never actually received - simply ends a sysex)

      // System real-time messages
      clock: 0xF8,            // 248
      start: 0xFA,            // 250
      continue: 0xFB,         // 251
      stop: 0xFC,             // 252
      activesensing: 0xFE,    // 254
      reset: 0xFF,            // 255

      // Custom WebMidi.js messages
      midimessage: 0,
      unknownsystemmessage: -1

    };

  }

  /**
   * @enum {Object.<string, number>}
   * @readonly
   * @deprecated since 3.1 (use Enumerations.SYSTEM_MESSAGES instead)
   * @private
   * @static
   */
  static get MIDI_SYSTEM_MESSAGES() {

    if (this.validation) {
      console.warn(
        "The MIDI_SYSTEM_MESSAGES enum has been deprecated. Use the " +
        "Enumerations.SYSTEM_MESSAGES enum instead."
      );
    }

    return Enumerations.SYSTEM_MESSAGES;

  }

  /**
   * Array of channel-specific event names that can be listened for. This includes channel mode
   * events and RPN/NRPN events.
   *
   * @type {string[]}
   * @readonly
   */
  static get CHANNEL_EVENTS() {

    return [

      // MIDI channel message events
      "noteoff",
      "controlchange",
      "noteon",
      "keyaftertouch",
      "programchange",
      "channelaftertouch",
      "pitchbend",

      // MIDI channel mode events
      "allnotesoff",
      "allsoundoff",
      "localcontrol",
      "monomode",
      "omnimode",
      "resetallcontrollers",

      // RPN/NRPN events
      "nrpn",
      "nrpn-dataentrycoarse",
      "nrpn-dataentryfine",
      "nrpn-dataincrement",
      "nrpn-datadecrement",
      "rpn",
      "rpn-dataentrycoarse",
      "rpn-dataentryfine",
      "rpn-dataincrement",
      "rpn-datadecrement",

      // Legacy (remove in v4)
      "nrpn-databuttonincrement",
      "nrpn-databuttondecrement",
      "rpn-databuttonincrement",
      "rpn-databuttondecrement",

    ];
  }

}

/**
 * The `Note` class represents a single musical note such as `"D3"`, `"G#4"`, `"F-1"`, `"Gb7"`, etc.
 *
 * `Note` objects can be played back on a single channel by calling
 * [`OutputChannel.playNote()`]{@link OutputChannel#playNote} or, on multiple channels of the same
 * output, by calling [`Output.playNote()`]{@link Output#playNote}.
 *
 * The note has [`attack`](#attack) and [`release`](#release) velocities set at `0.5` by default.
 * These can be changed by passing in the appropriate option. It is also possible to set a
 * system-wide default for attack and release velocities by using the
 * [`WebMidi.defaults`](WebMidi#defaults) property.
 *
 * If you prefer to work with raw MIDI values (`0` to `127`), you can use [`rawAttack`](#rawAttack) and
 * [`rawRelease`](#rawRelease) to both get and set the values.
 *
 * The note may have a [`duration`](#duration). If it does, playback will be automatically stopped
 * when the duration has elapsed by sending a `"noteoff"` event. By default, the duration is set to
 * `Infinity`. In this case, it will never stop playing unless explicitly stopped by calling a
 * method such as [`OutputChannel.stopNote()`]{@link OutputChannel#stopNote},
 * [`Output.stopNote()`]{@link Output#stopNote} or similar.
 *
 * @license Apache-2.0
 * @since 3.0.0
 */
let Note$1 = class Note {

  /**
   * Creates a `Note` object.
   *
   * @param value {string|number} The value used to create the note. If an identifier string is used,
   * it must start with the note letter, optionally followed by an accidental and followed by the
   * octave number (`"C3"`, `"G#4"`, `"F-1"`, `"Db7"`, etc.). If a number is used, it must be an
   * integer between 0 and 127. In this case, middle C is considered to be C4 (note number 60).
   *
   * @param {object} [options={}]
   *
   * @param {number} [options.duration=Infinity] The number of milliseconds before the note should be
   * explicitly stopped.
   *
   * @param {number} [options.attack=0.5] The note's attack velocity as a float between 0 and 1. If
   * you wish to use an integer between 0 and 127, use the `rawAttack` option instead. If both
   * `attack` and `rawAttack` are specified, the latter has precedence.
   *
   * @param {number} [options.release=0.5] The note's release velocity as a float between 0 and 1. If
   * you wish to use an integer between 0 and 127, use the `rawRelease` option instead. If both
   * `release` and `rawRelease` are specified, the latter has precedence.
   *
   * @param {number} [options.rawAttack=64] The note's attack velocity as an integer between 0 and
   * 127. If you wish to use a float between 0 and 1, use the `release` option instead. If both
   * `attack` and `rawAttack` are specified, the latter has precedence.
   *
   * @param {number} [options.rawRelease=64] The note's release velocity as an integer between 0 and
   * 127. If you wish to use a float between 0 and 1, use the `release` option instead. If both
   * `release` and `rawRelease` are specified, the latter has precedence.
   *
   * @throws {Error} Invalid note identifier
   * @throws {RangeError} Invalid name value
   * @throws {RangeError} Invalid accidental value
   * @throws {RangeError} Invalid octave value
   * @throws {RangeError} Invalid duration value
   * @throws {RangeError} Invalid attack value
   * @throws {RangeError} Invalid release value
   */
  constructor(value, options = {}) {

    // Assign property defaults
    this.duration = wm.defaults.note.duration;
    this.attack = wm.defaults.note.attack;
    this.release = wm.defaults.note.release;

    // Assign property values from options (validation occurs in setter)
    if (options.duration != undefined) this.duration = options.duration;
    if (options.attack != undefined) this.attack = options.attack;
    if (options.rawAttack != undefined) this.attack = Utilities.from7bitToFloat(options.rawAttack);
    if (options.release != undefined) this.release = options.release;
    if (options.rawRelease != undefined) {
      this.release = Utilities.from7bitToFloat(options.rawRelease);
    }

    // Assign note depending on the way it was specified (name or number)
    if (Number.isInteger(value)) {
      this.identifier = Utilities.toNoteIdentifier(value);
    } else {
      this.identifier = value;
    }

  }

  /**
   * The name, optional accidental and octave of the note, as a string.
   * @type {string}
   * @since 3.0.0
   */
  get identifier() {
    return this._name + (this._accidental || "") + this._octave;
  }
  set identifier(value) {

    const fragments = Utilities.getNoteDetails(value);

    if (wm.validation) {
      if (!value) throw new Error("Invalid note identifier");
    }

    this._name = fragments.name;
    this._accidental = fragments.accidental;
    this._octave = fragments.octave;

  }

  /**
   * The name (letter) of the note. If you need the full name with octave and accidental, you can
   * use the [`identifier`]{@link Note#identifier} property instead.
   * @type {string}
   * @since 3.0.0
   */
  get name() {
    return this._name;
  }
  set name(value) {

    if (wm.validation) {
      value = value.toUpperCase();
      if (!["C", "D", "E", "F", "G", "A", "B"].includes(value)) {
        throw new Error("Invalid name value");
      }
    }

    this._name = value;

  }

  /**
   * The accidental (#, ##, b or bb) of the note.
   * @type {string}
   * @since 3.0.0
   */
  get accidental() {
    return this._accidental;
  }
  set accidental(value) {

    if (wm.validation) {
      value = value.toLowerCase();
      if (!["#", "##", "b", "bb"].includes(value)) throw new Error("Invalid accidental value");
    }

    this._accidental = value;

  }

  /**
   * The octave of the note.
   * @type {number}
   * @since 3.0.0
   */
  get octave() {
    return this._octave;
  }
  set octave(value) {

    if (wm.validation) {
      value = parseInt(value);
      if (isNaN(value)) throw new Error("Invalid octave value");
    }

    this._octave = value;

  }

  /**
   * The duration of the note as a positive decimal number representing the number of milliseconds
   * that the note should play for.
   *
   * @type {number}
   * @since 3.0.0
   */
  get duration() {
    return this._duration;
  }
  set duration(value) {

    if (wm.validation) {
      value = parseFloat(value);
      if (isNaN(value) || value === null || value < 0) {
        throw new RangeError("Invalid duration value.");
      }
    }

    this._duration = value;

  }

  /**
   * The attack velocity of the note as an integer between 0 and 1.
   * @type {number}
   * @since 3.0.0
   */
  get attack() {
    return this._attack;
  }
  set attack(value) {

    if (wm.validation) {
      value = parseFloat(value);
      if (isNaN(value) || !(value >= 0 && value <= 1)) {
        throw new RangeError("Invalid attack value.");
      }
    }

    this._attack = value;

  }

  /**
   * The release velocity of the note as an integer between 0 and 1.
   * @type {number}
   * @since 3.0.0
   */
  get release() {
    return this._release;
  }
  set release(value) {

    if (wm.validation) {
      value = parseFloat(value);
      if (isNaN(value) || !(value >= 0 && value <= 1)) {
        throw new RangeError("Invalid release value.");
      }
    }

    this._release = value;

  }

  /**
   * The attack velocity of the note as a positive integer between 0 and 127.
   * @type {number}
   * @since 3.0.0
   */
  get rawAttack() {
    return Utilities.fromFloatTo7Bit(this._attack);
  }
  set rawAttack(value) {
    this._attack = Utilities.from7bitToFloat(value);
  }

  /**
   * The release velocity of the note as a positive integer between 0 and 127.
   * @type {number}
   * @since 3.0.0
   */
  get rawRelease() {
    return Utilities.fromFloatTo7Bit(this._release);
  }
  set rawRelease(value) {
    this._release = Utilities.from7bitToFloat(value);
  }

  /**
   * The MIDI number of the note (`0` - `127`). This number is derived from the note identifier
   * using C4 as a reference for middle C.
   *
   * @type {number}
   * @readonly
   * @since 3.0.0
   */
  get number() {
    return Utilities.toNoteNumber(this.identifier);
  }

  /**
   * Returns a MIDI note number offset by octave and/or semitone. If the calculated value is less
   * than 0, 0 will be returned. If the calculated value is more than 127, 127 will be returned. If
   * an invalid value is supplied, 0 will be used.
   *
   * @param [octaveOffset] {number} An integer to offset the note number by octave.
   * @param [semitoneOffset] {number} An integer to offset the note number by semitone.
   * @returns {number} An integer between 0 and 127
   */
  getOffsetNumber(octaveOffset = 0, semitoneOffset = 0) {

    if (wm.validation) {
      octaveOffset = parseInt(octaveOffset) || 0;
      semitoneOffset = parseInt(semitoneOffset) || 0;
    }

    return Math.min(Math.max(this.number + (octaveOffset * 12) + semitoneOffset, 0), 127);

  }

};

/**
 * The `Utilities` class contains general-purpose utility methods. All methods are static and
 * should be called using the class name. For example: `Utilities.getNoteDetails("C4")`.
 *
 * @license Apache-2.0
 * @since 3.0.0
 */
class Utilities {

  /**
   * Returns a MIDI note number matching the identifier passed in the form of a string. The
   * identifier must include the octave number. The identifier also optionally include a sharp (#),
   * a double sharp (##), a flat (b) or a double flat (bb) symbol. For example, these are all valid
   * identifiers: C5, G4, D#-1, F0, Gb7, Eb-1, Abb4, B##6, etc.
   *
   * When converting note identifiers to numbers, C4 is considered to be middle C (MIDI note number
   * 60) as per the scientific pitch notation standard.
   *
   * The resulting note number can be offset by using the `octaveOffset` parameter.
   *
   * @param identifier {string} The identifier in the form of a letter, followed by an optional "#",
   * "##", "b" or "bb" followed by the octave number. For exemple: C5, G4, D#-1, F0, Gb7, Eb-1,
   * Abb4, B##6, etc.
   *
   * @param {number} [octaveOffset=0] A integer to offset the octave by.
   *
   * @returns {number} The MIDI note number (an integer between 0 and 127).
   *
   * @throws RangeError Invalid 'octaveOffset' value
   *
   * @throws TypeError Invalid note identifier
   *
   * @license Apache-2.0
   * @since 3.0.0
   * @static
   */
  static toNoteNumber(identifier, octaveOffset = 0) {

    // Validation
    octaveOffset = octaveOffset == undefined ? 0 : parseInt(octaveOffset);
    if (isNaN(octaveOffset)) throw new RangeError("Invalid 'octaveOffset' value");
    if (typeof identifier !== "string") identifier = "";

    const fragments = this.getNoteDetails(identifier);
    if (!fragments) throw new TypeError("Invalid note identifier");

    const notes = { C: 0, D: 2, E: 4, F: 5, G: 7, A: 9, B: 11 };
    let result = (fragments.octave + 1 + octaveOffset) * 12;
    result += notes[fragments.name];

    if (fragments.accidental) {
      if (fragments.accidental.startsWith("b")) {
        result -= fragments.accidental.length;
      } else {
        result += fragments.accidental.length;
      }
    }

    if (result < 0 || result > 127) throw new RangeError("Invalid octaveOffset value");

    return result;

  }

  /**
   * Given a proper note identifier (`C#4`, `Gb-1`, etc.) or a valid MIDI note number (0-127), this
   * method returns an object containing broken down details about the specified note (uppercase
   * letter, accidental and octave).
   *
   * When a number is specified, the translation to note is done using a value of 60 for middle C
   * (C4 = middle C).
   *
   * @param value {string|number} A note identifier A  atring ("C#4", "Gb-1", etc.) or a MIDI note
   * number (0-127).
   *
   * @returns {{accidental: string, identifier: string, name: string, octave: number }}
   *
   * @throws TypeError Invalid note identifier
   *
   * @since 3.0.0
   * @static
   */
  static getNoteDetails(value) {

    if (Number.isInteger(value)) value = this.toNoteIdentifier(value);

    const matches = value.match(/^([CDEFGAB])(#{0,2}|b{0,2})(-?\d+)$/i);
    if (!matches) throw new TypeError("Invalid note identifier");

    const name = matches[1].toUpperCase();
    const octave = parseInt(matches[3]);
    let accidental = matches[2].toLowerCase();
    accidental = accidental === "" ? undefined : accidental;

    const fragments = {
      accidental: accidental,
      identifier: name + (accidental || "") + octave,
      name: name,
      octave: octave
    };

    return fragments;

  }

  /**
   * Returns a sanitized array of valid MIDI channel numbers (1-16). The parameter should be a
   * single integer or an array of integers.
   *
   * For backwards-compatibility, passing `undefined` as a parameter to this method results in all
   * channels being returned (1-16). Otherwise, parameters that cannot successfully be parsed to
   * integers between 1 and 16 are silently ignored.
   *
   * @param [channel] {number|number[]} An integer or an array of integers to parse as channel
   * numbers.
   *
   * @returns {number[]} An array of 0 or more valid MIDI channel numbers.
   *
   * @since 3.0.0
   * @static
   */
  static sanitizeChannels(channel) {

    let channels;

    if (wm.validation) {

      if (channel === "all") { // backwards-compatibility
        channels = ["all"];
      } else if (channel === "none") { // backwards-compatibility
        return [];
      }

    }

    if (!Array.isArray(channel)) {
      channels = [channel];
    } else {
      channels = channel;
    }

    // In order to preserve backwards-compatibility, we let this assignment as it is.
    if (channels.indexOf("all") > -1) {
      channels = Enumerations.MIDI_CHANNEL_NUMBERS;
    }

    return channels
      .map(function(ch) {
        return parseInt(ch);
      })
      .filter(function(ch) {
        return (ch >= 1 && ch <= 16);
      });

  }

  /**
   * Returns a valid timestamp, relative to the navigation start of the document, derived from the
   * `time` parameter. If the parameter is a string starting with the "+" sign and followed by a
   * number, the resulting timestamp will be the sum of the current timestamp plus that number. If
   * the parameter is a positive number, it will be returned as is. Otherwise, false will be
   * returned.
   *
   * @param [time] {number|string} The time string (e.g. `"+2000"`) or number to parse
   * @return {number|false} A positive number or `false` (if the time cannot be converted)
   *
   * @since 3.0.0
   * @static
   */
  static toTimestamp(time) {

    let value = false;

    const parsed = parseFloat(time);
    if (isNaN(parsed)) return false;

    if (typeof time === "string" && time.substring(0, 1) === "+") {
      if (parsed >= 0) value = wm.time + parsed;
    } else {
      if (parsed >= 0) value = parsed;
    }

    return value;

  }

  /**
   * Returns a valid MIDI note number (0-127) given the specified input. The input usually is a
   * string containing a note identifier (`"C3"`, `"F#4"`, `"D-2"`, `"G8"`, etc.). If an integer
   * between 0 and 127 is passed, it will simply be returned as is (for convenience). Other strings
   * will be parsed for integer value, if possible.
   *
   * If the input is an identifier, the resulting note number is offset by the `octaveOffset`
   * parameter. For example, if you pass in "C4" (note number 60) and the `octaveOffset` value is
   * -2, the resulting MIDI note number will be 36.
   *
   * @param input {string|number} A string or number to extract the MIDI note number from.
   * @param octaveOffset {number} An integer to offset the octave by
   *
   * @returns {number|false} A valid MIDI note number (0-127) or `false` if the input could not
   * successfully be parsed to a note number.
   *
   * @since 3.0.0
   * @static
   */
  static guessNoteNumber(input, octaveOffset) {

    // Validate and, if necessary, assign default
    octaveOffset = parseInt(octaveOffset) || 0;

    let output = false;

    // Check input type
    if (Number.isInteger(input) && input >= 0 && input <= 127) {        // uint
      output = parseInt(input);
    } else if (parseInt(input) >= 0 && parseInt(input) <= 127) {        // float or uint as string
      output = parseInt(input);
    } else if (typeof input === "string" || input instanceof String) {  // string
      try {
        output = this.toNoteNumber(input.trim(), octaveOffset);
      } catch (e) {
        return false;
      }
    }

    return output;

  }

  /**
   * Returns an identifier string representing a note name (with optional accidental) followed by an
   * octave number. The octave can be offset by using the `octaveOffset` parameter.
   *
   * @param {number} number The MIDI note number to convert to a note identifier
   * @param {number} octaveOffset An offset to apply to the resulting octave
   *
   * @returns {string}
   *
   * @throws RangeError Invalid note number
   * @throws RangeError Invalid octaveOffset value
   *
   * @since 3.0.0
   * @static
   */
  static toNoteIdentifier(number, octaveOffset) {

    number = parseInt(number);
    if (isNaN(number) || number < 0 || number > 127) throw new RangeError("Invalid note number");

    octaveOffset = octaveOffset == undefined ? 0 : parseInt(octaveOffset);
    if (isNaN(octaveOffset)) throw new RangeError("Invalid octaveOffset value");

    const notes = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    const octave = Math.floor(number / 12 - 1) + octaveOffset;
    return notes[number % 12] + octave.toString();

  }

  /**
   * Converts the `input` parameter to a valid [`Note`]{@link Note} object. The input usually is an
   * unsigned integer (0-127) or a note identifier (`"C4"`, `"G#5"`, etc.). If the input is a
   * [`Note`]{@link Note} object, it will be returned as is.
   *
   * If the input is a note number or identifier, it is possible to specify options by providing the
   * `options` parameter.
   *
   * @param [input] {number|string|Note}
   *
   * @param {object} [options={}]
   *
   * @param {number} [options.duration=Infinity] The number of milliseconds before the note should
   * be explicitly stopped.
   *
   * @param {number} [options.attack=0.5] The note's attack velocity as a float between 0 and 1. If
   * you wish to use an integer between 0 and 127, use the `rawAttack` option instead. If both
   * `attack` and `rawAttack` are specified, the latter has precedence.
   *
   * @param {number} [options.release=0.5] The note's release velocity as a float between 0 and 1. If
   * you wish to use an integer between 0 and 127, use the `rawRelease` option instead. If both
   * `release` and `rawRelease` are specified, the latter has precedence.
   *
   * @param {number} [options.rawAttack=64] The note's attack velocity as an integer between 0 and
   * 127. If you wish to use a float between 0 and 1, use the `release` option instead. If both
   * `attack` and `rawAttack` are specified, the latter has precedence.
   *
   * @param {number} [options.rawRelease=64] The note's release velocity as an integer between 0 and
   * 127. If you wish to use a float between 0 and 1, use the `release` option instead. If both
   * `release` and `rawRelease` are specified, the latter has precedence.
   *
   * @param {number} [options.octaveOffset=0] An integer to offset the octave by. **This is only
   * used when the input value is a note identifier.**
   *
   * @returns {Note}
   *
   * @throws TypeError The input could not be parsed to a note
   *
   * @since version 3.0.0
   * @static
   */
  static buildNote(input, options= {}) {

    options.octaveOffset = parseInt(options.octaveOffset) || 0;

    // If it's already a Note, we're done
    if (input instanceof Note$1) return input;

    let number = this.guessNoteNumber(input, options.octaveOffset);

    if (number === false) { // We use a comparison b/c the note can be 0 (which equates to false)
      throw new TypeError(`The input could not be parsed as a note (${input})`);
    }

    // If we got here, we have a proper note number. Before creating the new note, we strip out
    // 'octaveOffset' because it has already been factored in when calling guessNoteNumber().
    options.octaveOffset = undefined;
    return new Note$1(number, options);

  }

  /**
   * Converts an input value, which can be an unsigned integer (0-127), a note identifier, a
   * [`Note`]{@link Note}  object or an array of the previous types, to an array of
   * [`Note`]{@link Note}  objects.
   *
   * [`Note`]{@link Note}  objects are returned as is. For note numbers and identifiers, a
   * [`Note`]{@link Note} object is created with the options specified. An error will be thrown when
   * encountering invalid input.
   *
   * Note: if both the `attack` and `rawAttack` options are specified, the later has priority. The
   * same goes for `release` and `rawRelease`.
   *
   * @param [notes] {number|string|Note|number[]|string[]|Note[]}
   *
   * @param {object} [options={}]
   *
   * @param {number} [options.duration=Infinity] The number of milliseconds before the note should
   * be explicitly stopped.
   *
   * @param {number} [options.attack=0.5] The note's attack velocity as a float between 0 and 1. If
   * you wish to use an integer between 0 and 127, use the `rawAttack` option instead. If both
   * `attack` and `rawAttack` are specified, the latter has precedence.
   *
   * @param {number} [options.release=0.5] The note's release velocity as a float between 0 and 1. If
   * you wish to use an integer between 0 and 127, use the `rawRelease` option instead. If both
   * `release` and `rawRelease` are specified, the latter has precedence.
   *
   * @param {number} [options.rawAttack=64] The note's attack velocity as an integer between 0 and
   * 127. If you wish to use a float between 0 and 1, use the `release` option instead. If both
   * `attack` and `rawAttack` are specified, the latter has precedence.
   *
   * @param {number} [options.rawRelease=64] The note's release velocity as an integer between 0 and
   * 127. If you wish to use a float between 0 and 1, use the `release` option instead. If both
   * `release` and `rawRelease` are specified, the latter has precedence.
   *
   * @param {number} [options.octaveOffset=0] An integer to offset the octave by. **This is only
   * used when the input value is a note identifier.**
   *
   * @returns {Note[]}
   *
   * @throws TypeError An element could not be parsed as a note.
   *
   * @since 3.0.0
   * @static
   */
  static buildNoteArray(notes, options = {}) {

    let result = [];
    if (!Array.isArray(notes)) notes = [notes];

    notes.forEach(note => {
      result.push(this.buildNote(note, options));
    });

    return result;

  }

  /**
   * Returns a number between 0 and 1 representing the ratio of the input value divided by 127 (7
   * bit). The returned value is restricted between 0 and 1 even if the input is greater than 127 or
   * smaller than 0.
   *
   * Passing `Infinity` will return `1` and passing `-Infinity` will return `0`. Otherwise, when the
   * input value cannot be converted to an integer, the method returns 0.
   *
   * @param value {number} A positive integer between 0 and 127 (inclusive)
   * @returns {number} A number between 0 and 1 (inclusive)
   * @static
   */
  static from7bitToFloat(value) {
    if (value === Infinity) value = 127;
    value = parseInt(value) || 0;
    return Math.min(Math.max(value / 127, 0), 1);
  }

  /**
   * Returns an integer between 0 and 127 which is the result of multiplying the input value by
   * 127. The input value should be a number between 0 and 1 (inclusively). The returned value is
   * restricted between 0 and 127 even if the input is greater than 1 or smaller than 0.
   *
   * Passing `Infinity` will return `127` and passing `-Infinity` will return `0`. Otherwise, when
   * the input value cannot be converted to a number, the method returns 0.
   *
   * @param value {number} A positive float between 0 and 1 (inclusive)
   * @returns {number} A number between 0 and 127 (inclusive)
   * @static
   */
  static fromFloatTo7Bit(value) {
    if (value === Infinity) value = 1;
    value = parseFloat(value) || 0;
    return Math.min(Math.max(Math.round(value * 127), 0), 127);
  }

  /**
   * Combines and converts MSB and LSB values (0-127) to a float between 0 and 1. The returned value
   * is within between 0 and 1 even if the result is greater than 1 or smaller than 0.
   *
   * @param msb {number} The most significant byte as a integer between 0 and 127.
   * @param [lsb=0] {number} The least significant byte as a integer between 0 and 127.
   * @returns {number} A float between 0 and 1.
   */
  static fromMsbLsbToFloat(msb, lsb = 0) {

    if (wm.validation) {
      msb = Math.min(Math.max(parseInt(msb) || 0, 0), 127);
      lsb = Math.min(Math.max(parseInt(lsb) || 0, 0), 127);
    }

    const value = ((msb << 7) + lsb) / 16383;
    return Math.min(Math.max(value, 0), 1);

  }

  /**
   * Extracts 7bit MSB and LSB values from the supplied float.
   *
   * @param value {number} A float between 0 and 1
   * @returns {{lsb: number, msb: number}}
   */
  static fromFloatToMsbLsb(value) {

    if (wm.validation) {
      value = Math.min(Math.max(parseFloat(value) || 0, 0), 1);
    }

    const multiplied = Math.round(value * 16383);

    return {
      msb: multiplied >> 7,
      lsb: multiplied & 0x7F
    };

  }

  /**
   * Returns the supplied MIDI note number offset by the requested octave and semitone values. If
   * the calculated value is less than 0, 0 will be returned. If the calculated value is more than
   * 127, 127 will be returned. If an invalid offset value is supplied, 0 will be used.
   *
   * @param number {number} The MIDI note to offset as an integer between 0 and 127.
   * @param octaveOffset {number} An integer to offset the note by (in octave)
   * @param octaveOffset {number} An integer to offset the note by (in semitones)
   * @returns {number} An integer between 0 and 127
   *
   * @throws {Error} Invalid note number
   * @static
   */
  static offsetNumber(number, octaveOffset = 0, semitoneOffset = 0) {

    if (wm.validation) {
      number = parseInt(number);
      if (isNaN(number)) throw new Error("Invalid note number");
      octaveOffset = parseInt(octaveOffset) || 0;
      semitoneOffset = parseInt(semitoneOffset) || 0;
    }

    return Math.min(Math.max(number + (octaveOffset * 12) + semitoneOffset, 0), 127);

  }

  /**
   * Returns the name of the first property of the supplied object whose value is equal to the one
   * supplied. If nothing is found, `undefined` is returned.
   *
   * @param object {object} The object to look for the property in.
   * @param value {*} Any value that can be expected to be found in the object's properties.
   * @returns {string|undefined} The name of the matching property or `undefined` if nothing is
   * found.
   * @static
   */
  static getPropertyByValue(object, value) {
    return Object.keys(object).find(key => object[key] === value);
  }

  /**
   * Returns the name of a control change message matching the specified number (0-127). Some valid
   * control change numbers do not have a specific name or purpose assigned in the MIDI
   * [spec](https://midi.org/specifications-old/item/table-3-control-change-messages-data-bytes-2).
   * In these cases, the method returns `controllerXXX` (where XXX is the number).
   *
   * @param {number} number An integer (0-127) representing the control change message
   * @returns {string|undefined} The matching control change name or `undefined` if no match was
   * found.
   *
   * @static
   */
  static getCcNameByNumber(number) {

    if (wm.validation) {
      number = parseInt(number);
      if (!(number >= 0 && number <= 127)) return undefined;
    }

    return Enumerations.CONTROL_CHANGE_MESSAGES[number].name;

  }

  /**
   * Returns the number of a control change message matching the specified name.
   *
   * @param {string} name A string representing the control change message
   * @returns {string|undefined} The matching control change number or `undefined` if no match was
   * found.
   *
   * @since 3.1
   * @static
   */
  static getCcNumberByName(name) {
    let message = Enumerations.CONTROL_CHANGE_MESSAGES.find(element => element.name === name);
    if (message) {
      return message.number;
    } else {
      // Legacy (remove in v4)
      return Enumerations.MIDI_CONTROL_CHANGE_MESSAGES[name];
    }
  }

  /**
   * Returns the channel mode name matching the specified number. If no match is found, the function
   * returns `false`.
   *
   * @param {number} number An integer representing the channel mode message (120-127)
   * @returns {string|false} The name of the matching channel mode or `false` if no match could be
   * found.
   *
   * @since 2.0.0
   */
  static getChannelModeByNumber(number) {

    if ( !(number >= 120 && number <= 127) ) return false;

    for (let cm in Enumerations.CHANNEL_MODE_MESSAGES) {

      if (
        Enumerations.CHANNEL_MODE_MESSAGES.hasOwnProperty(cm) &&
        number === Enumerations.CHANNEL_MODE_MESSAGES[cm]
      ) {
        return cm;
      }

    }

    return false;

  }

  /**
   * Indicates whether the execution environment is Node.js (`true`) or not (`false`)
   * @type {boolean}
   */
  static get isNode() {
    return typeof process !== "undefined" &&
      process.versions != null &&
      process.versions.node != null;
  }

  /**
   * Indicates whether the execution environment is a browser (`true`) or not (`false`)
   * @type {boolean}
   */
  static get isBrowser() {
    return typeof window !== "undefined" && typeof window.document !== "undefined";
  }

}

/**
 * The `OutputChannel` class represents a single output MIDI channel. `OutputChannel` objects are
 * provided by an [`Output`](Output) port which, itself, is made available by a device. The
 * `OutputChannel` object is derived from the host's MIDI subsystem and should not be instantiated
 * directly.
 *
 * All 16 `OutputChannel` objects can be found inside the parent output's
 * [`channels`]{@link Output#channels} property.
 *
 * @param {Output} output The [`Output`](Output) this channel belongs to.
 * @param {number} number The MIDI channel number (`1` - `16`).
 *
 * @extends EventEmitter
 * @license Apache-2.0
 * @since 3.0.0
 */
class OutputChannel extends EventEmitter {

  /**
   * Creates an `OutputChannel` object.
   *
   * @param {Output} output The [`Output`](Output) this channel belongs to.
   * @param {number} number The MIDI channel number (`1` - `16`).
   */
  constructor(output, number) {

    super();

    /**
     * @type {Output}
     * @private
     */
    this._output = output;

    /**
     * @type {number}
     * @private
     */
    this._number = number;

    /**
     * @type {number}
     * @private
     */
    this._octaveOffset = 0;

  }

  /**
   * Unlinks the MIDI subsystem, removes all listeners attached to the channel and nulls the channel
   * number. This method is mostly for internal use. It has not been prefixed with an underscore
   * since it is called by other objects such as the `Output` object.
   *
   * @private
   */
  destroy() {
    this._output = null;
    this._number = null;
    this._octaveOffset = 0;
    this.removeListener();
  }

  /**
   * Sends a MIDI message on the MIDI output port. If no time is specified, the message will be
   * sent immediately. The message should be an array of 8-bit unsigned integers (`0` - `225`),
   * a
   * [`Uint8Array`]{@link https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array}
   * object or a [`Message`](Message) object.
   *
   * It is usually not necessary to use this method directly as you can use one of the simpler
   * helper methods such as [`playNote()`](#playNote), [`stopNote()`](#stopNote),
   * [`sendControlChange()`](#sendControlChange), etc.
   *
   * Details on the format of MIDI messages are available in the summary of
   * [MIDI messages]{@link https://www.midi.org/specifications-old/item/table-1-summary-of-midi-message}
   * from the MIDI Manufacturers Association.
   *
   * @param message {number[]|Uint8Array|Message} A `Message` object, an array of 8-bit unsigned
   * integers or a `Uint8Array` object (not available in Node.js) containing the message bytes.
   *
   * @param {object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @throws {RangeError} The first byte (status) must be an integer between 128 and 255.
   *
   * @throws {RangeError} Data bytes must be integers between 0 and 255.
   *
   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.
   */
  send(message, options = {time: 0}) {
    this.output.send(message, options);
    return this;
  }

  /**
   * Sends a MIDI **key aftertouch** message at the scheduled time. This is a key-specific
   * aftertouch. For a channel-wide aftertouch message, use
   * [`sendChannelAftertouch()`]{@link #sendChannelAftertouch}.
   *
   * @param target {number|Note|string|number[]|Note[]|string[]} The note(s) for which you are sending
   * an aftertouch value. The notes can be specified by using a MIDI note number (`0` - `127`), a
   * [`Note`](Note) object, a note identifier (e.g. `C3`, `G#4`, `F-1`, `Db7`) or an array of the
   * previous types. When using a note identifier, octave range must be between `-1` and `9`. The
   * lowest note is `C-1` (MIDI note number `0`) and the highest note is `G9` (MIDI note number
   * `127`).
   *
   * When using a note identifier, the octave value will be offset by the local
   * [`octaveOffset`](#octaveOffset) and by
   * [`Output.octaveOffset`](Output#octaveOffset) and [`WebMidi.octaveOffset`](WebMidi#octaveOffset)
   * (if those values are not `0`). When using a key number, `octaveOffset` values are ignored.
   *
   * @param [pressure=0.5] {number} The pressure level (between `0` and `1`). An invalid pressure
   * value will silently trigger the default behaviour. If the `rawValue` option is set to `true`,
   * the pressure is defined by using an integer between `0` and `127`.
   *
   * @param {object} [options={}]
   *
   * @param {boolean} [options.rawValue=false] A boolean indicating whether the value should be
   * considered a float between `0` and `1.0` (default) or a raw integer between `0` and `127`.
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @return {OutputChannel} Returns the `OutputChannel` object so methods can be chained.
   *
   * @throws RangeError Invalid key aftertouch value.
   */
  sendKeyAftertouch(target, pressure, options = {}) {

    if (wm.validation) {

      // Legacy support
      if (options.useRawValue) options.rawValue = options.useRawValue;

      if (isNaN(parseFloat(pressure))) {
        throw new RangeError("Invalid key aftertouch value.");
      }
      if (options.rawValue) {
        if (!(pressure >= 0 && pressure <= 127 && Number.isInteger(pressure))) {
          throw new RangeError("Key aftertouch raw value must be an integer between 0 and 127.");
        }
      } else {
        if (!(pressure >= 0 && pressure <= 1)) {
          throw new RangeError("Key aftertouch value must be a float between 0 and 1.");
        }
      }

    }

    // Normalize pressure to integer
    if (!options.rawValue) pressure = Utilities.fromFloatTo7Bit(pressure);

    // Plot total offset
    const offset = wm.octaveOffset + this.output.octaveOffset + this.octaveOffset;

    // Make sure we are dealing with an array
    if (!Array.isArray(target)) target = [target];

    Utilities.buildNoteArray(target).forEach(n => {
      this.send(
        [
          (Enumerations.CHANNEL_MESSAGES.keyaftertouch << 4) + (this.number - 1),
          n.getOffsetNumber(offset),
          pressure
        ],
        {time: Utilities.toTimestamp(options.time)}
      );
    });

    return this;

  }

  /**
   * Sends a MIDI **control change** message to the channel at the scheduled time. The control
   * change message to send can be specified numerically (`0` to `127`) or by using one of the
   * following common names:
   *
   * | Number | Name                          |
   * |--------|-------------------------------|
   * | 0      |`bankselectcoarse`             |
   * | 1      |`modulationwheelcoarse`        |
   * | 2      |`breathcontrollercoarse`       |
   * | 4      |`footcontrollercoarse`         |
   * | 5      |`portamentotimecoarse`         |
   * | 6      |`dataentrycoarse`              |
   * | 7      |`volumecoarse`                 |
   * | 8      |`balancecoarse`                |
   * | 10     |`pancoarse`                    |
   * | 11     |`expressioncoarse`             |
   * | 12     |`effectcontrol1coarse`         |
   * | 13     |`effectcontrol2coarse`         |
   * | 18     |`generalpurposeslider3`        |
   * | 19     |`generalpurposeslider4`        |
   * | 32     |`bankselectfine`               |
   * | 33     |`modulationwheelfine`          |
   * | 34     |`breathcontrollerfine`         |
   * | 36     |`footcontrollerfine`           |
   * | 37     |`portamentotimefine`           |
   * | 38     |`dataentryfine`                |
   * | 39     |`volumefine`                   |
   * | 40     |`balancefine`                  |
   * | 42     |`panfine`                      |
   * | 43     |`expressionfine`               |
   * | 44     |`effectcontrol1fine`           |
   * | 45     |`effectcontrol2fine`           |
   * | 64     |`holdpedal`                    |
   * | 65     |`portamento`                   |
   * | 66     |`sustenutopedal`               |
   * | 67     |`softpedal`                    |
   * | 68     |`legatopedal`                  |
   * | 69     |`hold2pedal`                   |
   * | 70     |`soundvariation`               |
   * | 71     |`resonance`                    |
   * | 72     |`soundreleasetime`             |
   * | 73     |`soundattacktime`              |
   * | 74     |`brightness`                   |
   * | 75     |`soundcontrol6`                |
   * | 76     |`soundcontrol7`                |
   * | 77     |`soundcontrol8`                |
   * | 78     |`soundcontrol9`                |
   * | 79     |`soundcontrol10`               |
   * | 80     |`generalpurposebutton1`        |
   * | 81     |`generalpurposebutton2`        |
   * | 82     |`generalpurposebutton3`        |
   * | 83     |`generalpurposebutton4`        |
   * | 91     |`reverblevel`                  |
   * | 92     |`tremololevel`                 |
   * | 93     |`choruslevel`                  |
   * | 94     |`celestelevel`                 |
   * | 95     |`phaserlevel`                  |
   * | 96     |`dataincrement`                |
   * | 97     |`datadecrement`                |
   * | 98     |`nonregisteredparametercoarse` |
   * | 99     |`nonregisteredparameterfine`   |
   * | 100    |`registeredparametercoarse`    |
   * | 101    |`registeredparameterfine`      |
   * | 120    |`allsoundoff`                  |
   * | 121    |`resetallcontrollers`          |
   * | 122    |`localcontrol`                 |
   * | 123    |`allnotesoff`                  |
   * | 124    |`omnimodeoff`                  |
   * | 125    |`omnimodeon`                   |
   * | 126    |`monomodeon`                   |
   * | 127    |`polymodeon`                   |
   *
   * As you can see above, not all control change message have a matching name. This does not mean
   * you cannot use the others. It simply means you will need to use their number
   * (`0` to `127`) instead of their name. While you can still use them, numbers `120` to `127` are
   * usually reserved for *channel mode* messages. See
   * [`sendChannelMode()`]{@link OutputChannel#sendChannelMode} method for more info.
   *
   * To view a detailed list of all available **control change** messages, please consult "Table 3 -
   * Control Change Messages" from the [MIDI Messages](
   * https://www.midi.org/specifications/item/table-3-control-change-messages-data-bytes-2)
   * specification.
   *
   * **Note**: messages #0-31 (MSB) are paired with messages #32-63 (LSB). For example, message #1
   * (`modulationwheelcoarse`) can be accompanied by a second control change message for
   * `modulationwheelfine` to achieve a greater level of precision. if you want to specify both MSB
   * and LSB for messages between `0` and `31`, you can do so by passing a 2-value array as the
   * second parameter.
   *
   * @param {number|string} controller The MIDI controller name or number (`0` - `127`).
   *
   * @param {number|number[]} value The value to send (0-127). You can also use a two-position array
   * for controllers 0 to 31. In this scenario, the first value will be sent as usual and the second
   * value will be sent to the matching LSB controller (which is obtained by adding 32 to the first
   * controller)
   *
   * @param {object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @throws {RangeError} Controller numbers must be between 0 and 127.
   * @throws {RangeError} Invalid controller name.
   * @throws {TypeError} The value array must have a length of 2.
   *
   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.
   *
   * @license Apache-2.0
   * @since 3.0.0
   */
  sendControlChange(controller, value, options = {}) {

    if (typeof controller === "string") {
      controller = Utilities.getCcNumberByName(controller);
    }

    if (!Array.isArray(value)) value = [value];

    if (wm.validation) {

      if (controller === undefined) {
        throw new TypeError(
          "Control change must be identified with a valid name or an integer between 0 and 127."
        );
      }

      if (!Number.isInteger(controller) || !(controller >= 0 && controller <= 127)) {
        throw new TypeError("Control change number must be an integer between 0 and 127.");
      }

      value = value.map(item => {
        const output = Math.min(Math.max(parseInt(item), 0), 127);
        if (isNaN(output)) throw new TypeError("Values must be integers between 0 and 127");
        return output;
      });

      if (value.length === 2 && controller >= 32) {
        throw new TypeError("To use a value array, the controller must be between 0 and 31");
      }

    }

    value.forEach((item, index) => {

      this.send(
        [
          (Enumerations.CHANNEL_MESSAGES.controlchange << 4) + (this.number - 1),
          controller + (index * 32),
          value[index]
        ],
        {time: Utilities.toTimestamp(options.time)}
      );

    });

    return this;

  }

  /**
   * Selects a MIDI non-registered parameter so it is affected by upcoming data entry, data
   * increment and data decrement messages.
   *
   * @param parameter {number[]} A two-position array specifying the two control bytes that identify
   * the registered parameter. The NRPN MSB (99 or 0x63) is a position 0. The NRPN LSB (98 or 0x62)
   * is at position 1.
   *
   * @private
   *
   * @param {object} [options={}]
   *
   * @param {number|string} [options.time] If `time` is a string prefixed with `"+"` and followed by
   * a number, the message will be delayed by that many milliseconds. If the value is a number, the
   * operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.
   */
  _selectNonRegisteredParameter(parameter, options = {}) {

    // parameter[0] = Math.floor(parameter[0]);
    // if (!(parameter[0] >= 0 && parameter[0] <= 127)) {
    //   throw new RangeError("The control63 value must be between 0 and 127.");
    // }
    //
    // parameter[1] = Math.floor(parameter[1]);
    // if (!(parameter[1] >= 0 && parameter[1] <= 127)) {
    //   throw new RangeError("The control62 value must be between 0 and 127.");
    // }

    this.sendControlChange(0x63, parameter[0], options);
    this.sendControlChange(0x62, parameter[1], options);

    return this;

  }

  /**
   * Deselects the currently active MIDI registered parameter so it is no longer affected by data
   * entry, data increment and data decrement messages.
   *
   * Current best practice recommends doing that after each call to
   * [_setCurrentParameter()]{@link #_setCurrentParameter}.
   *
   * @private
   *
   * @param {object} [options={}]
   *
   * @param {number|string} [options.time] If `time` is a string prefixed with `"+"` and followed by
   * a number, the message will be delayed by that many milliseconds. If the value is a number, the
   * operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.
   */
  _deselectRegisteredParameter(options = {}) {
    this.sendControlChange(0x65, 0x7F, options);
    this.sendControlChange(0x64, 0x7F, options);
    return this;
  }

  /**
   * Deselects the currently active MIDI non-registered parameter so it is no longer affected by
   * data entry, data increment and data decrement messages.
   *
   * @private
   *
   * @param {object} [options={}]
   *
   * @param {number|string} [options.time] If `time` is a string prefixed with `"+"` and followed by
   * a number, the message will be delayed by that many milliseconds. If the value is a number, the
   * operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.
   */
  _deselectNonRegisteredParameter(options = {}) {
    this.sendControlChange(0x65, 0x7F, options);
    this.sendControlChange(0x64, 0x7F, options);
    return this;
  }

  /**
   * Selects a MIDI registered parameter so it is affected by upcoming data entry, data increment
   * and data decrement messages.
   *
   * @private
   *
   * @param parameter {number[]} A two-position array of integers specifying the two control bytes
   * (0x65, 0x64) that identify the registered parameter. The integers must be between 0 and 127.
   *
   * @param {object} [options={}]
   *
   * @param {number|string} [options.time] If `time` is a string prefixed with `"+"` and followed by
   * a number, the message will be delayed by that many milliseconds. If the value is a number, the
   * operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.
   */
  _selectRegisteredParameter(parameter, options = {}) {
    this.sendControlChange(0x65, parameter[0], options);
    this.sendControlChange(0x64, parameter[1], options);
    return this;
  }

  /**
   * Sets the value of the currently selected MIDI registered parameter.
   *
   * @private
   *
   * @param data {number|number[]}
   *
   * @param {object} [options={}]
   *
   * @param {number|string} [options.time] If `time` is a string prefixed with `"+"` and followed by
   * a number, the message will be delayed by that many milliseconds. If the value is a number, the
   * operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.
   */
  _setCurrentParameter(data, options = {}) {

    data = [].concat(data);

    // MSB
    // data[0] = parseInt(data[0]);
    // if (!isNaN(data[0]) && data[0] >= 0 && data[0] <= 127) {
    this.sendControlChange(0x06, data[0], options);
    // } else {
    //   throw new RangeError("The msb value must be between 0 and 127.");
    // }

    if (data.length < 2) return this;

    // LSB
    // data[1] = parseInt(data[1]);

    // if (!isNaN(data[1]) && data[1] >= 0 && data[1] <= 127) {
    this.sendControlChange(0x26, data[1], options);
    // } else {
    //   throw new RangeError("The lsb value must be between 0 and 127.");
    // }

    return this;

  }

  /**
   * Decrements the specified MIDI registered parameter by 1. Here is the full list of parameter
   * names that can be used with this function:
   *
   *  * Pitchbend Range (0x00, 0x00): `"pitchbendrange"`
   *  * Channel Fine Tuning (0x00, 0x01): `"channelfinetuning"`
   *  * Channel Coarse Tuning (0x00, 0x02): `"channelcoarsetuning"`
   *  * Tuning Program (0x00, 0x03): `"tuningprogram"`
   *  * Tuning Bank (0x00, 0x04): `"tuningbank"`
   *  * Modulation Range (0x00, 0x05): `"modulationrange"`
   *  * Azimuth Angle (0x3D, 0x00): `"azimuthangle"`
   *  * Elevation Angle (0x3D, 0x01): `"elevationangle"`
   *  * Gain (0x3D, 0x02): `"gain"`
   *  * Distance Ratio (0x3D, 0x03): `"distanceratio"`
   *  * Maximum Distance (0x3D, 0x04): `"maximumdistance"`
   *  * Maximum Distance Gain (0x3D, 0x05): `"maximumdistancegain"`
   *  * Reference Distance Ratio (0x3D, 0x06): `"referencedistanceratio"`
   *  * Pan Spread Angle (0x3D, 0x07): `"panspreadangle"`
   *  * Roll Angle (0x3D, 0x08): `"rollangle"`
   *
   * @param parameter {String|number[]} A string identifying the parameter's name (see above) or a
   * two-position array specifying the two control bytes (0x65, 0x64) that identify the registered
   * parameter.
   *
   * @param {object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @throws TypeError The specified registered parameter is invalid.
   *
   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.
   */
  sendRpnDecrement(parameter, options = {}) {

    if (!Array.isArray(parameter)) parameter = Enumerations.REGISTERED_PARAMETERS[parameter];

    if (wm.validation) {

      if (parameter === undefined) {
        throw new TypeError("The specified registered parameter is invalid.");
      }

      let valid = false;

      Object.getOwnPropertyNames(Enumerations.REGISTERED_PARAMETERS).forEach(p => {
        if (
          Enumerations.REGISTERED_PARAMETERS[p][0] === parameter[0] &&
          Enumerations.REGISTERED_PARAMETERS[p][1] === parameter[1]
        ) {
          valid = true;
        }
      });

      if (!valid) throw new TypeError("The specified registered parameter is invalid.");

    }

    this._selectRegisteredParameter(parameter, options);
    this.sendControlChange(0x61, 0, options);
    this._deselectRegisteredParameter(options);

    return this;

  }

  /**
   * Increments the specified MIDI registered parameter by 1. Here is the full list of parameter
   * names that can be used with this function:
   *
   *  * Pitchbend Range (0x00, 0x00): `"pitchbendrange"`
   *  * Channel Fine Tuning (0x00, 0x01): `"channelfinetuning"`
   *  * Channel Coarse Tuning (0x00, 0x02): `"channelcoarsetuning"`
   *  * Tuning Program (0x00, 0x03): `"tuningprogram"`
   *  * Tuning Bank (0x00, 0x04): `"tuningbank"`
   *  * Modulation Range (0x00, 0x05): `"modulationrange"`
   *  * Azimuth Angle (0x3D, 0x00): `"azimuthangle"`
   *  * Elevation Angle (0x3D, 0x01): `"elevationangle"`
   *  * Gain (0x3D, 0x02): `"gain"`
   *  * Distance Ratio (0x3D, 0x03): `"distanceratio"`
   *  * Maximum Distance (0x3D, 0x04): `"maximumdistance"`
   *  * Maximum Distance Gain (0x3D, 0x05): `"maximumdistancegain"`
   *  * Reference Distance Ratio (0x3D, 0x06): `"referencedistanceratio"`
   *  * Pan Spread Angle (0x3D, 0x07): `"panspreadangle"`
   *  * Roll Angle (0x3D, 0x08): `"rollangle"`
   *
   * @param parameter {String|number[]} A string identifying the parameter's name (see above) or a
   * two-position array specifying the two control bytes (0x65, 0x64) that identify the registered
   * parameter.
   *
   * @param {object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @throws TypeError The specified registered parameter is invalid.
   *
   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.
   */
  sendRpnIncrement(parameter, options = {}) {

    if (!Array.isArray(parameter)) parameter = Enumerations.REGISTERED_PARAMETERS[parameter];

    if (wm.validation) {

      if (parameter === undefined) {
        throw new TypeError("The specified registered parameter is invalid.");
      }

      let valid = false;

      Object.getOwnPropertyNames(Enumerations.REGISTERED_PARAMETERS).forEach(p => {
        if (
          Enumerations.REGISTERED_PARAMETERS[p][0] === parameter[0] &&
          Enumerations.REGISTERED_PARAMETERS[p][1] === parameter[1]
        ) {
          valid = true;
        }
      });

      if (!valid) throw new TypeError("The specified registered parameter is invalid.");

    }

    this._selectRegisteredParameter(parameter, options);
    this.sendControlChange(0x60, 0, options);
    this._deselectRegisteredParameter(options);

    return this;

  }

  /**
   * Plays a note or an array of notes on the channel. The first parameter is the note to play. It
   * can be a single value or an array of the following valid values:
   *
   *  - A [`Note`]{@link Note} object
   *  - A MIDI note number (integer between `0` and `127`)
   *  - A note name, followed by the octave (e.g. `"C3"`, `"G#4"`, `"F-1"`, `"Db7"`)
   *
   * The `playNote()` method sends a **note on** MIDI message for all specified notes. If a
   * `duration` is set in the `options` parameter or in the [`Note`]{@link Note} object's
   * [`duration`]{@link Note#duration} property, it will also schedule a **note off** message
   * to end the note after said duration. If no `duration` is set, the note will simply play until
   * a matching **note off** message is sent with [`stopNote()`]{@link OutputChannel#stopNote} or
   * [`sendNoteOff()`]{@link OutputChannel#sendNoteOff}.
   *
   *  The execution of the **note on** command can be delayed by using the `time` property of the
   * `options` parameter.
   *
   * When using [`Note`]{@link Note} objects, the durations and velocities defined in the
   * [`Note`]{@link Note} objects have precedence over the ones specified via the method's `options`
   * parameter.
   *
   * **Note**: per the MIDI standard, a **note on** message with an attack velocity of `0` is
   * functionally equivalent to a **note off** message.
   *
   * @param note {number|string|Note|number[]|string[]|Note[]} The note(s) to play. The notes can be
   * specified by using a MIDI note number (`0` - `127`), a note identifier (e.g. `C3`, `G#4`,
   * `F-1`, `Db7`), a [`Note`]{@link Note} object or an array of the previous types. When using a
   * note identifier, the octave range must be between `-1` and `9`. The lowest note is `C-1` (MIDI
   * note number `0`) and the highest note is `G9` (MIDI note number `127`).
   *
   * @param {object} [options={}]
   *
   * @param {number} [options.duration] A positive decimal number larger than `0` representing the
   * number of milliseconds to wait before sending a **note off** message. If invalid or left
   * undefined, only a **note on** message will be sent.
   *
   * @param {number} [options.attack=0.5] The velocity at which to play the note (between `0` and
   * `1`). If the `rawAttack` option is also defined, it will have priority. An invalid velocity
   * value will silently trigger the default of `0.5`.
   *
   * @param {number} [options.rawAttack=64] The attack velocity at which to play the note (between
   * `0` and `127`). This has priority over the `attack` property. An invalid velocity value will
   * silently trigger the default of 64.
   *
   * @param {number} [options.release=0.5] The velocity at which to release the note (between `0`
   * and `1`). If the `rawRelease` option is also defined, it will have priority. An invalid
   * velocity value will silently trigger the default of `0.5`. This is only used with the
   * **note off** event triggered when `options.duration` is set.
   *
   * @param {number} [options.rawRelease=64] The velocity at which to release the note (between `0`
   * and `127`). This has priority over the `release` property. An invalid velocity value will
   * silently trigger the default of 64. This is only used with the **note off** event triggered
   * when `options.duration` is set.
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.
   */
  playNote(note, options = {}) {

    // Send note on and, optionally, note off message (if duration is a positive number)
    this.sendNoteOn(note, options);

    const notes = Array.isArray(note) ? note : [note];

    for(let note of notes) {
      if (parseInt(note.duration) > 0) {
        const noteOffOptions = {
          time: (Utilities.toTimestamp(options.time) || wm.time) + parseInt(note.duration),
          release: note.release,
          rawRelease: note.rawRelease
        };
        this.sendNoteOff(note, noteOffOptions);
      } else if (parseInt(options.duration) > 0) {
        const noteOffOptions = {
          time: (Utilities.toTimestamp(options.time) || wm.time) + parseInt(options.duration),
          release: options.release,
          rawRelease: options.rawRelease
        };
        this.sendNoteOff(note, noteOffOptions);
      }
    }

    return this;

  }

  /**
   * Sends a **note off** message for the specified notes on the channel. The first parameter is the
   * note. It can be a single value or an array of the following valid values:
   *
   *  - A MIDI note number (integer between `0` and `127`)
   *  - A note name, followed by the octave (e.g. `"C3"`, `"G#4"`, `"F-1"`, `"Db7"`)
   *  - A [`Note`]{@link Note} object
   *
   * The execution of the **note off** command can be delayed by using the `time` property of the
   * `options` parameter.
   *
   * When using [`Note`]{@link Note} objects, the release velocity defined in the
   * [`Note`]{@link Note} objects has precedence over the one specified via the method's `options`
   * parameter.
   *
   * @param note {number|string|Note|number[]|string[]|Note[]} The note(s) to stop. The notes can be
   * specified by using a MIDI note number (0-127), a note identifier (e.g. C3, G#4, F-1, Db7), a
   * [`Note`]{@link Note} object or an array of the previous types. When using a note name, octave
   * range must be between -1 and 9. The lowest note is C-1 (MIDI note number 0) and the highest
   * note is G9 (MIDI note number 127).
   *
   * @param {object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @param {number} [options.release=0.5] The velocity at which to release the note
   * (between `0` and `1`).  If the `rawRelease` option is also defined, `rawRelease` will have
   * priority. An invalid velocity value will silently trigger the default of `0.5`.
   *
   * @param {number} [options.rawRelease=64] The velocity at which to release the note
   * (between `0` and `127`). If the `release` option is also defined, `rawRelease` will have
   * priority. An invalid velocity value will silently trigger the default of `64`.
   *
   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.
   */
  sendNoteOff(note, options = {}) {

    if (wm.validation) {

      if (
        options.rawRelease != undefined &&
        !(options.rawRelease >= 0 && options.rawRelease <= 127)
      ) {
        throw new RangeError("The 'rawRelease' option must be an integer between 0 and 127");
      }

      if (options.release != undefined && !(options.release >= 0 && options.release <= 1)) {
        throw new RangeError("The 'release' option must be an number between 0 and 1");
      }

      // Legacy compatibility warnings
      if (options.rawVelocity) {
        options.rawRelease = options.velocity;
        console.warn("The 'rawVelocity' option is deprecated. Use 'rawRelease' instead.");
      }
      if (options.velocity) {
        options.release = options.velocity;
        console.warn("The 'velocity' option is deprecated. Use 'attack' instead.");
      }

    }

    let nVelocity = 64;

    if (options.rawRelease != undefined) {
      nVelocity = options.rawRelease;
    } else {
      if (!isNaN(options.release)) nVelocity = Math.round(options.release * 127);
    }

    // Plot total octave offset
    const offset = wm.octaveOffset + this.output.octaveOffset + this.octaveOffset;

    Utilities.buildNoteArray(note, {rawRelease: parseInt(nVelocity)}).forEach(n => {
      this.send(
        [
          (Enumerations.CHANNEL_MESSAGES.noteoff << 4) + (this.number - 1),
          n.getOffsetNumber(offset),
          n.rawRelease,
        ],
        {time: Utilities.toTimestamp(options.time)}
      );
    });

    return this;

  }

  /**
   * Sends a **note off** message for the specified MIDI note number. The first parameter is the
   * note to stop. It can be a single value or an array of the following valid values:
   *
   *  - A MIDI note number (integer between `0` and `127`)
   *  - A note identifier (e.g. `"C3"`, `"G#4"`, `"F-1"`, `"Db7"`)
   *  - A [`Note`](Note) object
   *
   * The execution of the **note off** command can be delayed by using the `time` property of the
   * `options` parameter.
   *
   * @param note {number|Note|string|number[]|Note[]|string[]} The note(s) to stop. The notes can be
   * specified by using a MIDI note number (`0` - `127`), a note identifier (e.g. `C3`, `G#4`, `F-1`,
   * `Db7`) or an array of the previous types. When using a note identifier, octave range must be
   * between `-1` and `9`. The lowest note is `C-1` (MIDI note number `0`) and the highest note is
   * `G9` (MIDI note number `127`).
   *
   * @param {Object} [options={}]
   *
   * @param {number} [options.release=0.5] The velocity at which to release the note
   * (between `0` and `1`).  If the `rawRelease` option is also defined, `rawRelease` will have
   * priority. An invalid velocity value will silently trigger the default of `0.5`.
   *
   * @param {number} [options.rawRelease=64] The velocity at which to release the note
   * (between `0` and `127`). If the `release` option is also defined, `rawRelease` will have
   * priority. An invalid velocity value will silently trigger the default of `64`.
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {Output} Returns the `Output` object so methods can be chained.
   */
  stopNote(note, options = {}) {
    return this.sendNoteOff(note, options);
  }

  /**
   * Sends a **note on** message for the specified note(s) on the channel. The first parameter is
   * the note. It can be a single value or an array of the following valid values:
   *
   *  - A [`Note`]{@link Note} object
   *  - A MIDI note number (integer between `0` and `127`)
   *  - A note identifier (e.g. `"C3"`, `"G#4"`, `"F-1"`, `"Db7"`)
   *
   *  When passing a [`Note`]{@link Note}object or a note name, the `octaveOffset` will be applied.
   *  This is not the case when using a note number. In this case, we assume you know exactly which
   *  MIDI note number should be sent out.
   *
   * The execution of the **note on** command can be delayed by using the `time` property of the
   * `options` parameter.
   *
   * When using [`Note`]{@link Note} objects, the attack velocity defined in the
   * [`Note`]{@link Note} objects has precedence over the one specified via the method's `options`
   * parameter. Also, the `duration` is ignored. If you want to also send a **note off** message,
   * use the [`playNote()`]{@link #playNote} method instead.
   *
   * **Note**: As per the MIDI standard, a **note on** message with an attack velocity of `0` is
   * functionally equivalent to a **note off** message.
   *
   * @param note {number|string|Note|number[]|string[]|Note[]} The note(s) to play. The notes can be
   * specified by using a MIDI note number (0-127), a note identifier (e.g. C3, G#4, F-1, Db7), a
   * [`Note`]{@link Note} object or an array of the previous types.
   *
   * @param {object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @param {number} [options.attack=0.5] The velocity at which to play the note (between `0` and
   * `1`).  If the `rawAttack` option is also defined, `rawAttack` will have priority. An invalid
   * velocity value will silently trigger the default of `0.5`.
   *
   * @param {number} [options.rawAttack=64] The velocity at which to release the note (between `0`
   * and `127`). If the `attack` option is also defined, `rawAttack` will have priority. An invalid
   * velocity value will silently trigger the default of `64`.
   *
   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.
   */
  sendNoteOn(note, options = {}) {

    if (wm.validation) {

      if (options.rawAttack != undefined && !(options.rawAttack >= 0 && options.rawAttack <= 127)) {
        throw new RangeError("The 'rawAttack' option must be an integer between 0 and 127");
      }

      if (options.attack != undefined && !(options.attack >= 0 && options.attack <= 1)) {
        throw new RangeError("The 'attack' option must be an number between 0 and 1");
      }

      // Legacy compatibility warnings
      if (options.rawVelocity) {
        options.rawAttack = options.velocity;
        options.rawRelease = options.release;
        console.warn("The 'rawVelocity' option is deprecated. Use 'rawAttack' or 'rawRelease'.");
      }
      if (options.velocity) {
        options.attack = options.velocity;
        console.warn("The 'velocity' option is deprecated. Use 'attack' instead.");
      }

    }

    let nVelocity = 64;

    if (options.rawAttack != undefined) {
      nVelocity = options.rawAttack;
    } else {
      if (!isNaN(options.attack)) nVelocity = Math.round(options.attack * 127);
    }

    // Plot total octave offset
    const offset = wm.octaveOffset + this.output.octaveOffset + this.octaveOffset;

    Utilities.buildNoteArray(note, {rawAttack: nVelocity}).forEach(n => {
      this.send(
        [
          (Enumerations.CHANNEL_MESSAGES.noteon << 4) + (this.number - 1),
          n.getOffsetNumber(offset),
          n.rawAttack
        ],
        {time: Utilities.toTimestamp(options.time)}
      );
    });

    return this;

  }

  /**
   * Sends a MIDI **channel mode** message. The channel mode message to send can be specified
   * numerically or by using one of the following common names:
   *
   * |  Type                |Number| Shortcut Method                                               |
   * | ---------------------|------|-------------------------------------------------------------- |
   * | `allsoundoff`        | 120  | [`sendAllSoundOff()`]{@link #sendAllSoundOff}                 |
   * | `resetallcontrollers`| 121  | [`sendResetAllControllers()`]{@link #sendResetAllControllers} |
   * | `localcontrol`       | 122  | [`sendLocalControl()`]{@link #sendLocalControl}               |
   * | `allnotesoff`        | 123  | [`sendAllNotesOff()`]{@link #sendAllNotesOff}                 |
   * | `omnimodeoff`        | 124  | [`sendOmniMode(false)`]{@link #sendOmniMode}                  |
   * | `omnimodeon`         | 125  | [`sendOmniMode(true)`]{@link #sendOmniMode}                   |
   * | `monomodeon`         | 126  | [`sendPolyphonicMode("mono")`]{@link #sendPolyphonicMode}     |
   * | `polymodeon`         | 127  | [`sendPolyphonicMode("poly")`]{@link #sendPolyphonicMode}     |
   *
   * **Note**: as you can see above, to make it easier, all channel mode messages also have a matching
   * helper method.
   *
   * It should be noted that, per the MIDI specification, only `localcontrol` and `monomodeon` may
   * require a value that's not zero. For that reason, the `value` parameter is optional and
   * defaults to 0.
   *
   * @param {number|string} command The numerical identifier of the channel mode message (integer
   * between `120` and `127`) or its name as a string.
   *
   * @param {number} [value=0] The value to send (integer between `0` - `127`).
   *
   * @param {object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.
   */
  sendChannelMode(command, value = 0, options = {}) {

    // Normalize command to integer
    if (typeof command === "string") command = Enumerations.CHANNEL_MODE_MESSAGES[command];

    if (wm.validation) {

      if (command === undefined) {
        throw new TypeError("Invalid channel mode message name or number.");
      }

      if (isNaN(command) || !(command >= 120 && command <= 127)) {
        throw new TypeError("Invalid channel mode message number.");
      }

      if (isNaN(parseInt(value)) || value < 0 || value > 127) {
        throw new RangeError("Value must be an integer between 0 and 127.");
      }

    }

    this.send(
      [
        (Enumerations.CHANNEL_MESSAGES.controlchange << 4) + (this.number - 1),
        command,
        value
      ],
      {time: Utilities.toTimestamp(options.time)}
    );

    return this;

  }

  /**
   * Sets OMNI mode to `"on"` or `"off"`. MIDI's OMNI mode causes the instrument to respond to
   * messages from all channels.
   *
   * It should be noted that support for OMNI mode is not as common as it used to be.
   *
   * @param [state=true] {boolean} Whether to activate OMNI mode (`true`) or not (`false`).
   *
   * @param {object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @throws {TypeError} Invalid channel mode message name.
   * @throws {RangeError} Channel mode controller numbers must be between 120 and 127.
   * @throws {RangeError} Value must be an integer between 0 and 127.
   *
   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.
   */
  sendOmniMode(state, options = {}) {

    if (state === undefined || state) {
      this.sendChannelMode("omnimodeon", 0, options);
    } else {
      this.sendChannelMode("omnimodeoff", 0, options);
    }

    return this;

  }

  /**
   * Sends a MIDI **channel aftertouch** message. For key-specific aftertouch, you should instead
   * use [`sendKeyAftertouch()`]{@link #sendKeyAftertouch}.
   *
   * @param [pressure] {number} The pressure level (between `0` and `1`). If the `rawValue` option
   * is set to `true`, the pressure can be defined by using an integer between `0` and `127`.
   *
   * @param {object} [options={}]
   *
   * @param {boolean} [options.rawValue=false] A boolean indicating whether the value should be
   * considered a float between `0` and `1.0` (default) or a raw integer between `0` and `127`.
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.
   *
   * @throws RangeError Invalid channel aftertouch value.
   */
  sendChannelAftertouch(pressure, options = {}) {

    if (wm.validation) {

      if (isNaN(parseFloat(pressure))) {
        throw new RangeError("Invalid channel aftertouch value.");
      }

      if (options.rawValue) {
        if (!(pressure >= 0 && pressure <= 127 && Number.isInteger(pressure))) {
          throw new RangeError(
            "Channel aftertouch raw value must be an integer between 0 and 127.")
          ;
        }
      } else {
        if (!(pressure >= 0 && pressure <= 1)) {
          throw new RangeError("Channel aftertouch value must be a float between 0 and 1.");
        }
      }

    }

    // Normalize pressure to integer
    if (!options.rawValue) pressure = Utilities.fromFloatTo7Bit(pressure);

    this.send(
      [
        (Enumerations.CHANNEL_MESSAGES.channelaftertouch << 4) + (this.number - 1),
        Math.round(pressure)
      ],
      {time: Utilities.toTimestamp(options.time)}
    );

    return this;

  }

  /**
   * Sends a **master tuning** message. The value is decimal and must be larger than -65 semitones
   * and smaller than 64 semitones.
   *
   * Because of the way the MIDI specification works, the decimal portion of the value will be
   * encoded with a resolution of 14bit. The integer portion must be between -64 and 63
   * inclusively. This function actually generates two MIDI messages: a **Master Coarse Tuning** and
   * a **Master Fine Tuning** RPN messages.
   *
   * @param [value=0.0] {number} The desired decimal adjustment value in semitones (-65 < x < 64)
   *
   * @param {object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @throws {RangeError} The value must be a decimal number between larger than -65 and smaller
   * than 64.
   *
   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.
   */
  sendMasterTuning(value, options = {}) {

    // @todo allow passing value as msb/lsb pair (the same as pitch bend range)

    value = parseFloat(value) || 0.0;

    if (wm.validation) {

      if (!(value > -65 && value < 64)) {
        throw new RangeError(
          "The value must be a decimal number larger than -65 and smaller than 64."
        );
      }

    }

    let coarse = Math.floor(value) + 64;
    let fine = value - Math.floor(value);

    // Calculate MSB and LSB for fine adjustment (14bit resolution)
    fine = Math.round((fine + 1) / 2 * 16383);
    let msb = (fine >> 7) & 0x7F;
    let lsb = fine & 0x7F;

    this.sendRpnValue("channelcoarsetuning", coarse, options);
    this.sendRpnValue("channelfinetuning", [msb, lsb], options);

    return this;

  }

  /**
   * Sends a **modulation depth range** message to adjust the depth of the modulation wheel's range.
   * The range can be specified with the `semitones` parameter, the `cents` parameter or by
   * specifying both parameters at the same time.
   *
   * @param {number} semitones The desired adjustment value in semitones (integer between 0 and
   * 127).
   *
   * @param {number} [cents=0] The desired adjustment value in cents (integer between 0 and 127).
   *
   * @param {Object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.
   */
  sendModulationRange(semitones, cents, options = {}) {

    // @todo allow passing value as msb/lsb pair (the same as pitch bend range)
    // when passing a single argument, semitones and cents shoud be combined

    if (wm.validation) {

      if (!Number.isInteger(semitones) || !(semitones >= 0 && semitones <= 127)) {
        throw new RangeError("The semitones value must be an integer between 0 and 127.");
      }

      if (!(cents == undefined) && (!Number.isInteger(cents) || !(cents >= 0 && cents <= 127))) {
        throw new RangeError("If specified, the cents value must be an integer between 0 and 127.");
      }

    }

    // Default value for cents
    if (!(cents >= 0 && cents <= 127)) cents = 0;

    this.sendRpnValue("modulationrange", [semitones, cents], options);

    return this;

  }

  /**
   * Sets a non-registered parameter (NRPN) to the specified value. The NRPN is selected by passing
   * in a two-position array specifying the values of the two control bytes. The value is specified
   * by passing in a single integer (most cases) or an array of two integers.
   *
   * NRPNs are not standardized in any way. Each manufacturer is free to implement them any way
   * they see fit. For example, according to the Roland GS specification, you can control the
   * **vibrato rate** using NRPN (1, 8). Therefore, to set the **vibrato rate** value to **123** you
   * would use:
   *
   * ```js
   * WebMidi.outputs[0].channels[0].sendNrpnValue([1, 8], 123);
   * ```
   *
   * In some rarer cases, you need to send two values with your NRPN messages. In such cases, you
   * would use a 2-position array. For example, for its **ClockBPM** parameter (2, 63), Novation
   * uses a 14-bit value that combines an MSB and an LSB (7-bit values). So, for example, if the
   * value to send was 10, you could use:
   *
   * ```js
   * WebMidi.outputs[0].channels[0].sendNrpnValue([2, 63], [0, 10]);
   * ```
   *
   * For further implementation details, refer to the manufacturer's documentation.
   *
   * @param nrpn {number[]} A two-position array specifying the two control bytes (0x63,
   * 0x62) that identify the non-registered parameter.
   *
   * @param [data=[]] {number|number[]} An integer or an array of integers with a length of 1 or 2
   * specifying the desired data.
   *
   * @param {Object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @throws {RangeError} The control value must be between 0 and 127.
   * @throws {RangeError} The msb value must be between 0 and 127
   *
   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.
   */
  sendNrpnValue(nrpn, data, options = {}) {

    data = [].concat(data);

    if (wm.validation) {

      if (!Array.isArray(nrpn) || !Number.isInteger(nrpn[0]) || !Number.isInteger(nrpn[1])) {
        throw new TypeError("The specified NRPN is invalid.");
      }

      if (!(nrpn[0] >= 0 && nrpn[0] <= 127)) {
        throw new RangeError("The first byte of the NRPN must be between 0 and 127.");
      }

      if (!(nrpn[1] >= 0 && nrpn[1] <= 127)) {
        throw new RangeError("The second byte of the NRPN must be between 0 and 127.");
      }

      data.forEach(value => {
        if (!(value >= 0 && value <= 127)) {
          throw new RangeError("The data bytes of the NRPN must be between 0 and 127.");
        }
      });

    }

    this._selectNonRegisteredParameter(nrpn, options);
    this._setCurrentParameter(data, options);
    this._deselectNonRegisteredParameter(options);

    return this;

  }

  /**
   * Sends a MIDI **pitch bend** message at the scheduled time. The resulting bend is relative to
   * the pitch bend range that has been defined. The range can be set with
   * [`sendPitchBendRange()`]{@link #sendPitchBendRange}. So, for example, if the pitch
   * bend range has been set to 12 semitones, using a bend value of -1 will bend the note 1 octave
   * below its nominal value.
   *
   * @param {number|number[]} [value] The intensity of the bend (between -1.0 and 1.0). A value of
   * zero means no bend. If the `rawValue` option is set to `true`, the intensity of the bend can be
   * defined by either using a single integer between 0 and 127 (MSB) or an array of two integers
   * between 0 and 127 representing, respectively, the MSB (most significant byte) and the LSB
   * (least significant byte). The MSB is expressed in semitones with `64` meaning no bend. A value
   * lower than `64` bends downwards while a value higher than `64` bends upwards. The LSB is
   * expressed in cents (1/100 of a semitone). An LSB of `64` also means no bend.
   *
   * @param {Object} [options={}]
   *
   * @param {boolean} [options.rawValue=false] A boolean indicating whether the value should be
   * considered as a float between -1.0 and 1.0 (default) or as raw integer between 0 and 127 (or
   * an array of 2 integers if using both MSB and LSB).
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.
   */
  sendPitchBend(value, options = {}) {

    // @todo standardize the way msb/lsb are passed in

    if (wm.validation) {

      if (options.rawValue && Array.isArray(value)) {

        if (!(value[0] >= 0 && value[0] <= 127)) {
          throw new RangeError("The pitch bend MSB must be an integer between 0 and 127.");
        }
        if (!(value[1] >= 0 && value[1] <= 127)) {
          throw new RangeError("The pitch bend LSB must be an integer between 0 and 127.");
        }

      } else if (options.rawValue && !Array.isArray(value)) {

        if (!(value >= 0 && value <= 127)) {
          throw new RangeError("The pitch bend MSB must be an integer between 0 and 127.");
        }

      } else {

        if (isNaN(value) || value === null) {
          throw new RangeError("Invalid pitch bend value.");
        }

        if (!(value >= -1 && value <= 1)) {
          throw new RangeError("The pitch bend value must be a float between -1 and 1.");
        }

      }

    }

    let msb = 0;
    let lsb = 0;

    // Calculate MSB and LSB for both scenarios
    if (options.rawValue && Array.isArray(value)) {
      msb = value[0];
      lsb = value[1];
    } else if (options.rawValue && !Array.isArray(value)) {
      msb = value;
    } else {
      const result = Utilities.fromFloatToMsbLsb((value + 1) / 2); // b/c value is -1 to 1
      msb = result.msb;
      lsb = result.lsb;
    }

    this.send(
      [
        (Enumerations.CHANNEL_MESSAGES.pitchbend << 4) + (this.number - 1),
        lsb,
        msb
      ],
      {time: Utilities.toTimestamp(options.time)}
    );

    return this;

  }

  /**
   * Sends a **pitch bend range** message at the scheduled time to adjust the range used by the
   * pitch bend lever. The range is specified by using the `semitones` and `cents` parameters. For
   * example, setting the `semitones` parameter to `12` means that the pitch bend range will be 12
   * semitones above and below the nominal pitch.
   *
   * @param semitones {number} The desired adjustment value in semitones (between 0 and 127). While
   * nothing imposes that in the specification, it is very common for manufacturers to limit the
   * range to 2 octaves (-12 semitones to 12 semitones).
   *
   * @param [cents=0] {number} The desired adjustment value in cents (integer between 0-127).
   *
   * @param {Object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @throws {RangeError} The semitones value must be an integer between 0 and 127.
   * @throws {RangeError} The cents value must be an integer between 0 and 127.
   *
   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.
   */
  sendPitchBendRange(semitones, cents, options = {}) {

    // @todo use single value as parameter or pair of msb/lsb

    if (wm.validation) {

      if (!Number.isInteger(semitones) || !(semitones >= 0 && semitones <= 127)) {
        throw new RangeError("The semitones value must be an integer between 0 and 127.");
      }

      if (!Number.isInteger(cents) || !(cents >= 0 && cents <= 127)) {
        throw new RangeError("The cents value must be an integer between 0 and 127.");
      }

    }

    this.sendRpnValue("pitchbendrange", [semitones, cents], options);
    return this;

  }

  /**
   * Sends a MIDI **program change** message at the scheduled time.
   *
   * @param [program=1] {number} The MIDI patch (program) number (integer between `0` and `127`).
   *
   * @param {Object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @throws {TypeError} Failed to execute 'send' on 'MIDIOutput': The value at index 1 is greater
   * than 0xFF.
   *
   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.
   *
   */
  sendProgramChange(program, options = {}) {

    program = parseInt(program) || 0;

    if (wm.validation) {

      if (!(program >= 0 && program <= 127)) {
        throw new RangeError("The program number must be between 0 and 127.");
      }

    }

    this.send(
      [
        (Enumerations.CHANNEL_MESSAGES.programchange << 4) + (this.number - 1),
        program
      ],
      {time: Utilities.toTimestamp(options.time)}
    );

    return this;

  }

  /**
   * Sets the specified MIDI registered parameter to the desired value. The value is defined with
   * up to two bytes of data (msb, lsb) that each can go from 0 to 127.
   *
   * MIDI
   * [registered parameters](https://www.midi.org/specifications-old/item/table-3-control-change-messages-data-bytes-2)
   * extend the original list of control change messages. The MIDI 1.0 specification lists only a
   * limited number of them:
   *
   * | Numbers      | Function                 |
   * |--------------|--------------------------|
   * | (0x00, 0x00) | `pitchbendrange`         |
   * | (0x00, 0x01) | `channelfinetuning`      |
   * | (0x00, 0x02) | `channelcoarsetuning`    |
   * | (0x00, 0x03) | `tuningprogram`          |
   * | (0x00, 0x04) | `tuningbank`             |
   * | (0x00, 0x05) | `modulationrange`        |
   * | (0x3D, 0x00) | `azimuthangle`           |
   * | (0x3D, 0x01) | `elevationangle`         |
   * | (0x3D, 0x02) | `gain`                   |
   * | (0x3D, 0x03) | `distanceratio`          |
   * | (0x3D, 0x04) | `maximumdistance`        |
   * | (0x3D, 0x05) | `maximumdistancegain`    |
   * | (0x3D, 0x06) | `referencedistanceratio` |
   * | (0x3D, 0x07) | `panspreadangle`         |
   * | (0x3D, 0x08) | `rollangle`              |
   *
   * Note that the **Tuning Program** and **Tuning Bank** parameters are part of the *MIDI Tuning
   * Standard*, which is not widely implemented.
   *
   * @param rpn {string|number[]} A string identifying the parameter's name (see above) or a
   * two-position array specifying the two control bytes (e.g. `[0x65, 0x64]`) that identify the
   * registered parameter.
   *
   * @param [data=[]] {number|number[]} An single integer or an array of integers with a maximum
   * length of 2 specifying the desired data.
   *
   * @param {Object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.
   */
  sendRpnValue(rpn, data, options = {}) {

    if (!Array.isArray(rpn)) rpn = Enumerations.REGISTERED_PARAMETERS[rpn];

    if (wm.validation) {

      if (!Number.isInteger(rpn[0]) || !Number.isInteger(rpn[1])) {
        throw new TypeError("The specified NRPN is invalid.");
      }

      if (!(rpn[0] >= 0 && rpn[0] <= 127)) {
        throw new RangeError("The first byte of the RPN must be between 0 and 127.");
      }

      if (!(rpn[1] >= 0 && rpn[1] <= 127)) {
        throw new RangeError("The second byte of the RPN must be between 0 and 127.");
      }

      [].concat(data).forEach(value => {
        if (!(value >= 0 && value <= 127)) {
          throw new RangeError("The data bytes of the RPN must be between 0 and 127.");
        }
      });

    }

    this._selectRegisteredParameter(rpn, options);
    this._setCurrentParameter(data, options);
    this._deselectRegisteredParameter(options);

    return this;

  }

  /**
   * Sets the MIDI tuning bank to use. Note that the **Tuning Bank** parameter is part of the
   * *MIDI Tuning Standard*, which is not widely implemented.
   *
   * @param value {number} The desired tuning bank (integer between `0` and `127`).
   *
   * @param {Object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @throws {RangeError} The bank value must be between 0 and 127.
   *
   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.
   */
  sendTuningBank(value, options = {}) {

    if (wm.validation) {

      if (!Number.isInteger(value) || !(value >= 0 && value <= 127)) {
        throw new RangeError("The tuning bank number must be between 0 and 127.");
      }

    }

    this.sendRpnValue("tuningbank", value, options);
    return this;

  }

  /**
   * Sets the MIDI tuning program to use. Note that the **Tuning Program** parameter is part of the
   * *MIDI Tuning Standard*, which is not widely implemented.
   *
   * @param value {number} The desired tuning program (integer between `0` and `127`).
   *
   * @param {Object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @throws {RangeError} The program value must be between 0 and 127.
   *
   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.
   */
  sendTuningProgram(value, options = {}) {

    if (wm.validation) {

      if (!Number.isInteger(value) || !(value >= 0 && value <= 127)) {
        throw new RangeError("The tuning program number must be between 0 and 127.");
      }

    }

    this.sendRpnValue("tuningprogram", value, options);
    return this;

  }

  /**
   * Turns local control on or off. Local control is usually enabled by default. If you disable it,
   * the instrument will no longer trigger its own sounds. It will only send the MIDI messages to
   * its out port.
   *
   * @param [state=false] {boolean} Whether to activate local control (`true`) or disable it
   * (`false`).
   *
   * @param {Object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.
   */
  sendLocalControl(state, options = {}) {
    if (state) {
      return this.sendChannelMode("localcontrol", 127, options);
    } else {
      return this.sendChannelMode("localcontrol", 0, options);
    }
  }

  /**
   * Sends an **all notes off** channel mode message. This will make all currently playing notes
   * fade out just as if their key had been released. This is different from the
   * [`sendAllSoundOff()`]{@link #sendAllSoundOff} method which mutes all sounds immediately.
   *
   * @param {Object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.
   */
  sendAllNotesOff(options = {}) {
    return this.sendChannelMode("allnotesoff", 0, options);
  }

  /**
   * Sends an **all sound off** channel mode message. This will silence all sounds playing on that
   * channel but will not prevent new sounds from being triggered.
   *
   * @param {Object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.
   */
  sendAllSoundOff(options = {}) {
    return this.sendChannelMode("allsoundoff", 0, options);
  }

  /**
   * Sends a **reset all controllers** channel mode message. This resets all controllers, such as
   * the pitch bend, to their default value.
   *
   * @param {Object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.
   */
  sendResetAllControllers(options = {}) {
    return this.sendChannelMode("resetallcontrollers", 0, options);
  }

  /**
   * Sets the polyphonic mode. In `"poly"` mode (usually the default), multiple notes can be played
   * and heard at the same time. In `"mono"` mode, only one note will be heard at once even if
   * multiple notes are being played.
   *
   * @param {string} [mode=poly] The mode to use: `"mono"` or `"poly"`.
   *
   * @param {Object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.
   */
  sendPolyphonicMode(mode, options = {}) {
    if (mode === "mono") {
      return this.sendChannelMode("monomodeon", 0, options);
    } else {
      return this.sendChannelMode("polymodeon", 0, options);
    }
  }

  /**
   * An integer to offset the reported octave of outgoing note-specific messages (`noteon`,
   * `noteoff` and `keyaftertouch`). By default, middle C (MIDI note number 60) is placed on the 4th
   * octave (C4).
   *
   * Note that this value is combined with the global offset value defined in
   * [`WebMidi.octaveOffset`](WebMidi#octaveOffset) and with the parent value defined in
   * [`Output.octaveOffset`]{@link Output#octaveOffset}.
   *
   * @type {number}
   *
   * @since 3.0
   */
  get octaveOffset() {
    return this._octaveOffset;
  }
  set octaveOffset(value) {

    if (this.validation) {
      value = parseInt(value);
      if (isNaN(value)) throw new TypeError("The 'octaveOffset' property must be an integer.");
    }

    this._octaveOffset = value;

  }

  /**
   * The parent [`Output`]{@link Output} this channel belongs to.
   * @type {Output}
   * @since 3.0
   */
  get output() {
    return this._output;
  }

  /**
   * This channel's MIDI number (`1` - `16`).
   * @type {number}
   * @since 3.0
   */
  get number() {
    return this._number;
  }

}

/**
 * The `Output` class represents a single MIDI output port (not to be confused with a MIDI channel).
 * A port is made available by a MIDI device. A MIDI device can advertise several input and output
 * ports. Each port has 16 MIDI channels which can be accessed via the [`channels`](#channels)
 * property.
 *
 * The `Output` object is automatically instantiated by the library according to the host's MIDI
 * subsystem and should not be directly instantiated.
 *
 * You can access all available `Output` objects by referring to the
 * [`WebMidi.outputs`](WebMidi#outputs) array or by using methods such as
 * [`WebMidi.getOutputByName()`](WebMidi#getOutputByName) or
 * [`WebMidi.getOutputById()`](WebMidi#getOutputById).
 *
 * @fires Output#opened
 * @fires Output#disconnected
 * @fires Output#closed
 *
 * @extends EventEmitter
 * @license Apache-2.0
 */
class Output extends EventEmitter {

  /**
   * Creates an `Output` object.
   *
   * @param {MIDIOutput} midiOutput [`MIDIOutput`](https://developer.mozilla.org/en-US/docs/Web/API/MIDIOutput)
   * object as provided by the MIDI subsystem.
   */
  constructor(midiOutput) {

    super();

    /**
     * A reference to the `MIDIOutput` object
     * @type {MIDIOutput}
     * @private
     */
    this._midiOutput = midiOutput;

    /**
     * @type {number}
     * @private
     */
    this._octaveOffset = 0;

    /**
     * Array containing the 16 [`OutputChannel`]{@link OutputChannel} objects available provided by
     * this `Output`. The channels are numbered 1 through 16.
     *
     * @type {OutputChannel[]}
     */
    this.channels = [];
    for (let i = 1; i <= 16; i++) this.channels[i] = new OutputChannel(this, i);

    this._midiOutput.onstatechange = this._onStateChange.bind(this);

  }

  /**
   * Destroys the `Output`. All listeners are removed, all channels are destroyed and the MIDI
   * subsystem is unlinked.
   * @returns {Promise<void>}
   */
  async destroy() {
    this.removeListener();
    this.channels.forEach(ch => ch.destroy());
    this.channels = [];
    if (this._midiOutput) this._midiOutput.onstatechange = null;
    await this.close();
    this._midiOutput = null;
  }

  /**
   * @private
   */
  _onStateChange(e) {

    let event = {
      timestamp: wm.time
    };

    if (e.port.connection === "open") {

      /**
       * Event emitted when the {@link Output} has been opened by calling the
       * [open()]{@link Output#open} method.
       *
       * @event Output#opened
       * @type {object}
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       * @property {string} type `"opened"`
       * @property {Output} target The object to which the listener was originally added (`Output`).
       * @property {Output} port The port that was opened
       */
      event.type = "opened";
      event.target = this;
      event.port = event.target; // for consistency
      this.emit("opened", event);

    } else if (e.port.connection === "closed" && e.port.state === "connected") {

      /**
       * Event emitted when the {@link Output} has been closed by calling the
       * [close()]{@link Output#close} method.
       *
       * @event Output#closed
       * @type {object}
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       * @property {string} type `"closed"`
       * @property {Output} target The object to which the listener was originally added (`Output`).
       * @property {Output} port The port that was closed
       */
      event.type = "closed";
      event.target = this;
      event.port = event.target; // for consistency
      this.emit("closed", event);

    } else if (e.port.connection === "closed" && e.port.state === "disconnected") {

      /**
       * Event emitted when the {@link Output} becomes unavailable. This event is typically fired
       * when the MIDI device is unplugged.
       *
       * @event Output#disconnected
       * @type {object}
       * @property {number} timestamp The moment (DOMHighResTimeStamp0 when the event occurred (in
       * milliseconds since the navigation start of the document).
       * @property {string} type `"disconnected"`
       * @property {Output} target The object to which the listener was originally added (`Output`).
       * @property {object} port Object with properties describing the {@link Output} that was
       * disconnected. This is not the actual `Output` as it is no longer available.
       */
      event.type = "disconnected";
      event.port = {
        connection: e.port.connection,
        id: e.port.id,
        manufacturer: e.port.manufacturer,
        name: e.port.name,
        state: e.port.state,
        type: e.port.type
      };
      this.emit("disconnected", event);

    } else if (e.port.connection === "pending" && e.port.state === "disconnected") ; else {
      console.warn("This statechange event was not caught:", e.port.connection, e.port.state);
    }

  }

  /**
   * Opens the output for usage. When the library is enabled, all ports are automatically opened.
   * This method is only useful for ports that have been manually closed.
   *
   * @returns {Promise<Output>} The promise is fulfilled with the `Output` object.
   */
  async open() {

    // Explicitly opens the port for usage. This is not mandatory. When the port is not explicitly
    // opened, it is implicitly opened (asynchronously) when calling `send()` on the `MIDIOutput`.
    // We do it explicitly so that 'connected' events are dispatched immediately and we are ready to
    // send.
    try {
      await this._midiOutput.open();
      return Promise.resolve(this);
    } catch (err) {
      return Promise.reject(err);
    }

  }

  /**
   * Closes the output connection. When an output is closed, it cannot be used to send MIDI messages
   * until the output is opened again by calling [`open()`]{@link #open}. You can check
   * the connection status by looking at the [`connection`]{@link #connection} property.
   *
   * @returns {Promise<void>}
   */
  async close() {

    // We close the port. This triggers a 'statechange' event which we listen to to re-trigger the
    // 'closed' event.
    if (this._midiOutput) {
      await this._midiOutput.close();
    } else {
      await Promise.resolve();
    }

  }

  /**
   * Sends a MIDI message on the MIDI output port. If no time is specified, the message will be
   * sent immediately. The message should be an array of 8 bit unsigned integers (0-225), a
   * [`Uint8Array`]{@link https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array}
   * object or a [`Message`](Message) object.
   *
   * It is usually not necessary to use this method directly as you can use one of the simpler
   * helper methods such as [`playNote()`](#playNote), [`stopNote()`](#stopNote),
   * [`sendControlChange()`](#sendControlChange), etc.
   *
   * Details on the format of MIDI messages are available in the summary of
   * [MIDI messages]{@link https://www.midi.org/specifications-old/item/table-1-summary-of-midi-message}
   * from the MIDI Manufacturers Association.
   *
   * @param message {number[]|Uint8Array|Message} An array of 8bit unsigned integers, a `Uint8Array`
   * object (not available in Node.js) containing the message bytes or a `Message` object.
   *
   * @param {object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @throws {RangeError} The first byte (status) must be an integer between 128 and 255.
   *
   * @returns {Output} Returns the `Output` object so methods can be chained.
   *
   * @license Apache-2.0
   */
  send(message, options = {time: 0}, legacy = 0) {

    // If a Message object is passed in we extract the message data (the jzz plugin used on Node.js
    // does not support using Uint8Array).
    if (message instanceof Message) {
      message = Utilities.isNode ? message.data : message.rawData;
    }

    // If the data is a Uint8Array and we are on Node, we must convert it to array so it works with
    // the jzz module.
    if (message instanceof Uint8Array && Utilities.isNode) {
      message = Array.from(message);
    }

    // Validation
    if (wm.validation) {

      // If message is neither an array nor a Uint8Array, then we are in legacy mode
      if (!Array.isArray(message) && !(message instanceof Uint8Array)) {
        message = [message];
        if (Array.isArray(options)) message = message.concat(options);
        options = isNaN(legacy) ? {time: 0} : {time: legacy};
      }

      if (!(parseInt(message[0]) >= 128 && parseInt(message[0]) <= 255)) {
        throw new RangeError("The first byte (status) must be an integer between 128 and 255.");
      }

      message.slice(1).forEach(value => {
        value = parseInt(value);
        if (!(value >= 0 && value <= 255)) {
          throw new RangeError("Data bytes must be integers between 0 and 255.");
        }
      });

      if (!options) options = {time: 0};

    }

    // Send message and return `Output` for chaining
    this._midiOutput.send(message, Utilities.toTimestamp(options.time));
    return this;

  }

  /**
   * Sends a MIDI [**system exclusive**]{@link
    * https://www.midi.org/specifications-old/item/table-4-universal-system-exclusive-messages}
   * (*sysex*) message. There are two categories of system exclusive messages: manufacturer-specific
   * messages and universal messages. Universal messages are further divided into three subtypes:
   *
   *   * Universal non-commercial (for research and testing): `0x7D`
   *   * Universal non-realtime: `0x7E`
   *   * Universal realtime: `0x7F`
   *
   * The method's first parameter (`identification`) identifies the type of message. If the value of
   * `identification` is `0x7D` (125), `0x7E` (126) or `0x7F` (127), the message will be identified
   * as a **universal non-commercial**, **universal non-realtime** or **universal realtime** message
   * (respectively).
   *
   * If the `identification` value is an array or an integer between 0 and 124, it will be used to
   * identify the manufacturer targeted by the message. The *MIDI Manufacturers Association*
   * maintains a full list of
   * [Manufacturer ID Numbers](https://www.midi.org/specifications-old/item/manufacturer-id-numbers).
   *
   * The `data` parameter should only contain the data of the message. When sending out the actual
   * MIDI message, WEBMIDI.js will automatically prepend the data with the **sysex byte** (`0xF0`)
   * and the identification byte(s). It will also automatically terminate the message with the
   * **sysex end byte** (`0xF7`).
   *
   * To use the `sendSysex()` method, system exclusive message support must have been enabled. To
   * do so, you must set the `sysex` option to `true` when calling
   * [`WebMidi.enable()`]{@link WebMidi#enable}:
   *
   * ```js
   * WebMidi.enable({sysex: true})
   *   .then(() => console.log("System exclusive messages are enabled");
   * ```
   *
   * ##### Examples of manufacturer-specific system exclusive messages
   *
   * If you want to send a sysex message to a Korg device connected to the first output, you would
   * use the following code:
   *
   * ```js
   * WebMidi.outputs[0].sendSysex(0x42, [0x1, 0x2, 0x3, 0x4, 0x5]);
   * ```
   * In this case `0x42` is the ID of the manufacturer (Korg) and `[0x1, 0x2, 0x3, 0x4, 0x5]` is the
   * data being sent.
   *
   * The parameters can be specified using any number notation (decimal, hex, binary, etc.).
   * Therefore, the code above is equivalent to this code:
   *
   * ```js
   * WebMidi.outputs[0].sendSysex(66, [1, 2, 3, 4, 5]);
   * ```
   *
   * Some manufacturers are identified using 3 bytes. In this case, you would use a 3-position array
   * as the first parameter. For example, to send the same sysex message to a
   * *Native Instruments* device:
   *
   * ```js
   * WebMidi.outputs[0].sendSysex([0x00, 0x21, 0x09], [0x1, 0x2, 0x3, 0x4, 0x5]);
   * ```
   *
   * There is no limit for the length of the data array. However, it is generally suggested to keep
   * system exclusive messages to 64Kb or less.
   *
   * ##### Example of universal system exclusive message
   *
   * If you want to send a universal sysex message, simply assign the correct identification number
   * in the first parameter. Number `0x7D` (125) is for non-commercial, `0x7E` (126) is for
   * non-realtime and `0x7F` (127) is for realtime.
   *
   * So, for example, if you wanted to send an identity request non-realtime message (`0x7E`), you
   * could use the following:
   *
   * ```js
   * WebMidi.outputs[0].sendSysex(0x7E, [0x7F, 0x06, 0x01]);
   * ```
   *
   * For more details on the format of universal messages, consult the list of
   * [universal sysex messages](https://www.midi.org/specifications-old/item/table-4-universal-system-exclusive-messages).
   *
   * @param {number|number[]} identification An unsigned integer or an array of three unsigned
   * integers between `0` and `127` that either identify the manufacturer or sets the message to be
   * a **universal non-commercial message** (`0x7D`), a **universal non-realtime message** (`0x7E`)
   * or a **universal realtime message** (`0x7F`). The *MIDI Manufacturers Association* maintains a
   * full list of
   * [Manufacturer ID Numbers](https://www.midi.org/specifications-old/item/manufacturer-id-numbers).
   *
   * @param {number[]|Uint8Array} [data] A `Uint8Array` or an array of unsigned integers between `0`
   * and `127`. This is the data you wish to transfer.
   *
   * @param {object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @throws {DOMException} Failed to execute 'send' on 'MIDIOutput': System exclusive message is
   * not allowed.
   *
   * @throws {TypeError} Failed to execute 'send' on 'MIDIOutput': The value at index x is greater
   * than 0xFF.
   *
   * @returns {Output} Returns the `Output` object so methods can be chained.
   */
  sendSysex(identification, data= [], options = {}) {

    identification = [].concat(identification);

    // Check if data is Uint8Array
    if (data instanceof Uint8Array) {
      const merged = new Uint8Array(1 + identification.length + data.length + 1);
      merged[0] = Enumerations.SYSTEM_MESSAGES.sysex;
      merged.set(Uint8Array.from(identification), 1);
      merged.set(data, 1 + identification.length);
      merged[merged.length - 1] = Enumerations.SYSTEM_MESSAGES.sysexend;
      this.send(merged, {time: options.time});
    } else {
      const merged = identification.concat(data, Enumerations.SYSTEM_MESSAGES.sysexend);
      this.send([Enumerations.SYSTEM_MESSAGES.sysex].concat(merged), {time: options.time});
    }

    return this;

  };

  /**
   * Clears all MIDI messages that have been queued and scheduled but not yet sent.
   *
   * **Warning**: this method is defined in the
   * [Web MIDI API specification](https://www.w3.org/TR/webmidi/#MIDIOutput) but has not been
   * implemented by all browsers yet. You can follow
   * [this issue](https://github.com/djipco/webmidi/issues/52) for more info.
   *
   * @returns {Output} Returns the `Output` object so methods can be chained.
   */
  clear() {

    if (this._midiOutput.clear) {

      this._midiOutput.clear();

    } else {

      if (wm.validation) {
        console.warn(
          "The 'clear()' method has not yet been implemented in your environment."
        );
      }

    }

    return this;

  }

  /**
   * Sends a MIDI **timecode quarter frame** message. Please note that no processing is being done
   * on the data. It is up to the developer to format the data according to the
   * [MIDI Timecode](https://en.wikipedia.org/wiki/MIDI_timecode) format.
   *
   * @param value {number} The quarter frame message content (integer between 0 and 127).
   *
   * @param {object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {Output} Returns the `Output` object so methods can be chained.
   */
  sendTimecodeQuarterFrame(value, options = {}) {

    if (wm.validation) {
      value = parseInt(value);
      if (isNaN(value) || !(value >= 0 && value <= 127)) {
        throw new RangeError("The value must be an integer between 0 and 127.");
      }
    }

    this.send(
      [
        Enumerations.SYSTEM_MESSAGES.timecode,
        value
      ],
      {time: options.time}
    );

    return this;

  };

  /**
   * Sends a **song position** MIDI message. The value is expressed in MIDI beats (between `0` and
   * `16383`) which are 16th note. Position `0` is always the start of the song.
   *
   * @param {number} [value=0] The MIDI beat to cue to (integer between `0` and `16383`).
   *
   * @param {object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {Output} Returns the `Output` object so methods can be chained.
   *
   * @since 3.0.0
   */
  sendSongPosition(value = 0, options = {}) {

    // @todo allow passing in 2-entries array for msb/lsb

    value = Math.floor(value) || 0;

    var msb = (value >> 7) & 0x7F;
    var lsb = value & 0x7F;

    this.send(
      [
        Enumerations.SYSTEM_MESSAGES.songposition,
        msb,
        lsb
      ],
      {time: options.time}
    );

    return this;

  }

  /**
   * Sends a **song select** MIDI message.
   *
   * @param {number} [value=0] The number of the song to select (integer between `0` and `127`).
   *
   * @param {object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @throws The song number must be between 0 and 127.
   *
   * @returns {Output} Returns the `Output` object so methods can be chained.
   *
   * @since 3.0.0
   */
  sendSongSelect(value = 0, options = {}) {

    if (wm.validation) {

      value = parseInt(value);

      if (isNaN(value) || !(value >= 0 && value <= 127)) {
        throw new RangeError("The program value must be between 0 and 127");
      }

    }

    this.send(
      [
        Enumerations.SYSTEM_MESSAGES.songselect,
        value
      ],
      {time: options.time}
    );

    return this;

  }

  /**
   * Sends a MIDI **tune request** real-time message.
   *
   * @param {object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {Output} Returns the `Output` object so methods can be chained.
   *
   * @since 3.0.0
   */
  sendTuneRequest(options = {}) {

    this.send(
      [Enumerations.SYSTEM_MESSAGES.tunerequest],
      {time: options.time}
    );

    return this;

  }

  /**
   * Sends a MIDI **clock** real-time message. According to the standard, there are 24 MIDI clocks
   * for every quarter note.
   *
   * @param {object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {Output} Returns the `Output` object so methods can be chained.
   */
  sendClock(options = {}) {

    this.send(
      [Enumerations.SYSTEM_MESSAGES.clock],
      {time: options.time}
    );

    return this;

  }

  /**
   * Sends a **start** real-time message. A MIDI Start message starts the playback of the current
   * song at beat 0. To start playback elsewhere in the song, use the
   * [`sendContinue()`]{@link #sendContinue} method.
   *
   * @param {object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {Output} Returns the `Output` object so methods can be chained.
   */
  sendStart(options = {}) {

    this.send(
      [Enumerations.SYSTEM_MESSAGES.start],
      {time: options.time}
    );

    return this;

  }

  /**
   * Sends a **continue** real-time message. This resumes song playback where it was previously
   * stopped or where it was last cued with a song position message. To start playback from the
   * start, use the [`sendStart()`]{@link Output#sendStart}` method.
   *
   * @param {object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {Output} Returns the `Output` object so methods can be chained.
   */
  sendContinue(options = {}) {

    this.send(
      [Enumerations.SYSTEM_MESSAGES.continue],
      {time: options.time}
    );

    return this;

  }

  /**
   * Sends a **stop** real-time message. This tells the device connected to this output to stop
   * playback immediately (or at the scheduled time, if specified).
   *
   * @param {object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {Output} Returns the `Output` object so methods can be chained.
   */
  sendStop(options = {}) {

    this.send(
      [Enumerations.SYSTEM_MESSAGES.stop],
      {time: options.time}
    );

    return this;

  }

  /**
   * Sends an **active sensing** real-time message. This tells the device connected to this port
   * that the connection is still good. Active sensing messages are often sent every 300 ms if there
   * was no other activity on the MIDI port.
   *
   * @param {object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {Output} Returns the `Output` object so methods can be chained.
   */
  sendActiveSensing(options = {}) {

    this.send(
      [Enumerations.SYSTEM_MESSAGES.activesensing],
      {time: options.time}
    );

    return this;

  }

  /**
   * Sends a **reset** real-time message. This tells the device connected to this output that it
   * should reset itself to a default state.
   *
   * @param {object} [options={}]
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {Output} Returns the `Output` object so methods can be chained.
   */
  sendReset(options = {}) {

    this.send(
      [Enumerations.SYSTEM_MESSAGES.reset],
      {time: options.time}
    );

    return this;

  }

  /**
   * @private
   * @deprecated since version 3.0
   */
  sendTuningRequest(options = {}) {

    if (wm.validation) {
      console.warn(
        "The sendTuningRequest() method has been deprecated. Use sendTuningRequest() instead."
      );
    }

    return this.sendTuneRequest(options);

  }

  /**
   * Sends a MIDI **key aftertouch** message to the specified channel(s) at the scheduled time. This
   * is a key-specific aftertouch. For a channel-wide aftertouch message, use
   * [`setChannelAftertouch()`]{@link #setChannelAftertouch}.
   *
   * @param note {number|Note|string|number[]|Note[]|string[]} The note(s) for which you are sending
   * an aftertouch value. The notes can be specified by using a MIDI note number (`0` - `127`), a
   * [`Note`](Note) object, a note identifier (e.g. `C3`, `G#4`, `F-1`, `Db7`) or an array of the
   * previous types. When using a note identifier, octave range must be between `-1` and `9`. The
   * lowest note is `C-1` (MIDI note number `0`) and the highest note is `G9` (MIDI note number
   * `127`).
   *
   * @param [pressure=0.5] {number} The pressure level (between 0 and 1). An invalid pressure value
   * will silently trigger the default behaviour. If the `rawValue` option is set to `true`, the
   * pressure can be defined by using an integer between 0 and 127.
   *
   * @param {object} [options={}]
   *
   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]
   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no
   * channel is specified, all channels will be used.
   *
   * @param {boolean} [options.rawValue=false] A boolean indicating whether the value should be
   * considered a float between `0` and `1.0` (default) or a raw integer between `0` and `127`.
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @return {Output} Returns the `Output` object so methods can be chained.
   *
   * @since 3.0.0
   */
  sendKeyAftertouch(note, pressure, options = {}) {

    if (options.channels == undefined) options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    Utilities.sanitizeChannels(options.channels).forEach(ch => {
      this.channels[ch].sendKeyAftertouch(note, pressure, options);
    });

    return this;

  };

  /**
   * Sends a MIDI **control change** message to the specified channel(s) at the scheduled time. The
   * control change message to send can be specified numerically (0-127) or by using one of the
   * following common names:
   *
   * | Number | Name                          |
   * |--------|-------------------------------|
   * | 0      |`bankselectcoarse`             |
   * | 1      |`modulationwheelcoarse`        |
   * | 2      |`breathcontrollercoarse`       |
   * | 4      |`footcontrollercoarse`         |
   * | 5      |`portamentotimecoarse`         |
   * | 6      |`dataentrycoarse`              |
   * | 7      |`volumecoarse`                 |
   * | 8      |`balancecoarse`                |
   * | 10     |`pancoarse`                    |
   * | 11     |`expressioncoarse`             |
   * | 12     |`effectcontrol1coarse`         |
   * | 13     |`effectcontrol2coarse`         |
   * | 18     |`generalpurposeslider3`        |
   * | 19     |`generalpurposeslider4`        |
   * | 32     |`bankselectfine`               |
   * | 33     |`modulationwheelfine`          |
   * | 34     |`breathcontrollerfine`         |
   * | 36     |`footcontrollerfine`           |
   * | 37     |`portamentotimefine`           |
   * | 38     |`dataentryfine`                |
   * | 39     |`volumefine`                   |
   * | 40     |`balancefine`                  |
   * | 42     |`panfine`                      |
   * | 43     |`expressionfine`               |
   * | 44     |`effectcontrol1fine`           |
   * | 45     |`effectcontrol2fine`           |
   * | 64     |`holdpedal`                    |
   * | 65     |`portamento`                   |
   * | 66     |`sustenutopedal`               |
   * | 67     |`softpedal`                    |
   * | 68     |`legatopedal`                  |
   * | 69     |`hold2pedal`                   |
   * | 70     |`soundvariation`               |
   * | 71     |`resonance`                    |
   * | 72     |`soundreleasetime`             |
   * | 73     |`soundattacktime`              |
   * | 74     |`brightness`                   |
   * | 75     |`soundcontrol6`                |
   * | 76     |`soundcontrol7`                |
   * | 77     |`soundcontrol8`                |
   * | 78     |`soundcontrol9`                |
   * | 79     |`soundcontrol10`               |
   * | 80     |`generalpurposebutton1`        |
   * | 81     |`generalpurposebutton2`        |
   * | 82     |`generalpurposebutton3`        |
   * | 83     |`generalpurposebutton4`        |
   * | 91     |`reverblevel`                  |
   * | 92     |`tremololevel`                 |
   * | 93     |`choruslevel`                  |
   * | 94     |`celestelevel`                 |
   * | 95     |`phaserlevel`                  |
   * | 96     |`dataincrement`                |
   * | 97     |`datadecrement`                |
   * | 98     |`nonregisteredparametercoarse` |
   * | 99     |`nonregisteredparameterfine`   |
   * | 100    |`registeredparametercoarse`    |
   * | 101    |`registeredparameterfine`      |
   * | 120    |`allsoundoff`                  |
   * | 121    |`resetallcontrollers`          |
   * | 122    |`localcontrol`                 |
   * | 123    |`allnotesoff`                  |
   * | 124    |`omnimodeoff`                  |
   * | 125    |`omnimodeon`                   |
   * | 126    |`monomodeon`                   |
   * | 127    |`polymodeon`                   |
   *
   * Note: as you can see above, not all control change message have a matching name. This does not
   * mean you cannot use the others. It simply means you will need to use their number (`0` - `127`)
   * instead of their name. While you can still use them, numbers `120` to `127` are usually
   * reserved for *channel mode* messages. See [`sendChannelMode()`]{@link #sendChannelMode} method
   * for more info.
   *
   * To view a list of all available **control change** messages, please consult [Table 3 - Control
   * Change Messages](https://www.midi.org/specifications-old/item/table-3-control-change-messages-data-bytes-2)
   * from the MIDI specification.
   *
   * @param controller {number|string} The MIDI controller name or number (0-127).
   *
   * @param [value=0] {number} The value to send (0-127).
   *
   * @param {object} [options={}]
   *
   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]
   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no
   * channel is specified, all channels will be used.
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @throws {RangeError} Controller numbers must be between 0 and 127.
   * @throws {RangeError} Invalid controller name.
   *
   * @return {Output} Returns the `Output` object so methods can be chained.
   */
  sendControlChange(controller, value, options = {}, legacy = {}) {

    if (wm.validation) {

      // Legacy compatibility
      if (Array.isArray(options) || Number.isInteger(options) || options === "all") {
        const channels = options;
        options = legacy;
        options.channels = channels;
        if (options.channels === "all") options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;
      }

    }

    if (options.channels == undefined) options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    Utilities.sanitizeChannels(options.channels).forEach(ch => {
      this.channels[ch].sendControlChange(controller, value, options);
    });

    return this;

  };

  /**
   * Sends a **pitch bend range** message to the specified channel(s) at the scheduled time so that
   * they adjust the range used by their pitch bend lever. The range is specified by using the
   * `semitones` and `cents` parameters. For example, setting the `semitones` parameter to `12`
   * means that the pitch bend range will be 12 semitones above and below the nominal pitch.
   *
   * @param {number} [semitones=0] The desired adjustment value in semitones (between `0` and `127`).
   * While nothing imposes that in the specification, it is very common for manufacturers to limit
   * the range to 2 octaves (-12 semitones to 12 semitones).
   *
   * @param {number} [cents=0] The desired adjustment value in cents (integer between `0` and
   * `127`).
   *
   * @param {object} [options={}]
   *
   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]
   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no
   * channel is specified, all channels will be used.
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @throws {RangeError} The msb value must be between 0 and 127.
   * @throws {RangeError} The lsb value must be between 0 and 127.
   *
   * @returns {Output} Returns the `Output` object so methods can be chained.
   *
   * @since 3.0.0
   */
  sendPitchBendRange(semitones= 0, cents = 0, options = {}) {

    if (options.channels == undefined) options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    Utilities.sanitizeChannels(options.channels).forEach(ch => {
      this.channels[ch].sendPitchBendRange(semitones, cents, options);
    });

    return this;

  }


  /**
   * @private
   * @deprecated since version 3.0
   */
  setPitchBendRange(semitones = 0, cents = 0, channel = "all", options = {}) {

    if (wm.validation) {

      console.warn(
        "The setPitchBendRange() method is deprecated. Use sendPitchBendRange() instead."
      );

      options.channels = channel;
      if (options.channels === "all") options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    }

    return this.sendPitchBendRange(semitones, cents, options);

  }

  /**
   * Sets the specified MIDI registered parameter to the desired value. The value is defined with
   * up to two bytes of data (msb, lsb) that each can go from `0` to `127`.
   *
   * MIDI
   * [registered parameters](https://www.midi.org/specifications-old/item/table-3-control-change-messages-data-bytes-2)
   * extend the original list of control change messages. The MIDI 1.0 specification lists only a
   * limited number of them:
   *
   * | Numbers      | Function                 |
   * |--------------|--------------------------|
   * | (0x00, 0x00) | `pitchbendrange`         |
   * | (0x00, 0x01) | `channelfinetuning`      |
   * | (0x00, 0x02) | `channelcoarsetuning`    |
   * | (0x00, 0x03) | `tuningprogram`          |
   * | (0x00, 0x04) | `tuningbank`             |
   * | (0x00, 0x05) | `modulationrange`        |
   * | (0x3D, 0x00) | `azimuthangle`           |
   * | (0x3D, 0x01) | `elevationangle`         |
   * | (0x3D, 0x02) | `gain`                   |
   * | (0x3D, 0x03) | `distanceratio`          |
   * | (0x3D, 0x04) | `maximumdistance`        |
   * | (0x3D, 0x05) | `maximumdistancegain`    |
   * | (0x3D, 0x06) | `referencedistanceratio` |
   * | (0x3D, 0x07) | `panspreadangle`         |
   * | (0x3D, 0x08) | `rollangle`              |
   *
   * Note that the `tuningprogram` and `tuningbank` parameters are part of the *MIDI Tuning
   * Standard*, which is not widely implemented.
   *
   * @param parameter {string|number[]} A string identifying the parameter's name (see above) or a
   * two-position array specifying the two control bytes (e.g. `[0x65, 0x64]`) that identify the
   * registered parameter.
   *
   * @param [data=[]] {number|number[]} A single integer or an array of integers with a maximum
   * length of 2 specifying the desired data.
   *
   * @param {object} [options={}]
   *
   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]
   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no
   * channel is specified, all channels will be used.
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {Output} Returns the `Output` object so methods can be chained.
   */
  sendRpnValue(parameter, data, options = {}) {

    if (options.channels == undefined) options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    Utilities.sanitizeChannels(options.channels).forEach(ch => {
      this.channels[ch].sendRpnValue(parameter, data, options);
    });

    return this;

  }

  /**
   * @private
   * @deprecated since version 3.0
   */
  setRegisteredParameter(parameter, data = [], channel = "all", options = {}) {

    if (wm.validation) {

      console.warn(
        "The setRegisteredParameter() method is deprecated. Use sendRpnValue() instead."
      );

      options.channels = channel;
      if (options.channels === "all") options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    }

    return this.sendRpnValue(parameter, data, options);

  }

  /**
   * Sends a MIDI **channel aftertouch** message to the specified channel(s). For key-specific
   * aftertouch, you should instead use [`setKeyAftertouch()`]{@link #setKeyAftertouch}.
   *
   * @param [pressure=0.5] {number} The pressure level (between `0` and `1`). An invalid pressure
   * value will silently trigger the default behaviour. If the `rawValue` option is set to `true`,
   * the pressure can be defined by using an integer between `0` and `127`.
   *
   * @param {object} [options={}]
   *
   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]
   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no
   * channel is specified, all channels will be used.
   *
   * @param {boolean} [options.rawValue=false] A boolean indicating whether the value should be
   * considered a float between `0` and `1.0` (default) or a raw integer between `0` and `127`.
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @return {Output} Returns the `Output` object so methods can be chained.
   * @since 3.0.0
   */
  sendChannelAftertouch(pressure, options = {}, legacy = {}) {

    if (wm.validation) {

      // Legacy compatibility
      if (Array.isArray(options) || Number.isInteger(options) || options === "all") {
        const channels = options;
        options = legacy;
        options.channels = channels;
        if (options.channels === "all") options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;
      }

    }

    if (options.channels == undefined) options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    Utilities.sanitizeChannels(options.channels).forEach(ch => {
      this.channels[ch].sendChannelAftertouch(pressure, options);
    });

    return this;

  }

  /**
   * Sends a MIDI **pitch bend** message to the specified channel(s) at the scheduled time.
   *
   * The resulting bend is relative to the pitch bend range that has been defined. The range can be
   * set with [`sendPitchBendRange()`]{@link #sendPitchBendRange}. So, for example, if the pitch
   * bend range has been set to 12 semitones, using a bend value of `-1` will bend the note 1 octave
   * below its nominal value.
   *
   * @param {number|number[]} value The intensity of the bend (between `-1.0` and `1.0`). A value of
   * `0` means no bend. If an invalid value is specified, the nearest valid value will be used
   * instead. If the `rawValue` option is set to `true`, the intensity of the bend can be defined by
   * either using a single integer between `0` and `127` (MSB) or an array of two integers between
   * `0` and `127` representing, respectively, the MSB (most significant byte) and the LSB (least
   * significant byte). The MSB is expressed in semitones with `64` meaning no bend. A value lower
   * than `64` bends downwards while a value higher than `64` bends upwards. The LSB is expressed
   * in cents (1/100 of a semitone). An LSB of `64` also means no bend.
   *
   * @param {object} [options={}]
   *
   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]
   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no
   * channel is specified, all channels will be used.
   *
   * @param {boolean} [options.rawValue=false] A boolean indicating whether the value should be
   * considered as a float between `-1.0` and `1.0` (default) or as raw integer between `0` and
   * 127` (or an array of 2 integers if using both MSB and LSB).
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {Output} Returns the `Output` object so methods can be chained.
   *
   * @since 3.0.0
   */
  sendPitchBend(value, options = {}, legacy = {}) {

    if (wm.validation) {

      // Legacy compatibility
      if (Array.isArray(options) || Number.isInteger(options) || options === "all") {
        const channels = options;
        options = legacy;
        options.channels = channels;
        if (options.channels === "all") options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;
      }

    }

    if (options.channels == undefined) options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    Utilities.sanitizeChannels(options.channels).forEach(ch => {
      this.channels[ch].sendPitchBend(value, options);
    });

    return this;

  }

  /**
   * Sends a MIDI **program change** message to the specified channel(s) at the scheduled time.
   *
   * @param {number} [program=0] The MIDI patch (program) number (integer between `0` and `127`).
   *
   * @param {Object} [options={}]
   *
   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]
   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no
   * channel is specified, all channels will be used.
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @throws {TypeError} Failed to execute 'send' on 'MIDIOutput': The value at index 1 is greater
   * than 0xFF.
   *
   * @return {Output} Returns the `Output` object so methods can be chained.
   *
   * @since 3.0.0
   */
  sendProgramChange(program = 0, options = {}, legacy = {}) {

    if (wm.validation) {

      // Legacy compatibility
      if (Array.isArray(options) || Number.isInteger(options) || options === "all") {
        const channels = options;
        options = legacy;
        options.channels = channels;
        if (options.channels === "all") options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;
      }

    }

    if (options.channels == undefined) options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    Utilities.sanitizeChannels(options.channels).forEach(ch => {
      this.channels[ch].sendProgramChange(program, options);
    });

    return this;

  }

  /**
   * Sends a **modulation depth range** message to the specified channel(s) so that they adjust the
   * depth of their modulation wheel's range. The range can be specified with the `semitones`
   * parameter, the `cents` parameter or by specifying both parameters at the same time.
   *
   * @param [semitones=0] {number} The desired adjustment value in semitones (integer between
   * 0 and 127).
   *
   * @param [cents=0] {number} The desired adjustment value in cents (integer between 0 and 127).
   *
   * @param {Object} [options={}]
   *
   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]
   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no
   * channel is specified, all channels will be used.
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @throws {RangeError} The msb value must be between 0 and 127
   * @throws {RangeError} The lsb value must be between 0 and 127
   *
   * @return {Output} Returns the `Output` object so methods can be chained.
   *
   * @since 3.0.0
   */
  sendModulationRange(semitones, cents, options = {}) {

    if (options.channels == undefined) options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    Utilities.sanitizeChannels(options.channels).forEach(ch => {
      this.channels[ch].sendModulationRange(semitones, cents, options);
    });

    return this;

  };

  /**
   * @private
   * @deprecated since version 3.0
   */
  setModulationRange(semitones = 0, cents = 0, channel = "all", options = {}) {

    if (wm.validation) {

      console.warn(
        "The setModulationRange() method is deprecated. Use sendModulationRange() instead."
      );

      options.channels = channel;
      if (options.channels === "all") options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    }

    return this.sendModulationRange(semitones, cents, options);

  }

  /**
   * Sends a master tuning message to the specified channel(s). The value is decimal and must be
   * larger than `-65` semitones and smaller than `64` semitones.
   *
   * Because of the way the MIDI specification works, the decimal portion of the value will be
   * encoded with a resolution of 14bit. The integer portion must be between -64 and 63
   * inclusively. This function actually generates two MIDI messages: a **Master Coarse Tuning** and
   * a **Master Fine Tuning** RPN messages.
   *
   * @param [value=0.0] {number} The desired decimal adjustment value in semitones (-65 < x < 64)
   *
   * @param {Object} [options={}]
   *
   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]
   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no
   * channel is specified, all channels will be used.
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @throws {RangeError} The value must be a decimal number between larger than -65 and smaller
   * than 64.
   *
   * @return {Output} Returns the `Output` object so methods can be chained.
   *
   * @since 3.0.0
   */
  sendMasterTuning(value, options = {}) {

    if (options.channels == undefined) options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    Utilities.sanitizeChannels(options.channels).forEach(ch => {
      this.channels[ch].sendMasterTuning(value, options);
    });

    return this;

  }

  /**
   * @private
   * @deprecated since version 3.0
   */
  setMasterTuning(value, channel = {}, options = {}) {

    if (wm.validation) {

      console.warn(
        "The setMasterTuning() method is deprecated. Use sendMasterTuning() instead."
      );

      options.channels = channel;
      if (options.channels === "all") options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    }

    return this.sendMasterTuning(value, options);

  }

  /**
   * Sets the MIDI tuning program to use. Note that the **Tuning Program** parameter is part of the
   * *MIDI Tuning Standard*, which is not widely implemented.
   *
   * @param value {number} The desired tuning program (integer between `0` and `127`).
   *
   * @param {Object} [options={}]
   *
   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]
   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no
   * channel is specified, all channels will be used.
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @throws {RangeError} The program value must be between 0 and 127.
   *
   * @return {Output} Returns the `Output` object so methods can be chained.
   *
   * @since 3.0.0
   */
  sendTuningProgram(value, options = {}) {

    if (options.channels == undefined) options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    Utilities.sanitizeChannels(options.channels).forEach(ch => {
      this.channels[ch].sendTuningProgram(value, options);
    });

    return this;

  }

  /**
   * @private
   * @deprecated since version 3.0
   */
  setTuningProgram(value, channel = "all", options = {}) {

    if (wm.validation) {

      console.warn(
        "The setTuningProgram() method is deprecated. Use sendTuningProgram() instead."
      );

      options.channels = channel;
      if (options.channels === "all") options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    }

    return this.sendTuningProgram(value, options);

  }

  /**
   * Sets the MIDI tuning bank to use. Note that the **Tuning Bank** parameter is part of the
   * *MIDI Tuning Standard*, which is not widely implemented.
   *
   * @param {number} [value=0] The desired tuning bank (integer between `0` and `127`).
   *
   * @param {Object} [options={}]
   *
   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]
   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no
   * channel is specified, all channels will be used.
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @throws {RangeError} The bank value must be between 0 and 127.
   *
   * @return {Output} Returns the `Output` object so methods can be chained.
   *
   * @since 3.0.0
   */
  sendTuningBank(value= 0, options = {}) {

    if (options.channels == undefined) options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    Utilities.sanitizeChannels(options.channels).forEach(ch => {
      this.channels[ch].sendTuningBank(value, options);
    });

    return this;

  };

  /**
   * @private
   * @deprecated since version 3.0
   */
  setTuningBank(parameter, channel = "all", options = {}) {

    if (wm.validation) {

      console.warn(
        "The setTuningBank() method is deprecated. Use sendTuningBank() instead."
      );

      options.channels = channel;
      if (options.channels === "all") options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    }

    return this.sendTuningBank(parameter, options);

  }

  /**
   * Sends a MIDI **channel mode** message to the specified channel(s). The channel mode message to
   * send can be specified numerically or by using one of the following common names:
   *
   * |  Type                |Number| Shortcut Method                                               |
   * | ---------------------|------|-------------------------------------------------------------- |
   * | `allsoundoff`        | 120  | [`sendAllSoundOff()`]{@link #sendAllSoundOff}                 |
   * | `resetallcontrollers`| 121  | [`sendResetAllControllers()`]{@link #sendResetAllControllers} |
   * | `localcontrol`       | 122  | [`sendLocalControl()`]{@link #sendLocalControl}               |
   * | `allnotesoff`        | 123  | [`sendAllNotesOff()`]{@link #sendAllNotesOff}                 |
   * | `omnimodeoff`        | 124  | [`sendOmniMode(false)`]{@link #sendOmniMode}                  |
   * | `omnimodeon`         | 125  | [`sendOmniMode(true)`]{@link #sendOmniMode}                   |
   * | `monomodeon`         | 126  | [`sendPolyphonicMode("mono")`]{@link #sendPolyphonicMode}     |
   * | `polymodeon`         | 127  | [`sendPolyphonicMode("poly")`]{@link #sendPolyphonicMode}     |
   *
   * Note: as you can see above, to make it easier, all channel mode messages also have a matching
   * helper method.
   *
   * It should also be noted that, per the MIDI specification, only `localcontrol` and `monomodeon`
   * may require a value that's not zero. For that reason, the `value` parameter is optional and
   * defaults to 0.
   *
   * @param {number|string} command The numerical identifier of the channel mode message (integer
   * between 120-127) or its name as a string.
   *
   * @param {number} [value=0] The value to send (integer between 0-127).
   *
   * @param {Object} [options={}]
   *
   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]
   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no
   * channel is specified, all channels will be used.
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @throws {TypeError} Invalid channel mode message name.
   * @throws {RangeError} Channel mode controller numbers must be between 120 and 127.
   * @throws {RangeError} Value must be an integer between 0 and 127.
   *
   * @return {Output} Returns the `Output` object so methods can be chained.
   *
   */
  sendChannelMode(command, value = 0, options = {}, legacy = {}) {

    if (wm.validation) {

      // Legacy compatibility
      if (Array.isArray(options) || Number.isInteger(options) || options === "all") {
        const channels = options;
        options = legacy;
        options.channels = channels;
        if (options.channels === "all") options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;
      }

    }

    if (options.channels == undefined) options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    Utilities.sanitizeChannels(options.channels).forEach(ch => {
      this.channels[ch].sendChannelMode(command, value, options);
    });

    return this;

  }

  /**
   * Sends an **all sound off** channel mode message. This will silence all sounds playing on that
   * channel but will not prevent new sounds from being triggered.
   *
   * @param {Object} [options={}]
   *
   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]
   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no
   * channel is specified, all channels will be used.
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {Output}
   *
   * @since 3.0.0
   */
  sendAllSoundOff(options = {}) {

    if (options.channels == undefined) options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    Utilities.sanitizeChannels(options.channels).forEach(ch => {
      this.channels[ch].sendAllSoundOff(options);
    });

    return this;

  }

  /**
   * Sends an **all notes off** channel mode message. This will make all currently playing notes
   * fade out just as if their key had been released. This is different from the
   * [`sendAllSoundOff()`]{@link #sendAllSoundOff} method which mutes all sounds immediately.
   *
   * @param {Object} [options={}]
   *
   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]
   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no
   * channel is specified, all channels will be used.
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {Output}
   *
   * @since 3.0.0
   */
  sendAllNotesOff(options = {}) {

    if (options.channels == undefined) options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    Utilities.sanitizeChannels(options.channels).forEach(ch => {
      this.channels[ch].sendAllNotesOff(options);
    });

    return this;

  }

  /**
   * Sends a **reset all controllers** channel mode message. This resets all controllers, such as
   * the pitch bend, to their default value.
   *
   * @param {Object} [options={}]
   *
   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]
   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no
   * channel is specified, all channels will be used.
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {Output}
   */
  sendResetAllControllers(options = {}, legacy = {}) {

    if (wm.validation) {

      // Legacy compatibility
      if (Array.isArray(options) || Number.isInteger(options) || options === "all") {
        const channels = options;
        options = legacy;
        options.channels = channels;
        if (options.channels === "all") options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;
      }

    }

    if (options.channels == undefined) options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    Utilities.sanitizeChannels(options.channels).forEach(ch => {
      this.channels[ch].sendResetAllControllers(options);
    });

    return this;

  }

  /**
   * Sets the polyphonic mode. In `poly` mode (usually the default), multiple notes can be played
   * and heard at the same time. In `mono` mode, only one note will be heard at once even if
   * multiple notes are being played.
   *
   * @param mode {string} The mode to use: `mono` or `poly`.
   *
   * @param {Object} [options={}]
   *
   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]
   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no
   * channel is specified, all channels will be used.
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @return {Output} Returns the `Output` object so methods can be chained.
   *
   * @since 3.0.0
   */
  sendPolyphonicMode(mode, options = {}, legacy = {}) {

    if (wm.validation) {

      // Legacy compatibility
      if (Array.isArray(options) || Number.isInteger(options) || options === "all") {
        const channels = options;
        options = legacy;
        options.channels = channels;
        if (options.channels === "all") options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;
      }

    }

    if (options.channels == undefined) options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    Utilities.sanitizeChannels(options.channels).forEach(ch => {
      this.channels[ch].sendPolyphonicMode(mode, options);
    });

    return this;

  }

  /**
   * Turns local control on or off. Local control is usually enabled by default. If you disable it,
   * the instrument will no longer trigger its own sounds. It will only send the MIDI messages to
   * its out port.
   *
   * @param [state=false] {boolean} Whether to activate local control (`true`) or disable it
   * (`false`).
   *
   * @param {Object} [options={}]
   *
   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]
   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no
   * channel is specified, all channels will be used.
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @return {Output} Returns the `Output` object so methods can be chained.
   *
   * @since 3.0.0
   */
  sendLocalControl(state, options = {}, legacy = {}) {

    if (wm.validation) {

      // Legacy compatibility
      if (Array.isArray(options) || Number.isInteger(options) || options === "all") {
        const channels = options;
        options = legacy;
        options.channels = channels;
        if (options.channels === "all") options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;
      }

    }

    if (options.channels == undefined) options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    Utilities.sanitizeChannels(options.channels).forEach(ch => {
      this.channels[ch].sendLocalControl(state, options);
    });

    return this;

  }

  /**
   * Sets OMNI mode to **on** or **off** for the specified channel(s). MIDI's OMNI mode causes the
   * instrument to respond to messages from all channels.
   *
   * It should be noted that support for OMNI mode is not as common as it used to be.
   *
   * @param [state] {boolean} Whether to activate OMNI mode (`true`) or not (`false`).
   *
   * @param {Object} [options={}]
   *
   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]
   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no
   * channel is specified, all channels will be used.
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @throws {TypeError} Invalid channel mode message name.
   * @throws {RangeError} Channel mode controller numbers must be between 120 and 127.
   * @throws {RangeError} Value must be an integer between 0 and 127.
   *
   * @return {Output} Returns the `Output` object so methods can be chained.
   *
   * @since 3.0.0
   */
  sendOmniMode(state, options = {}, legacy = {}) {

    if (wm.validation) {

      // Legacy compatibility
      if (Array.isArray(options) || Number.isInteger(options) || options === "all") {
        const channels = options;
        options = legacy;
        options.channels = channels;
        if (options.channels === "all") options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;
      }

    }

    if (options.channels == undefined) options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    Utilities.sanitizeChannels(options.channels).forEach(ch => {
      this.channels[ch].sendOmniMode(state, options);
    });

    return this;

  }

  /**
   * Sets a non-registered parameter to the specified value. The NRPN is selected by passing a
   * two-position array specifying the values of the two control bytes. The value is specified by
   * passing a single integer (most cases) or an array of two integers.
   *
   * NRPNs are not standardized in any way. Each manufacturer is free to implement them any way
   * they see fit. For example, according to the Roland GS specification, you can control the
   * **vibrato rate** using NRPN (`1`, `8`). Therefore, to set the **vibrato rate** value to `123`
   * you would use:
   *
   * ```js
   * WebMidi.outputs[0].sendNrpnValue([1, 8], 123);
   * ```
   *
   * You probably want to should select a channel so the message is not sent to all channels. For
   * instance, to send to channel `1` of the first output port, you would use:
   *
   * ```js
   * WebMidi.outputs[0].sendNrpnValue([1, 8], 123, 1);
   * ```
   *
   * In some rarer cases, you need to send two values with your NRPN messages. In such cases, you
   * would use a 2-position array. For example, for its **ClockBPM** parameter (`2`, `63`), Novation
   * uses a 14-bit value that combines an MSB and an LSB (7-bit values). So, for example, if the
   * value to send was `10`, you could use:
   *
   * ```js
   * WebMidi.outputs[0].sendNrpnValue([2, 63], [0, 10], 1);
   * ```
   *
   * For further implementation details, refer to the manufacturer's documentation.
   *
   * @param parameter {number[]} A two-position array specifying the two control bytes (`0x63`,
   * `0x62`) that identify the non-registered parameter.
   *
   * @param [data=[]] {number|number[]} An integer or an array of integers with a length of 1 or 2
   * specifying the desired data.
   *
   * @param {Object} [options={}]
   *
   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]
   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no
   * channel is specified, all channels will be used.
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @throws {RangeError} The control value must be between 0 and 127.
   * @throws {RangeError} The msb value must be between 0 and 127
   *
   * @returns {Output} Returns the `Output` object so methods can be chained.
   */
  sendNrpnValue(parameter, data, options = {}) {

    if (options.channels == undefined) options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    Utilities.sanitizeChannels(options.channels).forEach(ch => {
      this.channels[ch].sendNrpnValue(parameter, data, options);
    });

    return this;

  }

  /**
   * @private
   * @deprecated since version 3.0
   */
  setNonRegisteredParameter(parameter, data = [], channel = "all", options = {}) {

    if (wm.validation) {

      console.warn(
        "The setNonRegisteredParameter() method is deprecated. Use sendNrpnValue() instead."
      );

      options.channels = channel;
      if (options.channels === "all") options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    }

    return this.sendNrpnValue(parameter, data, options);

  }

  /**
   * Increments the specified MIDI registered parameter by 1. Here is the full list of parameter
   * names that can be used with this method:
   *
   *  * Pitchbend Range (0x00, 0x00): `"pitchbendrange"`
   *  * Channel Fine Tuning (0x00, 0x01): `"channelfinetuning"`
   *  * Channel Coarse Tuning (0x00, 0x02): `"channelcoarsetuning"`
   *  * Tuning Program (0x00, 0x03): `"tuningprogram"`
   *  * Tuning Bank (0x00, 0x04): `"tuningbank"`
   *  * Modulation Range (0x00, 0x05): `"modulationrange"`
   *  * Azimuth Angle (0x3D, 0x00): `"azimuthangle"`
   *  * Elevation Angle (0x3D, 0x01): `"elevationangle"`
   *  * Gain (0x3D, 0x02): `"gain"`
   *  * Distance Ratio (0x3D, 0x03): `"distanceratio"`
   *  * Maximum Distance (0x3D, 0x04): `"maximumdistance"`
   *  * Maximum Distance Gain (0x3D, 0x05): `"maximumdistancegain"`
   *  * Reference Distance Ratio (0x3D, 0x06): `"referencedistanceratio"`
   *  * Pan Spread Angle (0x3D, 0x07): `"panspreadangle"`
   *  * Roll Angle (0x3D, 0x08): `"rollangle"`
   *
   * @param parameter {String|number[]} A string identifying the parameter's name (see above) or a
   * two-position array specifying the two control bytes (0x65, 0x64) that identify the registered
   * parameter.
   *
   * @param {Object} [options={}]
   *
   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]
   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no
   * channel is specified, all channels will be used.
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {Output} Returns the `Output` object so methods can be chained.
   */
  sendRpnIncrement(parameter, options = {}) {

    if (options.channels == undefined) options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    Utilities.sanitizeChannels(options.channels).forEach(ch => {
      this.channels[ch].sendRpnIncrement(parameter, options);
    });

    return this;

  }

  /**
   * @private
   * @deprecated since version 3.0
   */
  incrementRegisteredParameter(parameter, channel = "all", options = {}) {

    if (wm.validation) {

      console.warn(
        "The incrementRegisteredParameter() method is deprecated. Use sendRpnIncrement() instead."
      );

      options.channels = channel;
      if (options.channels === "all") options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    }

    return this.sendRpnIncrement(parameter, options);

  }

  /**
   * Decrements the specified MIDI registered parameter by 1. Here is the full list of parameter
   * names that can be used with this method:
   *
   *  * Pitchbend Range (0x00, 0x00): `"pitchbendrange"`
   *  * Channel Fine Tuning (0x00, 0x01): `"channelfinetuning"`
   *  * Channel Coarse Tuning (0x00, 0x02): `"channelcoarsetuning"`
   *  * Tuning Program (0x00, 0x03): `"tuningprogram"`
   *  * Tuning Bank (0x00, 0x04): `"tuningbank"`
   *  * Modulation Range (0x00, 0x05): `"modulationrange"`
   *  * Azimuth Angle (0x3D, 0x00): `"azimuthangle"`
   *  * Elevation Angle (0x3D, 0x01): `"elevationangle"`
   *  * Gain (0x3D, 0x02): `"gain"`
   *  * Distance Ratio (0x3D, 0x03): `"distanceratio"`
   *  * Maximum Distance (0x3D, 0x04): `"maximumdistance"`
   *  * Maximum Distance Gain (0x3D, 0x05): `"maximumdistancegain"`
   *  * Reference Distance Ratio (0x3D, 0x06): `"referencedistanceratio"`
   *  * Pan Spread Angle (0x3D, 0x07): `"panspreadangle"`
   *  * Roll Angle (0x3D, 0x08): `"rollangle"`
   *
   * @param parameter {String|number[]} A string identifying the parameter's name (see above) or a
   * two-position array specifying the two control bytes (0x65, 0x64) that identify the registered
   * parameter.
   *
   * @param {Object} [options={}]
   *
   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]
   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no
   * channel is specified, all channels will be used.
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @throws TypeError The specified parameter is not available.
   *
   * @returns {Output} Returns the `Output` object so methods can be chained.
   */
  sendRpnDecrement(parameter, options = {}) {

    if (options.channels == undefined) options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    Utilities.sanitizeChannels(options.channels).forEach(ch => {
      this.channels[ch].sendRpnDecrement(parameter, options);
    });

    return this;

  }

  /**
   * @private
   * @deprecated since version 3.0
   */
  decrementRegisteredParameter(parameter, channel = "all", options = {}) {

    if (wm.validation) {

      console.warn(
        "The decrementRegisteredParameter() method is deprecated. Use sendRpnDecrement() instead."
      );

      options.channels = channel;
      if (options.channels === "all") options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    }

    return this.sendRpnDecrement(parameter, options);

  }

  /**
   * Sends a **note off** message for the specified MIDI note number on the specified channel(s).
   * The first parameter is the note to stop. It can be a single value or an array of the following
   * valid values:
   *
   *  - A MIDI note number (integer between `0` and `127`)
   *  - A note identifier (e.g. `"C3"`, `"G#4"`, `"F-1"`, `"Db7"`)
   *  - A [`Note`](Note) object
   *
   * The execution of the **note off** command can be delayed by using the `time` property of the
   * `options` parameter.
   *
   * @param note {number|Note|string|number[]|Note[]|string[]} The note(s) to stop. The notes can be
   * specified by using a MIDI note number (`0` - `127`), a note identifier (e.g. `C3`, `G#4`,
   * `F-1`, `Db7`) or an array of the previous types. When using a note identifier, octave range
   * must be between `-1` and `9`. The lowest note is `C-1` (MIDI note number `0`) and the highest
   * note is `G9` (MIDI note number `127`).
   *
   * @param {Object} [options={}]
   *
   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]
   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no
   * channel is specified, all channels will be used.
   *
   * @param {number} [options.release=0.5] The velocity at which to release the note
   * (between `0` and `1`).  If the `rawRelease` option is also defined, `rawRelease` will have
   * priority. An invalid velocity value will silently trigger the default of `0.5`.
   *
   * @param {number} [options.rawRelease=64] The velocity at which to release the note
   * (between `0` and `127`). If the `release` option is also defined, `rawRelease` will have
   * priority. An invalid velocity value will silently trigger the default of `64`.
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {Output} Returns the `Output` object so methods can be chained.
   */
  sendNoteOff(note, options= {}, legacy = {}) {

    if (wm.validation) {

      // Legacy compatibility
      if (Array.isArray(options) || Number.isInteger(options) || options === "all") {
        const channels = options;
        options = legacy;
        options.channels = channels;
        if (options.channels === "all") options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;
      }

    }

    if (options.channels == undefined) options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    Utilities.sanitizeChannels(options.channels).forEach(ch => {
      this.channels[ch].sendNoteOff(note, options);
    });

    return this;

  }

  /**
   * Sends a **note off** message for the specified MIDI note number on the specified channel(s).
   * The first parameter is the note to stop. It can be a single value or an array of the following
   * valid values:
   *
   *  - A MIDI note number (integer between `0` and `127`)
   *  - A note identifier (e.g. `"C3"`, `"G#4"`, `"F-1"`, `"Db7"`)
   *  - A [`Note`](Note) object
   *
   * The execution of the **note off** command can be delayed by using the `time` property of the
   * `options` parameter.
   *
   * @param note {number|Note|string|number[]|Note[]|string[]} The note(s) to stop. The notes can be
   * specified by using a MIDI note number (`0` - `127`), a note identifier (e.g. `C3`, `G#4`, `F-1`,
   * `Db7`) or an array of the previous types. When using a note identifier, octave range must be
   * between `-1` and `9`. The lowest note is `C-1` (MIDI note number `0`) and the highest note is
   * `G9` (MIDI note number `127`).
   *
   * @param {Object} [options={}]
   *
   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]
   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no
   * channel is specified, all channels will be used.
   *
   * @param {number} [options.release=0.5] The velocity at which to release the note
   * (between `0` and `1`).  If the `rawRelease` option is also defined, `rawRelease` will have
   * priority. An invalid velocity value will silently trigger the default of `0.5`.
   *
   * @param {number} [options.rawRelease=64] The velocity at which to release the note
   * (between `0` and `127`). If the `release` option is also defined, `rawRelease` will have
   * priority. An invalid velocity value will silently trigger the default of `64`.
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {Output} Returns the `Output` object so methods can be chained.
   */
  stopNote(note, options) {
    return this.sendNoteOff(note, options);
  }

  /**
   * Plays a note or an array of notes on one or more channels of this output. If you intend to play
   * notes on a single channel, you should probably use
   * [`OutputChannel.playNote()`](OutputChannel#playNote) instead.
   *
   * The first parameter is the note to play. It can be a single value or an array of the following
   * valid values:
   *
   *  - A MIDI note number (integer between `0` and `127`)
   *  - A note identifier (e.g. `"C3"`, `"G#4"`, `"F-1"`, `"Db7"`)
   *  - A [`Note`]{@link Note} object
   *
   * The `playNote()` method sends a **note on** MIDI message for all specified notes on all
   * specified channels. If no channel is specified, it will send to all channels. If a `duration`
   * is set in the `options` parameter or in the [`Note`]{@link Note} object's
   * [`duration`]{@link Note#duration} property, it will also schedule a **note off** message to end
   * the note after said duration. If no `duration` is set, the note will simply play until a
   * matching **note off** message is sent with [`stopNote()`]{@link #stopNote}.
   *
   * The execution of the **note on** command can be delayed by using the `time` property of the
   * `options` parameter.
   *
   * When using [`Note`]{@link Note} objects, the durations and velocities defined in the
   * [`Note`]{@link Note} objects have precedence over the ones specified via the method's `options`
   * parameter.
   *
   * **Note**: As per the MIDI standard, a **note on** message with an attack velocity of `0` is
   * functionally equivalent to a **note off** message.
   *
   * @param note {number|string|Note|number[]|string[]|Note[]} The note(s) to play. The notes can be
   * specified by using a MIDI note number (0-127), a note identifier (e.g. C3, G#4, F-1, Db7), a
   * [`Note`]{@link Note} object or an array of the previous types. When using a note identifier,
   * octave range must be between -1 and 9. The lowest note is C-1 (MIDI note number `0`) and the
   * highest note is G9 (MIDI note number `127`).
   *
   * @param {Object} [options={}]
   *
   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]
   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no
   * channel is specified, all channels will be used.
   *
   * @param {number} [options.duration=undefined] The number of milliseconds after which a
   * **note off** message will be scheduled. If left undefined, only a **note on** message is sent.
   *
   * @param {number} [options.attack=0.5] The velocity at which to play the note (between `0` and
   * `1`). If the `rawAttack` option is also defined, it will have priority. An invalid velocity
   * value will silently trigger the default of `0.5`.
   *
   * @param {number} [options.rawAttack=64] The attack velocity at which to play the note (between
   * `0` and `127`). This has priority over the `attack` property. An invalid velocity value will
   * silently trigger the default of 64.
   *
   * @param {number} [options.release=0.5] The velocity at which to release the note (between `0`
   * and `1`). If the `rawRelease` option is also defined, it will have priority. An invalid
   * velocity value will silently trigger the default of `0.5`. This is only used with the
   * **note off** event triggered when `options.duration` is set.
   *
   * @param {number} [options.rawRelease=64] The velocity at which to release the note (between `0`
   * and `127`). This has priority over the `release` property. An invalid velocity value will
   * silently trigger the default of 64. This is only used with the **note off** event triggered
   * when `options.duration` is set.
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {Output} Returns the `Output` object so methods can be chained.
   */
  playNote(note, options = {}, legacy = {}) {

    if (wm.validation) {

      // Legacy-compatibility warnings
      if (options.rawVelocity) {
        console.warn("The 'rawVelocity' option is deprecated. Use 'rawAttack' instead.");
      }

      if (options.velocity) {
        console.warn("The 'velocity' option is deprecated. Use 'velocity' instead.");
      }

      // Legacy compatibility
      if (Array.isArray(options) || Number.isInteger(options) || options === "all") {
        const channels = options;
        options = legacy;
        options.channels = channels;
        if (options.channels === "all") options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;
      }

    }

    if (options.channels == undefined) options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    Utilities.sanitizeChannels(options.channels).forEach(ch => {
      this.channels[ch].playNote(note, options);
    });

    return this;

  }

  /**
   * Sends a **note on** message for the specified MIDI note number on the specified channel(s). The
   * first parameter is the number. It can be a single value or an array of the following valid
   * values:
   *
   *  - A MIDI note number (integer between `0` and `127`)
   *  - A note identifier (e.g. `"C3"`, `"G#4"`, `"F-1"`, `"Db7"`)
   *  - A [`Note`](Note) object
   *
   *  The execution of the **note on** command can be delayed by using the `time` property of the
   * `options` parameter.
   *
   * **Note**: As per the MIDI standard, a **note on** message with an attack velocity of `0` is
   * functionally equivalent to a **note off** message.
   *
   * @param note {number|Note|string|number[]|Note[]|string[]} The note(s) to stop. The notes can be
   * specified by using a MIDI note number (`0` - `127`), a note identifier (e.g. `C3`, `G#4`, `F-1`,
   * `Db7`) or an array of the previous types. When using a note identifier, octave range must be
   * between `-1` and `9`. The lowest note is `C-1` (MIDI note number `0`) and the highest note is
   * `G9` (MIDI note number `127`).
   *
   * @param {Object} [options={}]
   *
   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]
   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no
   * channel is specified, all channels will be used.
   *
   * @param {number} [options.attack=0.5] The velocity at which to play the note (between `0` and
   * `1`).  If the `rawAttack` option is also defined, `rawAttack` will have priority. An invalid
   * velocity value will silently trigger the default of `0.5`.
   *
   * @param {number} [options.rawAttack=64] The velocity at which to release the note (between `0`
   * and `127`). If the `attack` option is also defined, `rawAttack` will have priority. An invalid
   * velocity value will silently trigger the default of `64`.
   *
   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and
   * followed by a number, the message will be delayed by that many milliseconds. If the value is a
   * positive number
   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),
   * the operation will be scheduled for that time. The current time can be retrieved with
   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the
   * operation will be carried out as soon as possible.
   *
   * @returns {Output} Returns the `Output` object so methods can be chained.
   */
  sendNoteOn(note, options = {}, legacy = {}) {

    if (wm.validation) {

      // Legacy compatibility
      if (Array.isArray(options) || Number.isInteger(options) || options === "all") {
        const channels = options;
        options = legacy;
        options.channels = channels;
        if (options.channels === "all") options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;
      }

    }

    if (options.channels == undefined) options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    // This actually supports passing a Note object even if, semantically, this does not make sense.
    Utilities.sanitizeChannels(options.channels).forEach(ch => {
      this.channels[ch].sendNoteOn(note, options);
    });

    return this;

  }

  /**
   * Name of the MIDI output.
   *
   * @type {string}
   * @readonly
   */
  get name() {
    return this._midiOutput.name;
  }

  /**
   * ID string of the MIDI output. The ID is host-specific. Do not expect the same ID on different
   * platforms. For example, Google Chrome and the Jazz-Plugin report completely different IDs for
   * the same port.
   *
   * @type {string}
   * @readonly
   */
  get id() {
    return this._midiOutput.id;
  }

  /**
   * Output port's connection state: `pending`, `open` or `closed`.
   *
   * @type {string}
   * @readonly
   */
  get connection() {
    return this._midiOutput.connection;
  }

  /**
   * Name of the manufacturer of the device that makes this output port available.
   *
   * @type {string}
   * @readonly
   */
  get manufacturer() {
    return this._midiOutput.manufacturer;
  }

  /**
   * State of the output port: `connected` or `disconnected`.
   *
   * @type {string}
   * @readonly
   */
  get state() {
    return this._midiOutput.state;
  }

  /**
   * Type of the output port (it will always be: `output`).
   *
   * @type {string}
   * @readonly
   */
  get type() {
    return this._midiOutput.type;
  }

  /**
   * An integer to offset the octave of outgoing notes. By default, middle C (MIDI note number 60)
   * is placed on the 4th octave (C4).
   *
   * Note that this value is combined with the global offset value defined in
   * [`WebMidi.octaveOffset`](WebMidi#octaveOffset) (if any).
   *
   * @type {number}
   *
   * @since 3.0
   */
  get octaveOffset() {
    return this._octaveOffset;
  }
  set octaveOffset(value) {

    if (this.validation) {
      value = parseInt(value);
      if (isNaN(value)) throw new TypeError("The 'octaveOffset' property must be an integer.");
    }

    this._octaveOffset = value;

  }

}

/**
 * The `Forwarder` class allows the forwarding of MIDI messages to predetermined outputs. When you
 * call its [`forward()`](#forward) method, it will send the specified [`Message`](Message) object
 * to all the outputs listed in its [`destinations`](#destinations) property.
 *
 * If specific channels or message types have been defined in the [`channels`](#channels) or
 * [`types`](#types) properties, only messages matching the channels/types will be forwarded.
 *
 * While it can be manually instantiated, you are more likely to come across a `Forwarder` object as
 * the return value of the [`Input.addForwarder()`](Input#addForwarder) method.
 *
 * @license Apache-2.0
 * @since 3.0.0
 */
class Forwarder {

  /**
   * Creates a `Forwarder` object.
   *
   * @param {Output|Output[]} [destinations=\[\]] An [`Output`](Output) object, or an array of such
   * objects, to forward the message to.
   *
   * @param {object} [options={}]
   * @param {string|string[]} [options.types=(all messages)] A MIDI message type or an array of such
   * types (`"noteon"`, `"controlchange"`, etc.), that the specified message must match in order to
   * be forwarded. If this option is not specified, all types of messages will be forwarded. Valid
   * messages are the ones found in either
   * [`SYSTEM_MESSAGES`](Enumerations#SYSTEM_MESSAGES)
   * or [`CHANNEL_MESSAGES`](Enumerations#CHANNEL_MESSAGES).
   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]
   * A MIDI channel number or an array of channel numbers that the message must match in order to be
   * forwarded. By default all MIDI channels are included (`1` to `16`).
   */
  constructor(destinations = [], options = {}) {

    /**
     * An array of [`Output`](Output) objects to forward the message to.
     * @type {Output[]}
     */
    this.destinations = [];

    /**
     * An array of message types (`"noteon"`, `"controlchange"`, etc.) that must be matched in order
     * for messages to be forwarded. By default, this array includes all
     * [`Enumerations.SYSTEM_MESSAGES`](Enumerations#SYSTEM_MESSAGES) and
     * [`Enumerations.CHANNEL_MESSAGES`](Enumerations#CHANNEL_MESSAGES).
     * @type {string[]}
     */
    this.types = [
      ...Object.keys(Enumerations.SYSTEM_MESSAGES),
      ...Object.keys(Enumerations.CHANNEL_MESSAGES)
    ];

    /**
     * An array of MIDI channel numbers that the message must match in order to be forwarded. By
     * default, this array includes all MIDI channels (`1` to `16`).
     * @type {number[]}
     */
    this.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    /**
     * Indicates whether message forwarding is currently suspended or not in this forwarder.
     * @type {boolean}
     */
    this.suspended = false;

    // Make sure parameters are arrays
    if (!Array.isArray(destinations)) destinations = [destinations];
    if (options.types && !Array.isArray(options.types)) options.types = [options.types];
    if (options.channels && !Array.isArray(options.channels)) options.channels = [options.channels];

    if (wm.validation) {

      // Validate destinations
      destinations.forEach(destination => {
        if ( !(destination instanceof Output) ) {
          throw new TypeError("Destinations must be of type 'Output'.");
        }
      });

      // Validate types
      if (options.types !== undefined) {

        options.types.forEach(type => {
          if (
            ! Enumerations.SYSTEM_MESSAGES.hasOwnProperty(type) &&
            ! Enumerations.CHANNEL_MESSAGES.hasOwnProperty(type)
          ) {
            throw new TypeError("Type must be a valid message type.");
          }
        });

      }

      // Validate channels
      if (options.channels !== undefined) {

        options.channels.forEach(channel => {
          if (! Enumerations.MIDI_CHANNEL_NUMBERS.includes(channel) ) {
            throw new TypeError("MIDI channel must be between 1 and 16.");
          }
        });

      }

    }

    this.destinations = destinations;
    if (options.types) this.types = options.types;
    if (options.channels) this.channels = options.channels;

  }

  /**
   * Sends the specified message to the forwarder's destination(s) if it matches the specified
   * type(s) and channel(s).
   *
   * @param {Message} message The [`Message`](Message) object to forward.
   */
  forward(message) {

    // Abort if forwarding is currently suspended
    if (this.suspended) return;

    // Abort if this message type should not be forwarded
    if (!this.types.includes(message.type)) return;

    // Abort if this channel should not be forwarded
    if (message.channel && !this.channels.includes(message.channel)) return;

    // Forward
    this.destinations.forEach(destination => {
      if (wm.validation && !(destination instanceof Output)) return;
      destination.send(message);
    });

  }

}

/**
 * The `InputChannel` class represents a single MIDI input channel (1-16) from a single input
 * device. This object is derived from the host's MIDI subsystem and should not be instantiated
 * directly.
 *
 * All 16 `InputChannel` objects can be found inside the input's [`channels`](Input#channels)
 * property.
 *
 * @fires InputChannel#midimessage
 * @fires InputChannel#unknownmessage
 *
 * @fires InputChannel#noteoff
 * @fires InputChannel#noteon
 * @fires InputChannel#keyaftertouch
 * @fires InputChannel#programchange
 * @fires InputChannel#channelaftertouch
 * @fires InputChannel#pitchbend
 *
 * @fires InputChannel#allnotesoff
 * @fires InputChannel#allsoundoff
 * @fires InputChannel#localcontrol
 * @fires InputChannel#monomode
 * @fires InputChannel#omnimode
 * @fires InputChannel#resetallcontrollers
 *
 * @fires InputChannel#event:nrpn
 * @fires InputChannel#event:nrpn-dataentrycoarse
 * @fires InputChannel#event:nrpn-dataentryfine
 * @fires InputChannel#event:nrpn-dataincrement
 * @fires InputChannel#event:nrpn-datadecrement
 * @fires InputChannel#event:rpn
 * @fires InputChannel#event:rpn-dataentrycoarse
 * @fires InputChannel#event:rpn-dataentryfine
 * @fires InputChannel#event:rpn-dataincrement
 * @fires InputChannel#event:rpn-datadecrement
 *
 * @fires InputChannel#controlchange
 * @fires InputChannel#event:controlchange-controllerxxx
 * @fires InputChannel#event:controlchange-bankselectcoarse
 * @fires InputChannel#event:controlchange-modulationwheelcoarse
 * @fires InputChannel#event:controlchange-breathcontrollercoarse
 * @fires InputChannel#event:controlchange-footcontrollercoarse
 * @fires InputChannel#event:controlchange-portamentotimecoarse
 * @fires InputChannel#event:controlchange-dataentrycoarse
 * @fires InputChannel#event:controlchange-volumecoarse
 * @fires InputChannel#event:controlchange-balancecoarse
 * @fires InputChannel#event:controlchange-pancoarse
 * @fires InputChannel#event:controlchange-expressioncoarse
 * @fires InputChannel#event:controlchange-effectcontrol1coarse
 * @fires InputChannel#event:controlchange-effectcontrol2coarse
 * @fires InputChannel#event:controlchange-generalpurposecontroller1
 * @fires InputChannel#event:controlchange-generalpurposecontroller2
 * @fires InputChannel#event:controlchange-generalpurposecontroller3
 * @fires InputChannel#event:controlchange-generalpurposecontroller4
 * @fires InputChannel#event:controlchange-bankselectfine
 * @fires InputChannel#event:controlchange-modulationwheelfine
 * @fires InputChannel#event:controlchange-breathcontrollerfine
 * @fires InputChannel#event:controlchange-footcontrollerfine
 * @fires InputChannel#event:controlchange-portamentotimefine
 * @fires InputChannel#event:controlchange-dataentryfine
 * @fires InputChannel#event:controlchange-channelvolumefine
 * @fires InputChannel#event:controlchange-balancefine
 * @fires InputChannel#event:controlchange-panfine
 * @fires InputChannel#event:controlchange-expressionfine
 * @fires InputChannel#event:controlchange-effectcontrol1fine
 * @fires InputChannel#event:controlchange-effectcontrol2fine
 * @fires InputChannel#event:controlchange-damperpedal
 * @fires InputChannel#event:controlchange-portamento
 * @fires InputChannel#event:controlchange-sostenuto
 * @fires InputChannel#event:controlchange-softpedal
 * @fires InputChannel#event:controlchange-legatopedal
 * @fires InputChannel#event:controlchange-hold2
 * @fires InputChannel#event:controlchange-soundvariation
 * @fires InputChannel#event:controlchange-resonance
 * @fires InputChannel#event:controlchange-releasetime
 * @fires InputChannel#event:controlchange-attacktime
 * @fires InputChannel#event:controlchange-brightness
 * @fires InputChannel#event:controlchange-decaytime
 * @fires InputChannel#event:controlchange-vibratorate
 * @fires InputChannel#event:controlchange-vibratodepth
 * @fires InputChannel#event:controlchange-vibratodelay
 * @fires InputChannel#event:controlchange-generalpurposecontroller5
 * @fires InputChannel#event:controlchange-generalpurposecontroller6
 * @fires InputChannel#event:controlchange-generalpurposecontroller7
 * @fires InputChannel#event:controlchange-generalpurposecontroller8
 * @fires InputChannel#event:controlchange-portamentocontrol
 * @fires InputChannel#event:controlchange-highresolutionvelocityprefix
 * @fires InputChannel#event:controlchange-effect1depth
 * @fires InputChannel#event:controlchange-effect2depth
 * @fires InputChannel#event:controlchange-effect3depth
 * @fires InputChannel#event:controlchange-effect4depth
 * @fires InputChannel#event:controlchange-effect5depth
 * @fires InputChannel#event:controlchange-dataincrement
 * @fires InputChannel#event:controlchange-datadecrement
 * @fires InputChannel#event:controlchange-nonregisteredparameterfine
 * @fires InputChannel#event:controlchange-nonregisteredparametercoarse
 * @fires InputChannel#event:controlchange-registeredparameterfine
 * @fires InputChannel#event:controlchange-registeredparametercoarse
 * @fires InputChannel#event:controlchange-allsoundoff
 * @fires InputChannel#event:controlchange-resetallcontrollers
 * @fires InputChannel#event:controlchange-localcontrol
 * @fires InputChannel#event:controlchange-allnotesoff
 * @fires InputChannel#event:controlchange-omnimodeoff
 * @fires InputChannel#event:controlchange-omnimodeon
 * @fires InputChannel#event:controlchange-monomodeon
 * @fires InputChannel#event:controlchange-polymodeon
 * @fires InputChannel#event:
 *
 * @extends EventEmitter
 * @license Apache-2.0
 * @since 3.0.0
 */
class InputChannel extends EventEmitter {

  /**
   * Creates an `InputChannel` object.
   *
   * @param {Input} input The [`Input`](Input) object this channel belongs to.
   * @param {number} number The channel's MIDI number (1-16).
   */
  constructor(input, number) {

    super();

    /**
     * @type {Input}
     * @private
     */
    this._input = input;

    /**
     * @type {number}
     * @private
     */
    this._number = number;

    /**
     * @type {number}
     * @private
     */
    this._octaveOffset = 0;

    /**
     * An array of messages that form the current NRPN sequence
     * @private
     * @type {Message[]}
     */
    this._nrpnBuffer = [];

    /**
     * An array of messages that form the current RPN sequence
     * @private
     * @type {Message[]}
     */
    this._rpnBuffer = [];

    /**
     * Indicates whether events for **Registered Parameter Number** and **Non-Registered Parameter
     * Number** should be dispatched. RPNs and NRPNs are composed of a sequence of specific
     * **control change** messages. When a valid sequence of such control change messages is
     * received, an [`rpn`](#event-rpn) or [`nrpn`](#event-nrpn) event will fire.
     *
     * If an invalid or out-of-order **control change** message is received, it will fall through
     * the collector logic and all buffered **control change** messages will be discarded as
     * incomplete.
     *
     * @type {boolean}
     */
    this.parameterNumberEventsEnabled = true;

    /**
     * Contains the current playing state of all MIDI notes of this channel (0-127). The state is
     * `true` for a currently playing note and `false` otherwise.
     * @type {boolean[]}
     */
    this.notesState = new Array(128).fill(false);

  }

  /**
   * Destroys the `InputChannel` by removing all listeners and severing the link with the MIDI
   * subsystem's input.
   */
  destroy() {
    this._input = null;
    this._number = null;
    this._octaveOffset = 0;
    this._nrpnBuffer = [];
    this.notesState = new Array(128).fill(false);
    this.parameterNumberEventsEnabled = false;
    this.removeListener();
  }

  /**
   * @param e MIDIMessageEvent
   * @private
   */
  _processMidiMessageEvent(e) {

    // Create and emit a new 'midimessage' event based on the incoming one
    const event = Object.assign({}, e);
    event.port = this.input;
    event.target = this;
    event.type = "midimessage";

    /**
     * Event emitted when a MIDI message of any kind is received by an `InputChannel`
     *
     * @event InputChannel#midimessage
     *
     * @type {object}
     *
     * @property {string} type `midimessage`
     * @property {InputChannel} target The object that dispatched the event.
     * @property {Input} port The `Input` that triggered the event.
     * @property {Message} message A [`Message`](Message) object containing information about the
     * incoming MIDI message.
     * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
     * milliseconds since the navigation start of the document).
     */
    this.emit(event.type, event);

    // Parse the inbound event for regular MIDI messages
    this._parseEventForStandardMessages(event);

  }

  /**
   * Parses incoming channel events and emit standard MIDI message events (noteon, noteoff, etc.)
   * @param e Event
   * @private
   */
  _parseEventForStandardMessages(e) {

    const event = Object.assign({}, e);
    event.type = event.message.type || "unknownmessage";

    const data1 = e.message.dataBytes[0];
    const data2 = e.message.dataBytes[1];

    if ( event.type === "noteoff" || (event.type === "noteon" && data2 === 0) ) {

      this.notesState[data1] = false;
      event.type = "noteoff"; // necessary for note on with 0 velocity

      /**
       * Event emitted when a **note off** MIDI message has been received on the channel.
       *
       * @event InputChannel#noteoff
       *
       * @type {object}
       * @property {string} type `noteoff`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the incoming
       * MIDI message.
       * @property {number} timestamp The moment
       * ([`DOMHighResTimeStamp`](https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp))
       * when the event occurred (in milliseconds since the navigation start of the document).
       *
       * @property {object} note A [`Note`](Note) object containing information such as note name,
       * octave and release velocity.
       * @property {number} value The release velocity amount expressed as a float between 0 and 1.
       * @property {number} rawValue The release velocity amount expressed as an integer (between 0
       * and 127).
       */

      // The object created when a noteoff event arrives is a Note with an attack velocity of 0.
      event.note = new Note$1(
        Utilities.offsetNumber(
          data1, this.octaveOffset + this.input.octaveOffset + wm.octaveOffset
        ),
        {
          rawAttack: 0,
          rawRelease: data2,
        }
      );

      event.value = Utilities.from7bitToFloat(data2);
      event.rawValue = data2;

      // Those are kept for backwards-compatibility but are gone from the documentation. They will
      // be removed in future versions (@deprecated).
      event.velocity = event.note.release;
      event.rawVelocity = event.note.rawRelease;

    } else if (event.type === "noteon") {

      this.notesState[data1] = true;

      /**
       * Event emitted when a **note on** MIDI message has been received.
       *
       * @event InputChannel#noteon
       *
       * @type {object}
       * @property {string} type `noteon`
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} note A [`Note`](Note) object containing information such as note name,
       * octave and release velocity.
       * @property {number} value The attack velocity amount expressed as a float between 0 and 1.
       * @property {number} rawValue The attack velocity amount expressed as an integer (between 0
       * and 127).
       */
      event.note = new Note$1(
        Utilities.offsetNumber(
          data1, this.octaveOffset + this.input.octaveOffset + wm.octaveOffset
        ),
        { rawAttack: data2 }
      );

      event.value = Utilities.from7bitToFloat(data2);
      event.rawValue = data2;

      // Those are kept for backwards-compatibility but are gone from the documentation. They will
      // be removed in future versions (@deprecated).
      event.velocity = event.note.attack;
      event.rawVelocity = event.note.rawAttack;

    } else if (event.type === "keyaftertouch") {

      /**
       * Event emitted when a **key-specific aftertouch** MIDI message has been received.
       *
       * @event InputChannel#keyaftertouch
       *
       * @type {object}
       * @property {string} type `"keyaftertouch"`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} note A [`Note`](Note) object containing information such as note name
       * and number.
       * @property {number} value The aftertouch amount expressed as a float between 0 and 1.
       * @property {number} rawValue The aftertouch amount expressed as an integer (between 0 and
       * 127).
       */
      event.note = new Note$1(
        Utilities.offsetNumber(
          data1, this.octaveOffset + this.input.octaveOffset + wm.octaveOffset
        )
      );

      // Aftertouch value
      event.value = Utilities.from7bitToFloat(data2);
      event.rawValue = data2;

      // @deprecated
      event.identifier = event.note.identifier;
      event.key = event.note.number;
      event.rawKey = data1;

    } else if (event.type === "controlchange") {

      /**
       * Event emitted when a **control change** MIDI message has been received.
       *
       * @event InputChannel#controlchange
       *
       * @type {object}
       * @property {string} type `controlchange`
       * @property {string} subtype The type of control change message that was received.
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */
      event.controller = {
        number: data1,
        name: Enumerations.CONTROL_CHANGE_MESSAGES[data1].name,
        description: Enumerations.CONTROL_CHANGE_MESSAGES[data1].description,
        position: Enumerations.CONTROL_CHANGE_MESSAGES[data1].position,
      };

      event.subtype = event.controller.name || "controller" + data1;
      event.value = Utilities.from7bitToFloat(data2);
      event.rawValue = data2;

      /**
       * Event emitted when a **control change** MIDI message has been received and that message is
       * targeting the controller numbered "xxx". Of course, "xxx" should be replaced by a valid
       * controller number (0-127).
       *
       * @event InputChannel#controlchange-controllerxxx
       *
       * @type {object}
       * @property {string} type `controlchange-controllerxxx`
       * @property {string} subtype The type of control change message that was received.
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */
      const numberedEvent = Object.assign({}, event);
      numberedEvent.type = `${event.type}-controller${data1}`;
      delete numberedEvent.subtype;
      this.emit(numberedEvent.type, numberedEvent);

      /**
       * Event emitted when a **controlchange-bankselectcoarse** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-bankselectcoarse
       *
       * @type {object}
       * @property {string} type `controlchange-bankselectcoarse`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-modulationwheelcoarse** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-modulationwheelcoarse
       *
       * @type {object}
       * @property {string} type `controlchange-modulationwheelcoarse`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-breathcontrollercoarse** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-breathcontrollercoarse
       *
       * @type {object}
       * @property {string} type `controlchange-breathcontrollercoarse`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-footcontrollercoarse** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-footcontrollercoarse
       *
       * @type {object}
       * @property {string} type `controlchange-footcontrollercoarse`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-portamentotimecoarse** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-portamentotimecoarse
       *
       * @type {object}
       * @property {string} type `controlchange-portamentotimecoarse`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-dataentrycoarse** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-dataentrycoarse
       *
       * @type {object}
       * @property {string} type `controlchange-dataentrycoarse`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-volumecoarse** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-volumecoarse
       *
       * @type {object}
       * @property {string} type `controlchange-volumecoarse`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-balancecoarse** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-balancecoarse
       *
       * @type {object}
       * @property {string} type `controlchange-balancecoarse`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-pancoarse** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-pancoarse
       *
       * @type {object}
       * @property {string} type `controlchange-pancoarse`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-expressioncoarse** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-expressioncoarse
       *
       * @type {object}
       * @property {string} type `controlchange-expressioncoarse`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-effectcontrol1coarse** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-effectcontrol1coarse
       *
       * @type {object}
       * @property {string} type `controlchange-effectcontrol1coarse`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-effectcontrol2coarse** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-effectcontrol2coarse
       *
       * @type {object}
       * @property {string} type `controlchange-effectcontrol2coarse`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-generalpurposecontroller1** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-generalpurposecontroller1
       *
       * @type {object}
       * @property {string} type `controlchange-generalpurposecontroller1`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-generalpurposecontroller2** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-generalpurposecontroller2
       *
       * @type {object}
       * @property {string} type `controlchange-generalpurposecontroller2`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-generalpurposecontroller3** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-generalpurposecontroller3
       *
       * @type {object}
       * @property {string} type `controlchange-generalpurposecontroller3`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-generalpurposecontroller4** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-generalpurposecontroller4
       *
       * @type {object}
       * @property {string} type `controlchange-generalpurposecontroller4`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-bankselectfine** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-bankselectfine
       *
       * @type {object}
       * @property {string} type `controlchange-bankselectfine`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-modulationwheelfine** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-modulationwheelfine
       *
       * @type {object}
       * @property {string} type `controlchange-modulationwheelfine`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-breathcontrollerfine** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-breathcontrollerfine
       *
       * @type {object}
       * @property {string} type `controlchange-breathcontrollerfine`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-footcontrollerfine** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-footcontrollerfine
       *
       * @type {object}
       * @property {string} type `controlchange-footcontrollerfine`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-portamentotimefine** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-portamentotimefine
       *
       * @type {object}
       * @property {string} type `controlchange-portamentotimefine`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-dataentryfine** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-dataentryfine
       *
       * @type {object}
       * @property {string} type `controlchange-dataentryfine`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-channelvolumefine** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-channelvolumefine
       *
       * @type {object}
       * @property {string} type `controlchange-channelvolumefine`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-balancefine** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-balancefine
       *
       * @type {object}
       * @property {string} type `controlchange-balancefine`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-panfine** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-panfine
       *
       * @type {object}
       * @property {string} type `controlchange-panfine`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-expressionfine** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-expressionfine
       *
       * @type {object}
       * @property {string} type `controlchange-expressionfine`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-effectcontrol1fine** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-effectcontrol1fine
       *
       * @type {object}
       * @property {string} type `controlchange-effectcontrol1fine`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-effectcontrol2fine** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-effectcontrol2fine
       *
       * @type {object}
       * @property {string} type `controlchange-effectcontrol2fine`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-damperpedal** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-damperpedal
       *
       * @type {object}
       * @property {string} type `controlchange-damperpedal`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-portamento** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-portamento
       *
       * @type {object}
       * @property {string} type `controlchange-portamento`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-sostenuto** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-sostenuto
       *
       * @type {object}
       * @property {string} type `controlchange-sostenuto`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-softpedal** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-softpedal
       *
       * @type {object}
       * @property {string} type `controlchange-softpedal`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-legatopedal** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-legatopedal
       *
       * @type {object}
       * @property {string} type `controlchange-legatopedal`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-hold2** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-hold2
       *
       * @type {object}
       * @property {string} type `controlchange-hold2`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-soundvariation** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-soundvariation
       *
       * @type {object}
       * @property {string} type `controlchange-soundvariation`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-resonance** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-resonance
       *
       * @type {object}
       * @property {string} type `controlchange-resonance`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-releasetime** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-releasetime
       *
       * @type {object}
       * @property {string} type `controlchange-releasetime`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-attacktime** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-attacktime
       *
       * @type {object}
       * @property {string} type `controlchange-attacktime`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-brightness** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-brightness
       *
       * @type {object}
       * @property {string} type `controlchange-brightness`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-decaytime** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-decaytime
       *
       * @type {object}
       * @property {string} type `controlchange-decaytime`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-vibratorate** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-vibratorate
       *
       * @type {object}
       * @property {string} type `controlchange-vibratorate`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-vibratodepth** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-vibratodepth
       *
       * @type {object}
       * @property {string} type `controlchange-vibratodepth`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-vibratodelay** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-vibratodelay
       *
       * @type {object}
       * @property {string} type `controlchange-vibratodelay`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-generalpurposecontroller5** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-generalpurposecontroller5
       *
       * @type {object}
       * @property {string} type `controlchange-generalpurposecontroller5`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-generalpurposecontroller6** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-generalpurposecontroller6
       *
       * @type {object}
       * @property {string} type `controlchange-generalpurposecontroller6`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-generalpurposecontroller7** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-generalpurposecontroller7
       *
       * @type {object}
       * @property {string} type `controlchange-generalpurposecontroller7`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-generalpurposecontroller8** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-generalpurposecontroller8
       *
       * @type {object}
       * @property {string} type `controlchange-generalpurposecontroller8`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-portamentocontrol** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-portamentocontrol
       *
       * @type {object}
       * @property {string} type `controlchange-portamentocontrol`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-highresolutionvelocityprefix** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-highresolutionvelocityprefix
       *
       * @type {object}
       * @property {string} type `controlchange-highresolutionvelocityprefix`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-effect1depth** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-effect1depth
       *
       * @type {object}
       * @property {string} type `controlchange-effect1depth`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-effect2depth** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-effect2depth
       *
       * @type {object}
       * @property {string} type `controlchange-effect2depth`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-effect3depth** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-effect3depth
       *
       * @type {object}
       * @property {string} type `controlchange-effect3depth`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-effect4depth** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-effect4depth
       *
       * @type {object}
       * @property {string} type `controlchange-effect4depth`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-effect5depth** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-effect5depth
       *
       * @type {object}
       * @property {string} type `controlchange-effect5depth`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-dataincrement** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-dataincrement
       *
       * @type {object}
       * @property {string} type `controlchange-dataincrement`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-datadecrement** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-datadecrement
       *
       * @type {object}
       * @property {string} type `controlchange-datadecrement`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-nonregisteredparameterfine** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-nonregisteredparameterfine
       *
       * @type {object}
       * @property {string} type `controlchange-nonregisteredparameterfine`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-nonregisteredparametercoarse** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-nonregisteredparametercoarse
       *
       * @type {object}
       * @property {string} type `controlchange-nonregisteredparametercoarse`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-registeredparameterfine** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-registeredparameterfine
       *
       * @type {object}
       * @property {string} type `controlchange-registeredparameterfine`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-registeredparametercoarse** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-registeredparametercoarse
       *
       * @type {object}
       * @property {string} type `controlchange-registeredparametercoarse`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-allsoundoff** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-allsoundoff
       *
       * @type {object}
       * @property {string} type `controlchange-allsoundoff`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-resetallcontrollers** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-resetallcontrollers
       *
       * @type {object}
       * @property {string} type `controlchange-resetallcontrollers`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-localcontrol** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-localcontrol
       *
       * @type {object}
       * @property {string} type `controlchange-localcontrol`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-allnotesoff** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-allnotesoff
       *
       * @type {object}
       * @property {string} type `controlchange-allnotesoff`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-omnimodeoff** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-omnimodeoff
       *
       * @type {object}
       * @property {string} type `controlchange-omnimodeoff`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-omnimodeon** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-omnimodeon
       *
       * @type {object}
       * @property {string} type `controlchange-omnimodeon`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-monomodeon** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-monomodeon
       *
       * @type {object}
       * @property {string} type `controlchange-monomodeon`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      /**
       * Event emitted when a **controlchange-polymodeon** MIDI message has been
       * received.
       *
       * @event InputChannel#controlchange-polymodeon
       *
       * @type {object}
       * @property {string} type `controlchange-polymodeon`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {object} controller
       * @property {object} controller.number The number of the controller.
       * @property {object} controller.name The usual name or function of the controller.
       * @property {object} controller.description A user-friendly representation of the
       * controller's default function
       * @property {string} controller.position Whether the controller is meant to be an `msb` or `lsb`
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The value expressed as an integer (between 0 and 127).
       */

      const namedEvent = Object.assign({}, event);
      namedEvent.type = `${event.type}-` + Enumerations.CONTROL_CHANGE_MESSAGES[data1].name;
      delete namedEvent.subtype;

      // Dispatch controlchange-"function" events only if the "function" is defined (not the generic
      // controllerXXX nomenclature)
      if (namedEvent.type.indexOf("controller") !== 0) {
        this.emit(namedEvent.type, namedEvent);
      }

      // Trigger channel mode message events (if appropriate)
      if (event.message.dataBytes[0] >= 120) this._parseChannelModeMessage(event);

      // Parse the inbound event to see if its part of an RPN/NRPN sequence
      if (
        this.parameterNumberEventsEnabled &&
        this._isRpnOrNrpnController(event.message.dataBytes[0])
      ) {
        this._parseEventForParameterNumber(event);
      }

    } else if (event.type === "programchange") {

      /**
       * Event emitted when a **program change** MIDI message has been received.
       *
       * @event InputChannel#programchange
       *
       * @type {object}
       * @property {string} type `programchange`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {number} value The value expressed as an integer between 0 and 127.
       * @property {number} rawValue  The raw MIDI value expressed as an integer between 0 and 127.
       */
      event.value = data1;
      event.rawValue = event.value;

    } else if (event.type === "channelaftertouch") {

      /**
       * Event emitted when a control change MIDI message has been received.
       *
       * @event InputChannel#channelaftertouch
       *
       * @type {object}
       * @property {string} type `channelaftertouch`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The raw MIDI value expressed as an integer between 0 and 127.
       */
      event.value = Utilities.from7bitToFloat(data1);
      event.rawValue = data1;

    } else if (event.type === "pitchbend") {

      /**
       * Event emitted when a pitch bend MIDI message has been received.
       *
       * @event InputChannel#pitchbend
       *
       * @type {object}
       * @property {string} type `pitchbend`
       *
       * @property {InputChannel} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       * @property {Message} message A [`Message`](Message) object containing information about the
       * incoming MIDI message.
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       *
       * @property {number} value The value expressed as a float between 0 and 1.
       * @property {number} rawValue The raw MIDI value expressed as an integer (between 0 and
       * 16383).
       */
      event.value = ((data2 << 7) + data1 - 8192) / 8192;
      event.rawValue = (data2 << 7) + data1;

    } else {
      event.type = "unknownmessage";
    }

    this.emit(event.type, event);

  }

  /**
   * @param e {Object}
   * @private
   */
  _parseChannelModeMessage(e) {

    // Make a shallow copy of the incoming event so we can use it as the new event.
    const event = Object.assign({}, e);
    event.type = event.controller.name;

    /**
     * Event emitted when an "all sound off" channel-mode MIDI message has been received.
     *
     * @event InputChannel#allsoundoff
     *
     * @type {object}
     * @property {string} type `allsoundoff`
     *
     * @property {InputChannel} target The object that dispatched the event.
     * @property {Input} port The `Input` that triggered the event.
     * @property {Message} message A [`Message`](Message) object containing information about the
     * incoming MIDI message.
     * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
     * milliseconds since the navigation start of the document).
     */

    /**
     * Event emitted when a "reset all controllers" channel-mode MIDI message has been received.
     *
     * @event InputChannel#resetallcontrollers
     *
     * @type {object}
     *
     * @property {InputChannel} target The object that dispatched the event.
     * @property {Input} port The `Input` that triggered the event.
     * @property {Message} message A [`Message`](Message) object containing information about the
     * incoming MIDI message.
     * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
     * milliseconds since the navigation start of the document).
     */

    /**
     * Event emitted when a "local control" channel-mode MIDI message has been received. The value
     * property of the event is set to either `true` (local control on) of `false` (local control
     * off).
     *
     * @event InputChannel#localcontrol
     *
     * @type {object}
     * @property {string} type `localcontrol`
     *
     * @property {InputChannel} target The object that dispatched the event.
     * @property {Input} port The `Input` that triggered the event.
     * @property {Message} message A [`Message`](Message) object containing information about the
     * incoming MIDI message.
     * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
     * milliseconds since the navigation start of the document).
     *
     * @property {boolean} value For local control on, the value is `true`. For local control off,
     * the value is `false`.
     * @property {boolean} rawValue For local control on, the value is `127`. For local control off,
     * the value is `0`.
     */
    if (event.type === "localcontrol") {
      event.value = event.message.data[2] === 127 ? true : false;
      event.rawValue = event.message.data[2];
    }

    /**
     * Event emitted when an "all notes off" channel-mode MIDI message has been received.
     *
     * @event InputChannel#allnotesoff
     *
     * @type {object}
     * @property {string} type `allnotesoff`
     *
     * @property {InputChannel} target The object that dispatched the event.
     * @property {Input} port The `Input` that triggered the event.
     * @property {Message} message A [`Message`](Message) object containing information about the
     * incoming MIDI message.
     * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
     * milliseconds since the navigation start of the document).
     */

    /**
     * Event emitted when an "omni mode" channel-mode MIDI message has been received. The value
     * property of the event is set to either `true` (omni mode on) of `false` (omni mode off).
     *
     * @event InputChannel#omnimode
     *
     * @type {object}
     * @property {string} type `"omnimode"`
     *
     * @property {InputChannel} target The object that dispatched the event.
     * @property {Input} port The `Input` that triggered the event.
     * @property {Message} message A [`Message`](Message) object containing information about the
     * incoming MIDI message.
     * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
     * milliseconds since the navigation start of the document).
     *
     * @property {boolean} value The value is `true` for omni mode on and false for omni mode off.
     * @property {boolean} rawValue The raw MIDI value
     */
    if (event.type === "omnimodeon") {
      event.type = "omnimode";
      event.value = true;
      event.rawValue = event.message.data[2];
    } else if (event.type === "omnimodeoff") {
      event.type = "omnimode";
      event.value = false;
      event.rawValue = event.message.data[2];
    }


    /**
     * Event emitted when a "mono/poly mode" MIDI message has been received. The value property of
     * the event is set to either `true` (mono mode on / poly mode off) or `false` (mono mode off /
     * poly mode on).
     *
     * @event InputChannel#monomode
     *
     * @type {object}
     * @property {string} type `monomode`
     *
     * @property {InputChannel} target The object that dispatched the event.
     * @property {Input} port The `Input` that triggered the event.
     * @property {Message} message A [`Message`](Message) object containing information about the
     * incoming MIDI message.
     * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
     * milliseconds since the navigation start of the document).
     *
     * @property {boolean} value The value is `true` for omni mode on and false for omni mode off.
     * @property {boolean} rawValue The raw MIDI value
     */
    if (event.type === "monomodeon") {
      event.type = "monomode";
      event.value = true;
      event.rawValue = event.message.data[2];
    } else if (event.type === "polymodeon") {
      event.type = "monomode";
      event.value = false;
      event.rawValue = event.message.data[2];
    }

    this.emit(event.type, event);

  }

  /**
   * Parses inbound events to identify RPN/NRPN sequences.
   * @param e Event
   * @private
   */
  _parseEventForParameterNumber(event) {

    // To make it more legible
    const controller = event.message.dataBytes[0];
    const value = event.message.dataBytes[1];

    // A. Check if the message is the start of an RPN (101) or NRPN (99) parameter declaration.
    if (controller === 99 || controller === 101) {

      this._nrpnBuffer = [];
      this._rpnBuffer = [];

      if (controller === 99) {                          // 99
        this._nrpnBuffer = [event.message];
      } else {                                          // 101
        // 127 is a reset so we ignore it
        if (value !== 127) this._rpnBuffer = [event.message];
      }

    // B. Check if the message is the end of an RPN (100) or NRPN (98) parameter declaration.
    } else if (controller === 98 || controller === 100) {

      if (controller === 98) {                          // 98

        // Flush the other buffer (they are mutually exclusive)
        this._rpnBuffer = [];

        // Check if we are in sequence
        if (this._nrpnBuffer.length === 1) {
          this._nrpnBuffer.push(event.message);
        } else {
          this._nrpnBuffer = []; // out of sequence
        }

      } else {                                          // 100

        // Flush the other buffer (they are mutually exclusive)
        this._nrpnBuffer = [];

        // 127 is a reset so we ignore it
        if (this._rpnBuffer.length === 1 && value !== 127) {
          this._rpnBuffer.push(event.message);
        } else {
          this._rpnBuffer = []; // out of sequence or reset
        }

      }

    // C. Check if the message is for data entry (6, 38, 96 or 97). Those messages trigger events.
    } else if (
      controller === 6 ||
      controller === 38 ||
      controller === 96 ||
      controller === 97
    ) {

      if (this._rpnBuffer.length === 2) {
        this._dispatchParameterNumberEvent(
          "rpn",
          this._rpnBuffer[0].dataBytes[1],
          this._rpnBuffer[1].dataBytes[1],
          event
        );
      } else if (this._nrpnBuffer.length === 2) {
        this._dispatchParameterNumberEvent(
          "nrpn",
          this._nrpnBuffer[0].dataBytes[1],
          this._nrpnBuffer[1].dataBytes[1],
          event
        );
      } else {
        this._nrpnBuffer = [];
        this._rpnBuffer = [];
      }

    }

  }

  /**
   * Indicates whether the specified controller can be part of an RPN or NRPN sequence
   * @param controller
   * @returns {boolean}
   * @private
   */
  _isRpnOrNrpnController(controller) {

    return controller === 6 ||
      controller === 38 ||
      controller === 96 ||
      controller === 97 ||
      controller === 98 ||
      controller === 99 ||
      controller === 100 ||
      controller === 101;

  }

  /**
   * @private
   */
  _dispatchParameterNumberEvent(type, paramMsb, paramLsb, e) {

    type = type === "nrpn" ? "nrpn" : "rpn";

    /**
     * Event emitted when an **RPN data entry coarse** message is received on the input. The
     * specific parameter to which the message applies can be found in the event's `parameter`
     * property. It is one of the ones defined in
     * [`Enumerations.REGISTERED_PARAMETERS`](Enumerations#REGISTERED_PARAMETERS).
     *
     * @event InputChannel#rpn-dataentrycoarse
     *
     * @type {object}
     *
     * @property {string} type `rpn-dataentrycoarse`
     * @property {InputChannel} target The object that dispatched the event.
     * @property {Input} port The `Input` that triggered the event.
     * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
     * milliseconds since the navigation start of the document).
     * @property {Message} message A [`Message`](Message) object containing information about the
     * incoming MIDI message.
     * @property {string} parameter The registered parameter's name
     * @property {number} parameterMsb The MSB portion of the registered parameter (0-127)
     * @property {number} parameterLsb: The LSB portion of the registered parameter (0-127)
     * @property {number} value The received value as a normalized number between 0 and 1.
     * @property {number} rawValue The value as received (0-127)
     */

    /**
     * Event emitted when an **RPN data entry fine** message is received on the input. The
     * specific parameter to which the message applies can be found in the event's `parameter`
     * property. It is one of the ones defined in
     * [`EnumerationsREGISTERED_PARAMETERS`](Enumerations#REGISTERED_PARAMETERS).
     *
     * @event InputChannel#rpn-dataentryfine
     *
     * @type {object}
     *
     * @property {string} type `rpn-dataentryfine`
     * @property {InputChannel} target The object that dispatched the event.
     * @property {Input} port The `Input` that triggered the event.
     * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
     * milliseconds since the navigation start of the document).
     * @property {Message} message A [`Message`](Message) object containing information about the
     * incoming MIDI message.
     * @property {string} parameter The registered parameter's name
     * @property {number} parameterMsb The MSB portion of the registered parameter (0-127)
     * @property {number} parameterLsb: The LSB portion of the registered parameter (0-127)
     * @property {number} value The received value as a normalized number between 0 and 1.
     * @property {number} rawValue The value as received (0-127)
     */

    /**
     * Event emitted when an **RPN data increment** message is received on the input. The specific
     * parameter to which the message applies can be found in the event's `parameter` property. It
     * is one of the ones defined in
     * [`Enumerations.REGISTERED_PARAMETERS`](Enumerations#REGISTERED_PARAMETERS).
     *
     * @event InputChannel#rpn-dataincrement
     *
     * @type {object}
     *
     * @property {string} type `rpn-dataincrement`
     * @property {InputChannel} target The object that dispatched the event.
     * @property {Input} port The `Input` that triggered the event.
     * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
     * milliseconds since the navigation start of the document).
     * @property {Message} message A [`Message`](Message) object containing information about the
     * incoming MIDI message.
     * @property {string} parameter The registered parameter's name
     * @property {number} parameterMsb The MSB portion of the registered parameter (0-127)
     * @property {number} parameterLsb: The LSB portion of the registered parameter (0-127)
     * @property {number} value The received value as a normalized number between 0 and 1.
     * @property {number} rawValue The value as received (0-127)
     */

    /**
     * Event emitted when an **RPN data decrement** message is received on the input. The specific
     * parameter to which the message applies can be found in the event's `parameter` property. It
     * is one of the ones defined in
     * [`Enumerations.REGISTERED_PARAMETERS`](Enumerations#REGISTERED_PARAMETERS).
     *
     * @event InputChannel#rpn-datadecrement
     *
     * @type {object}
     *
     * @property {string} type `rpn-datadecrement`
     * @property {InputChannel} target The object that dispatched the event.
     * @property {Input} port The `Input` that triggered the event.
     * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
     * milliseconds since the navigation start of the document).
     * @property {Message} message A [`Message`](Message) object containing information about the
     * incoming MIDI message.
     * @property {string} parameter The registered parameter's name
     * @property {number} parameterMsb The MSB portion of the registered parameter (0-127)
     * @property {number} parameterLsb: The LSB portion of the registered parameter (0-127)
     * @property {number} value The received value as a normalized number between 0 and 1.
     * @property {number} rawValue The value as received (0-127)
     */

    /**
     * Event emitted when an **NRPN data entry coarse** message is received on the input. The
     * specific parameter to which the message applies can be found in the event's `parameter`
     * property. It is one of the ones defined in
     * [`Enumerations.REGISTERED_PARAMETERS`](Enumerations#REGISTERED_PARAMETERS).
     *
     * @event InputChannel#nrpn-dataentrycoarse
     *
     * @type {object}
     *
     * @property {string} type `nrpn-dataentrycoarse`
     * @property {InputChannel} target The object that dispatched the event.
     * @property {Input} port The `Input` that triggered the event.
     * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
     * milliseconds since the navigation start of the document).
     * @property {Message} message A [`Message`](Message) object containing information about the
     * incoming MIDI message.
     * @property {string} parameter The registered parameter's name
     * @property {number} parameterMsb The MSB portion of the registered parameter (0-127)
     * @property {number} parameterLsb: The LSB portion of the registered parameter (0-127)
     * @property {number} value The received value as a normalized number between 0 and 1.
     * @property {number} rawValue The value as received (0-127)
     */

    /**
     * Event emitted when an **NRPN data entry fine** message is received on the input. The
     * specific parameter to which the message applies can be found in the event's `parameter`
     * property. It is one of the ones defined in
     * [`Enumerations.REGISTERED_PARAMETERS`](Enumerations#REGISTERED_PARAMETERS).
     *
     * @event InputChannel#nrpn-dataentryfine
     *
     * @type {object}
     *
     * @property {string} type `nrpn-dataentryfine`
     * @property {InputChannel} target The object that dispatched the event.
     * @property {Input} port The `Input` that triggered the event.
     * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
     * milliseconds since the navigation start of the document).
     * @property {Message} message A [`Message`](Message) object containing information about the
     * incoming MIDI message.
     * @property {string} parameter The registered parameter's name
     * @property {number} parameterMsb The MSB portion of the registered parameter (0-127)
     * @property {number} parameterLsb: The LSB portion of the registered parameter (0-127)
     * @property {number} value The received value as a normalized number between 0 and 1.
     * @property {number} rawValue The value as received (0-127)
     */

    /**
     * Event emitted when an **NRPN data increment** message is received on the input. The specific
     * parameter to which the message applies can be found in the event's `parameter` property. It
     * is one of the ones defined in
     * [`Enumerations.REGISTERED_PARAMETERS`](Enumerations#REGISTERED_PARAMETERS).
     *
     * @event InputChannel#nrpn-dataincrement
     *
     * @type {object}
     *
     * @property {string} type `nrpn-dataincrement`
     * @property {InputChannel} target The object that dispatched the event.
     * @property {Input} port The `Input` that triggered the event.
     * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
     * milliseconds since the navigation start of the document).
     * @property {Message} message A [`Message`](Message) object containing information about the
     * incoming MIDI message.
     * @property {string} parameter The registered parameter's name
     * @property {number} parameterMsb The MSB portion of the registered parameter (0-127)
     * @property {number} parameterLsb: The LSB portion of the registered parameter (0-127)
     * @property {number} value The received value as a normalized number between 0 and 1.
     * @property {number} rawValue The value as received (0-127)
     */

    /**
     * Event emitted when an **NRPN data decrement** message is received on the input. The specific
     * parameter to which the message applies can be found in the event's `parameter` property. It
     * is one of the ones defined in
     * [`Enumerations.REGISTERED_PARAMETERS`](Enumerations#REGISTERED_PARAMETERS).
     *
     * @event InputChannel#nrpn-datadecrement
     *
     * @type {object}
     *
     * @property {string} type `nrpn-datadecrement`
     * @property {InputChannel} target The object that dispatched the event.
     * @property {Input} port The `Input` that triggered the event.
     * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
     * milliseconds since the navigation start of the document).
     * @property {Message} message A [`Message`](Message) object containing information about the
     * incoming MIDI message.
     * @property {string} parameter The registered parameter's name
     * @property {number} parameterMsb The MSB portion of the registered parameter (0-127)
     * @property {number} parameterLsb: The LSB portion of the registered parameter (0-127)
     * @property {number} value The received value as a normalized number between 0 and 1.
     * @property {number} rawValue The value as received (0-127)
     */

    const event = {
      target: e.target,
      timestamp: e.timestamp,
      message: e.message,
      parameterMsb: paramMsb,
      parameterLsb: paramLsb,
      value: Utilities.from7bitToFloat(e.message.dataBytes[1]),
      rawValue: e.message.dataBytes[1],
    };

    // Identify the parameter (by name for RPN and by number for NRPN)
    if (type === "rpn") {

      event.parameter = Object.keys(Enumerations.REGISTERED_PARAMETERS).find(key => {
        return Enumerations.REGISTERED_PARAMETERS[key][0] === paramMsb &&
          Enumerations.REGISTERED_PARAMETERS[key][1] === paramLsb;
      });

    } else {
      event.parameter = (paramMsb << 7) + paramLsb;
    }

    // Type and subtype
    const subtype = Enumerations.CONTROL_CHANGE_MESSAGES[e.message.dataBytes[0]].name;

    // Emit specific event
    event.type = `${type}-${subtype}`;
    this.emit(event.type, event);

    // Begin Legacy Block (remove in v4)
    const legacyEvent = Object.assign({}, event);
    if (legacyEvent.type === "nrpn-dataincrement") {
      legacyEvent.type = "nrpn-databuttonincrement";
    } else if (legacyEvent.type === "nrpn-datadecrement") {
      legacyEvent.type = "nrpn-databuttondecrement";
    } else if (legacyEvent.type === "rpn-dataincrement") {
      legacyEvent.type = "rpn-databuttonincrement";
    } else if (legacyEvent.type === "rpn-datadecrement") {
      legacyEvent.type = "rpn-databuttondecrement";
    }
    this.emit(legacyEvent.type, legacyEvent);
    // End Legacy Block

    /**
     * Event emitted when any NRPN message is received on the input. There are four subtypes of NRPN
     * messages:
     *
     *   * `nrpn-dataentrycoarse`
     *   * `nrpn-dataentryfine`
     *   * `nrpn-dataincrement`
     *   * `nrpn-datadecrement`
     *
     * The parameter to which the message applies can be found in the event's `parameter` property.
     *
     * @event InputChannel#nrpn
     *
     * @type {object}
     *
     * @property {string} type `nrpn`
     * @property {string} subtype The precise type of NRPN message that was received.
     * @property {InputChannel} target The object that dispatched the event.
     * @property {Input} port The `Input` that triggered the event.
     * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
     * milliseconds since the navigation start of the document).
     * @property {Message} message A [`Message`](Message) object containing information about the
     * incoming MIDI message.
     * @property {number} parameter The non-registered parameter number (0-16383)
     * @property {number} parameterMsb The MSB portion of the non-registered parameter number
     * (0-127)
     * @property {number} parameterLsb: The LSB portion of the non-registered parameter number
     * (0-127)
     * @property {number} value The received value as a normalized number between 0 and 1.
     * @property {number} rawValue The value as received (0-127)
     */

    /**
     * Event emitted when any RPN message is received on the input. There are four subtypes of RPN
     * messages:
     *
     *   * `rpn-dataentrycoarse`
     *   * `rpn-dataentryfine`
     *   * `rpn-dataincrement`
     *   * `rpn-datadecrement`
     *
     * The parameter to which the message applies can be found in the event's `parameter` property.
     * It is one of the ones defined in
     * [`Enumerations.REGISTERED_PARAMETERS`](Enumerations#REGISTERED_PARAMETERS).
     *
     * @event InputChannel#rpn
     *
     * @type {object}
     *
     * @property {string} type `rpn`
     * @property {string} subtype The precise type of RPN message that was received.
     * @property {InputChannel} target The object that dispatched the event.
     * @property {Input} port The `Input` that triggered the event.
     * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
     * milliseconds since the navigation start of the document).
     * @property {Message} message A [`Message`](Message) object containing information about the
     * incoming MIDI message.
     * @property {string} parameter The registered parameter's name
     * @property {number} parameterMsb The MSB portion of the registered parameter (0-127)
     * @property {number} parameterLsb: The LSB portion of the registered parameter (0-127)
     * @property {number} value The received value as a normalized number between 0 and 1.
     * @property {number} rawValue The value as received (0-127)
     */

    // Emit general event
    event.type = type;
    event.subtype = subtype;
    this.emit(event.type, event);

  }

  /**
   * @deprecated since version 3.
   * @private
   */
  getChannelModeByNumber(number) {

    if (wm.validation) {
      console.warn(
        "The 'getChannelModeByNumber()' method has been moved to the 'Utilities' class."
      );
      number = Math.floor(number);
    }

    return Utilities.getChannelModeByNumber(number);

  }

  /**
   * @deprecated since version 3.
   * @private
   */
  getCcNameByNumber(number) {

    if (wm.validation) {
      console.warn(
        "The 'getCcNameByNumber()' method has been moved to the 'Utilities' class."
      );
      number = parseInt(number);
      if ( !(number >= 0 && number <= 127) ) throw new RangeError("Invalid control change number.");
    }

    return Utilities.getCcNameByNumber(number);

  }

  /**
   * Returns the playing status of the specified note (`true` if the note is currently playing,
   * `false` if it is not). The `note` parameter can be an unsigned integer (0-127), a note
   * identifier (`"C4"`, `"G#5"`, etc.) or a [`Note`]{@link Note} object.
   *
   * IF the note is specified using an integer (0-127), no octave offset will be applied.
   *
   * @param {number|string|Note} note The note to get the state for. The
   * [`octaveOffset`](#octaveOffset) (channel, input and global) will be factored in for note
   * identifiers and [`Note`]{@link Note} objects.
   * @returns {boolean}
   * @since version 3.0.0
   */
  getNoteState(note) {

    // If it's a note object, we simply use the identifier
    if (note instanceof Note$1) note = note.identifier;

    const number = Utilities.guessNoteNumber(
      note,
      wm.octaveOffset + this.input.octaveOffset + this.octaveOffset
    );

    return this.notesState[number];

  }

  /**
   * An integer to offset the reported octave of incoming note-specific messages (`noteon`,
   * `noteoff` and `keyaftertouch`). By default, middle C (MIDI note number 60) is placed on the 4th
   * octave (C4).
   *
   * If, for example, `octaveOffset` is set to 2, MIDI note number 60 will be reported as C6. If
   * `octaveOffset` is set to -1, MIDI note number 60 will be reported as C3.
   *
   * Note that this value is combined with the global offset value defined by
   * [`WebMidi.octaveOffset`](WebMidi#octaveOffset) object and with the value defined on the parent
   * input object with [`Input.octaveOffset`](Input#octaveOffset).
   *
   * @type {number}
   *
   * @since 3.0
   */
  get octaveOffset() {
    return this._octaveOffset;
  }
  set octaveOffset(value) {

    if (this.validation) {
      value = parseInt(value);
      if (isNaN(value)) throw new TypeError("The 'octaveOffset' property must be an integer.");
    }

    this._octaveOffset = value;

  }

  /**
   * The [`Input`](Input) this channel belongs to.
   * @type {Input}
   * @since 3.0
   */
  get input() {
    return this._input;
  }

  /**
   * This channel's MIDI number (1-16).
   * @type {number}
   * @since 3.0
   */
  get number() {
    return this._number;
  }

  /**
   * Whether RPN/NRPN events are parsed and dispatched.
   * @type {boolean}
   * @since 3.0
   * @deprecated Use parameterNumberEventsEnabled instead.
   * @private
   */
  get nrpnEventsEnabled() {
    return this.parameterNumberEventsEnabled;
  }
  set nrpnEventsEnabled(value) {

    if (this.validation) {
      value = !!value;
    }

    this.parameterNumberEventsEnabled = value;

  }

}

/**
 * The `Message` class represents a single MIDI message. It has several properties that make it
 * easy to make sense of the binary data it contains.
 *
 * @license Apache-2.0
 * @since 3.0.0
 */
class Message {

  /**
   * Creates a new `Message` object from raw MIDI data.
   *
   * @param {Uint8Array} data The raw data of the MIDI message as a
   * [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)
   * of integers between `0` and `255`.
   */
  constructor(data) {

    /**
     * A
     * [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)
     * containing the bytes of the MIDI message. Each byte is an integer between `0` and `255`.
     *
     * @type {Uint8Array}
     * @readonly
     */
    this.rawData = data;

    /**
     * An array containing all the bytes of the MIDI message. Each byte is an integer between `0`
     * and `255`.
     *
     * @type {number[]}
     * @readonly
     */
    this.data = Array.from(this.rawData);

    /**
     * The MIDI status byte of the message as an integer between `0` and `255`.
     *
     * @type {number}
     * @readonly
     */
    this.statusByte = this.rawData[0];

    /**
     * A
     * [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)
     * of the data byte(s) of the MIDI message. When the message is a system exclusive message
     * (sysex), `rawDataBytes` explicitly excludes the manufacturer ID and the sysex end byte so
     * only the actual data is included.
     *
     * @type {Uint8Array}
     * @readonly
     */
    this.rawDataBytes = this.rawData.slice(1);

    /**
     * An array of the the data byte(s) of the MIDI message (as opposed to the status byte). When
     * the message is a system exclusive message (sysex), `dataBytes` explicitly excludes the
     * manufacturer ID and the sysex end byte so only the actual data is included.
     *
     * @type {number[]}
     * @readonly
     */
    this.dataBytes = this.data.slice(1);

    /**
     * A boolean indicating whether the MIDI message is a channel-specific message.
     *
     * @type {boolean}
     * @readonly
     */
    this.isChannelMessage = false;

    /**
     * A boolean indicating whether the MIDI message is a system message (not specific to a
     * channel).
     *
     * @type {boolean}
     * @readonly
     */
    this.isSystemMessage = false;

    /**
     * An integer identifying the MIDI command. For channel-specific messages, the value is 4-bit
     * and will be between `8` and `14`. For system messages, the value will be between `240` and
     * `255`.
     *
     * @type {number}
     * @readonly
     */
    this.command = undefined;

    /**
     * The MIDI channel number (`1` - `16`) that the message is targeting. This is only for
     * channel-specific messages. For system messages, this will be left `undefined`.
     *
     * @type {number}
     * @readonly
     */
    this.channel = undefined;

    /**
     * When the message is a system exclusive message (sysex), this property contains an array with
     * either 1 or 3 entries that identify the manufacturer targeted by the message.
     *
     * To know how to translate these entries into manufacturer names, check out the official list:
     * https://www.midi.org/specifications-old/item/manufacturer-id-numbers
     *
     * @type {number[]}
     * @readonly
     */
    this.manufacturerId = undefined;

    /**
     * The type of message as a string (`"noteon"`, `"controlchange"`, `"sysex"`, etc.)
     *
     * @type {string}
     * @readonly
     */
    this.type = undefined;

    // Assign values to property that vary according to whether they are channel-specific or system
    if (this.statusByte < 240) {
      this.isChannelMessage = true;
      this.command = this.statusByte >> 4;
      this.channel = (this.statusByte & 0b00001111) + 1;
    } else {
      this.isSystemMessage = true;
      this.command = this.statusByte;
    }

    // Assign type (depending on whether the message is channel-specific or system)
    if (this.isChannelMessage) {
      this.type = Utilities.getPropertyByValue(Enumerations.CHANNEL_MESSAGES, this.command);
    } else if (this.isSystemMessage) {
      this.type = Utilities.getPropertyByValue(Enumerations.SYSTEM_MESSAGES, this.command);
    }

    // When the message is a sysex message, we add a manufacturer property and strip out the id from
    // dataBytes and rawDataBytes.
    if (this.statusByte === Enumerations.SYSTEM_MESSAGES.sysex) {

      if (this.dataBytes[0] === 0) {
        this.manufacturerId = this.dataBytes.slice(0, 3);
        this.dataBytes = this.dataBytes.slice(3, this.rawDataBytes.length - 1);
        this.rawDataBytes = this.rawDataBytes.slice(3, this.rawDataBytes.length - 1);
      } else {
        this.manufacturerId = [this.dataBytes[0]];
        this.dataBytes = this.dataBytes.slice(1, this.dataBytes.length - 1);
        this.rawDataBytes = this.rawDataBytes.slice(1, this.rawDataBytes.length - 1);
      }

    }

  }

}

/**
 * The `Input` class represents a single MIDI input port. This object is automatically instantiated
 * by the library according to the host's MIDI subsystem and does not need to be directly
 * instantiated. Instead, you can access all `Input` objects by referring to the
 * [`WebMidi.inputs`](WebMidi#inputs) array. You can also retrieve inputs by using methods such as
 * [`WebMidi.getInputByName()`](WebMidi#getInputByName) and
 * [`WebMidi.getInputById()`](WebMidi#getInputById).
 *
 * Note that a single MIDI device may expose several inputs and/or outputs.
 *
 * **Important**: the `Input` class does not directly fire channel-specific MIDI messages
 * (such as [`noteon`](InputChannel#event:noteon) or
 * [`controlchange`](InputChannel#event:controlchange), etc.). The [`InputChannel`](InputChannel)
 * object does that. However, you can still use the
 * [`Input.addListener()`](#addListener) method to listen to channel-specific events on multiple
 * [`InputChannel`](InputChannel) objects at once.
 *
 * @fires Input#opened
 * @fires Input#disconnected
 * @fires Input#closed
 * @fires Input#midimessage
 *
 * @fires Input#sysex
 * @fires Input#timecode
 * @fires Input#songposition
 * @fires Input#songselect
 * @fires Input#tunerequest
 * @fires Input#clock
 * @fires Input#start
 * @fires Input#continue
 * @fires Input#stop
 * @fires Input#activesensing
 * @fires Input#reset
 *
 * @fires Input#unknownmidimessage
 *
 * @extends EventEmitter
 * @license Apache-2.0
 */
class Input extends EventEmitter {

  /**
   * Creates an `Input` object.
   *
   * @param {MIDIInput} midiInput [`MIDIInput`](https://developer.mozilla.org/en-US/docs/Web/API/MIDIInput)
   * object as provided by the MIDI subsystem (Web MIDI API).
   */
  constructor(midiInput) {

    super();

    /**
     * Reference to the actual MIDIInput object
     * @private
     */
    this._midiInput = midiInput;

    /**
     * @type {number}
     * @private
     */
    this._octaveOffset = 0;

    /**
     * Array containing the 16 [`InputChannel`](InputChannel) objects available for this `Input`. The
     * channels are numbered 1 through 16.
     *
     * @type {InputChannel[]}
     */
    this.channels = [];
    for (let i = 1; i <= 16; i++) this.channels[i] = new InputChannel(this, i);

    /**
     * @type {Forwarder[]}
     * @private
     */
    this._forwarders = [];

    // Setup listeners
    this._midiInput.onstatechange = this._onStateChange.bind(this);
    this._midiInput.onmidimessage = this._onMidiMessage.bind(this);

  }

  /**
   * Destroys the `Input` by removing all listeners, emptying the [`channels`](#channels) array and
   * unlinking the MIDI subsystem. This is mostly for internal use.
   *
   * @returns {Promise<void>}
   */
  async destroy() {
    this.removeListener();
    this.channels.forEach(ch => ch.destroy());
    this.channels = [];
    this._forwarders = [];
    if (this._midiInput) {
      this._midiInput.onstatechange = null;
      this._midiInput.onmidimessage = null;
    }
    await this.close();
    this._midiInput = null;
  }

  /**
   * Executed when a `"statechange"` event occurs.
   *
   * @param e
   * @private
   */
  _onStateChange(e) {

    let event = {
      timestamp: wm.time,
      target: this,
      port: this // for consistency
    };

    if (e.port.connection === "open") {

      /**
       * Event emitted when the `Input` has been opened by calling the [`open()`]{@link #open}
       * method.
       *
       * @event Input#opened
       * @type {object}
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       * @property {string} type `opened`
       * @property {Input} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       */
      event.type = "opened";
      this.emit("opened", event);

    } else if (e.port.connection === "closed" && e.port.state === "connected") {

      /**
       * Event emitted when the `Input` has been closed by calling the
       * [`close()`]{@link #close} method.
       *
       * @event Input#closed
       * @type {object}
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       * @property {string} type `closed`
       * @property {Input} target The object that dispatched the event.
       * @property {Input} port The `Input` that triggered the event.
       */
      event.type = "closed";
      this.emit("closed", event);

    } else if (e.port.connection === "closed" && e.port.state === "disconnected") {

      /**
       * Event emitted when the `Input` becomes unavailable. This event is typically fired
       * when the MIDI device is unplugged.
       *
       * @event Input#disconnected
       * @type {object}
       * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
       * milliseconds since the navigation start of the document).
       * @property {string} type `disconnected`
       * @property {Input} port Object with properties describing the {@link Input} that was
       * disconnected. This is not the actual `Input` as it is no longer available.
       * @property {Input} target The object that dispatched the event.
       */
      event.type = "disconnected";
      event.port = {
        connection: e.port.connection,
        id: e.port.id,
        manufacturer: e.port.manufacturer,
        name: e.port.name,
        state: e.port.state,
        type: e.port.type
      };
      this.emit("disconnected", event);

    } else if (e.port.connection === "pending" && e.port.state === "disconnected") ; else {
      console.warn("This statechange event was not caught: ", e.port.connection, e.port.state);
    }

  }

  /**
   * Executed when a `"midimessage"` event is received
   * @param e
   * @private
   */
  _onMidiMessage(e) {

    // Create Message object from MIDI data
    const message = new Message(e.data);

    /**
     * Event emitted when any MIDI message is received on an `Input`.
     *
     * @event Input#midimessage
     *
     * @type {object}
     *
     * @property {Input} port The `Input` that triggered the event.
     * @property {Input} target The object that dispatched the event.
     * @property {Message} message A [`Message`](Message) object containing information about the
     * incoming MIDI message.
     * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
     * milliseconds since the navigation start of the document).
     * @property {string} type `midimessage`
     *
     * @since 2.1
     */
    const event = {
      port: this,
      target: this,
      message: message,
      timestamp: e.timeStamp,
      type: "midimessage",

      data: message.data,           // @deprecated (will be removed in v4)
      rawData: message.data,        // @deprecated (will be removed in v4)
      statusByte: message.data[0],  // @deprecated (will be removed in v4)
      dataBytes: message.dataBytes  // @deprecated (will be removed in v4)
    };

    this.emit("midimessage", event);

    // Messages are forwarded to InputChannel if they are channel messages or parsed locally for
    // system messages.
    if (message.isSystemMessage) {           // system messages
      this._parseEvent(event);
    } else if (message.isChannelMessage) {   // channel messages
      this.channels[message.channel]._processMidiMessageEvent(event);
    }

    // Forward message if forwarders have been defined
    this._forwarders.forEach(forwarder => forwarder.forward(message));

  }

  /**
   * @private
   */
  _parseEvent(e) {

    // Make a shallow copy of the incoming event so we can use it as the new event.
    const event = Object.assign({}, e);
    event.type = event.message.type || "unknownmidimessage";

    // Add custom property for 'songselect'
    if (event.type === "songselect") {
      event.song = e.data[1] + 1; // deprecated
      event.value = e.data[1];
      event.rawValue = event.value;
    }

    // Emit event
    this.emit(event.type, event);

  }

  /**
   * Opens the input for usage. This is usually unnecessary as the port is opened automatically when
   * WebMidi is enabled.
   *
   * @returns {Promise<Input>} The promise is fulfilled with the `Input` object.
   */
  async open() {

    // Explicitly opens the port for usage. This is not mandatory. When the port is not explicitly
    // opened, it is implicitly opened (asynchronously) when assigning a listener to the
    // `onmidimessage` property of the `MIDIInput`. We do it explicitly so that 'connected' events
    // are dispatched immediately and that we are ready to listen.
    try {
      await this._midiInput.open();
    } catch (err) {
      return Promise.reject(err);
    }

    return Promise.resolve(this);

  }

  /**
   * Closes the input. When an input is closed, it cannot be used to listen to MIDI messages until
   * the input is opened again by calling [`Input.open()`](Input#open).
   *
   * **Note**: if what you want to do is stop events from being dispatched, you should use
   * [`eventsSuspended`](#eventsSuspended) instead.
   *
   * @returns {Promise<Input>} The promise is fulfilled with the `Input` object
   */
  async close() {

    // We close the port. This triggers a statechange event which, in turn, will emit the 'closed'
    // event.
    if (!this._midiInput) return Promise.resolve(this);

    try {
      await this._midiInput.close();
    } catch (err) {
      return Promise.reject(err);
    }

    return Promise.resolve(this);

  }

  /**
   * @private
   * @deprecated since v3.0.0 (moved to 'Utilities' class)
   */
  getChannelModeByNumber() {
    if (wm.validation) {
      console.warn(
        "The 'getChannelModeByNumber()' method has been moved to the 'Utilities' class."
      );
    }
  }

  /**
   * Adds an event listener that will trigger a function callback when the specified event is
   * dispatched. The event usually is **input-wide** but can also be **channel-specific**.
   *
   * Input-wide events do not target a specific MIDI channel so it makes sense to listen for them
   * at the `Input` level and not at the [`InputChannel`](InputChannel) level. Channel-specific
   * events target a specific channel. Usually, in this case, you would add the listener to the
   * [`InputChannel`](InputChannel) object. However, as a convenience, you can also listen to
   * channel-specific events directly on an `Input`. This allows you to react to a channel-specific
   * event no matter which channel it actually came through.
   *
   * When listening for an event, you simply need to specify the event name and the function to
   * execute:
   *
   * ```javascript
   * const listener = WebMidi.inputs[0].addListener("midimessage", e => {
   *   console.log(e);
   * });
   * ```
   *
   * Calling the function with an input-wide event (such as
   * [`"midimessage"`]{@link #event:midimessage}), will return the [`Listener`](Listener) object
   * that was created.
   *
   * If you call the function with a channel-specific event (such as
   * [`"noteon"`]{@link InputChannel#event:noteon}), it will return an array of all
   * [`Listener`](Listener) objects that were created (one for each channel):
   *
   * ```javascript
   * const listeners = WebMidi.inputs[0].addListener("noteon", someFunction);
   * ```
   *
   * You can also specify which channels you want to add the listener to:
   *
   * ```javascript
   * const listeners = WebMidi.inputs[0].addListener("noteon", someFunction, {channels: [1, 2, 3]});
   * ```
   *
   * In this case, `listeners` is an array containing 3 [`Listener`](Listener) objects. The order of
   * the listeners in the array follows the order the channels were specified in.
   *
   * Note that, when adding channel-specific listeners, it is the [`InputChannel`](InputChannel)
   * instance that actually gets a listener added and not the `Input` instance. You can check that
   * by calling [`InputChannel.hasListener()`](InputChannel#hasListener()).
   *
   * There are 8 families of events you can listen to:
   *
   * 1. **MIDI System Common** Events (input-wide)
   *
   *    * [`songposition`]{@link Input#event:songposition}
   *    * [`songselect`]{@link Input#event:songselect}
   *    * [`sysex`]{@link Input#event:sysex}
   *    * [`timecode`]{@link Input#event:timecode}
   *    * [`tunerequest`]{@link Input#event:tunerequest}
   *
   * 2. **MIDI System Real-Time** Events (input-wide)
   *
   *    * [`clock`]{@link Input#event:clock}
   *    * [`start`]{@link Input#event:start}
   *    * [`continue`]{@link Input#event:continue}
   *    * [`stop`]{@link Input#event:stop}
   *    * [`activesensing`]{@link Input#event:activesensing}
   *    * [`reset`]{@link Input#event:reset}
   *
   * 3. **State Change** Events (input-wide)
   *
   *    * [`opened`]{@link Input#event:opened}
   *    * [`closed`]{@link Input#event:closed}
   *    * [`disconnected`]{@link Input#event:disconnected}
   *
   * 4. **Catch-All** Events (input-wide)
   *
   *    * [`midimessage`]{@link Input#event:midimessage}
   *    * [`unknownmidimessage`]{@link Input#event:unknownmidimessage}
   *
   * 5. **Channel Voice** Events (channel-specific)
   *
   *    * [`channelaftertouch`]{@link InputChannel#event:channelaftertouch}
   *    * [`controlchange`]{@link InputChannel#event:controlchange}
   *      * [`controlchange-controller0`]{@link InputChannel#event:controlchange-controller0}
   *      * [`controlchange-controller1`]{@link InputChannel#event:controlchange-controller1}
   *      * [`controlchange-controller2`]{@link InputChannel#event:controlchange-controller2}
   *      * (...)
   *      * [`controlchange-controller127`]{@link InputChannel#event:controlchange-controller127}
   *    * [`keyaftertouch`]{@link InputChannel#event:keyaftertouch}
   *    * [`noteoff`]{@link InputChannel#event:noteoff}
   *    * [`noteon`]{@link InputChannel#event:noteon}
   *    * [`pitchbend`]{@link InputChannel#event:pitchbend}
   *    * [`programchange`]{@link InputChannel#event:programchange}
   *
   *    Note: you can listen for a specific control change message by using an event name like this:
   *    `controlchange-controller23`, `controlchange-controller99`, `controlchange-controller122`,
   *    etc.
   *
   * 6. **Channel Mode** Events (channel-specific)
   *
   *    * [`allnotesoff`]{@link InputChannel#event:allnotesoff}
   *    * [`allsoundoff`]{@link InputChannel#event:allsoundoff}
   *    * [`localcontrol`]{@link InputChannel#event:localcontrol}
   *    * [`monomode`]{@link InputChannel#event:monomode}
   *    * [`omnimode`]{@link InputChannel#event:omnimode}
   *    * [`resetallcontrollers`]{@link InputChannel#event:resetallcontrollers}
   *
   * 7. **NRPN** Events (channel-specific)
   *
   *    * [`nrpn`]{@link InputChannel#event:nrpn}
   *    * [`nrpn-dataentrycoarse`]{@link InputChannel#event:nrpn-dataentrycoarse}
   *    * [`nrpn-dataentryfine`]{@link InputChannel#event:nrpn-dataentryfine}
   *    * [`nrpn-dataincrement`]{@link InputChannel#event:nrpn-dataincrement}
   *    * [`nrpn-datadecrement`]{@link InputChannel#event:nrpn-datadecrement}
   *
   * 8. **RPN** Events (channel-specific)
   *
   *    * [`rpn`]{@link InputChannel#event:rpn}
   *    * [`rpn-dataentrycoarse`]{@link InputChannel#event:rpn-dataentrycoarse}
   *    * [`rpn-dataentryfine`]{@link InputChannel#event:rpn-dataentryfine}
   *    * [`rpn-dataincrement`]{@link InputChannel#event:rpn-dataincrement}
   *    * [`rpn-datadecrement`]{@link InputChannel#event:rpn-datadecrement}
   *
   * @param event {string | EventEmitter.ANY_EVENT} The type of the event.
   *
   * @param listener {function} A callback function to execute when the specified event is detected.
   * This function will receive an event parameter object. For details on this object's properties,
   * check out the documentation for the various events (links above).
   *
   * @param {object} [options={}]
   *
   * @param {array} [options.arguments] An array of arguments which will be passed separately to the
   * callback function. This array is stored in the [`arguments`](Listener#arguments) property of
   * the [`Listener`](Listener) object and can be retrieved or modified as desired.
   *
   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]
   * An integer between 1 and 16 or an array of such integers representing the MIDI channel(s) to
   * listen on. If no channel is specified, all channels will be used. This parameter is ignored for
   * input-wide events.
   *
   * @param {object} [options.context=this] The value of `this` in the callback function.
   *
   * @param {number} [options.duration=Infinity] The number of milliseconds before the listener
   * automatically expires.
   *
   * @param {boolean} [options.prepend=false] Whether the listener should be added at the beginning
   * of the listeners array and thus be triggered before others.
   *
   * @param {number} [options.remaining=Infinity] The number of times after which the callback
   * should automatically be removed.
   *
   * @returns {Listener|Listener[]} If the event is input-wide, a single [`Listener`](Listener)
   * object is returned. If the event is channel-specific, an array of all the
   * [`Listener`](Listener) objects is returned (one for each channel).
   */
  addListener(event, listener, options = {}) {

    if (wm.validation) {

      // Legacy compatibility
      if (typeof options === "function") {
        let channels = (listener != undefined) ? [].concat(listener) : undefined; // clone
        listener = options;
        options = {channels: channels};
      }

    }

    // Check if the event is channel-specific or input-wide
    if (Enumerations.CHANNEL_EVENTS.includes(event)) {

      // If no channel defined, use all.
      if (options.channels === undefined) options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

      let listeners = [];

      Utilities.sanitizeChannels(options.channels).forEach(ch => {
        listeners.push(this.channels[ch].addListener(event, listener, options));
      });

      return listeners;

    } else {

      return super.addListener(event, listener, options);

    }

  }

  /**
   * Adds a one-time event listener that will trigger a function callback when the specified event
   * happens. The event can be **channel-bound** or **input-wide**. Channel-bound events are
   * dispatched by [`InputChannel`]{@link InputChannel} objects and are tied to a specific MIDI
   * channel while input-wide events are dispatched by the `Input` object itself and are not tied
   * to a specific channel.
   *
   * Calling the function with an input-wide event (such as
   * [`"midimessage"`]{@link #event:midimessage}), will return the [`Listener`](Listener) object
   * that was created.
   *
   * If you call the function with a channel-specific event (such as
   * [`"noteon"`]{@link InputChannel#event:noteon}), it will return an array of all
   * [`Listener`](Listener) objects that were created (one for each channel):
   *
   * ```javascript
   * const listeners = WebMidi.inputs[0].addOneTimeListener("noteon", someFunction);
   * ```
   *
   * You can also specify which channels you want to add the listener to:
   *
   * ```javascript
   * const listeners = WebMidi.inputs[0].addOneTimeListener("noteon", someFunction, {channels: [1, 2, 3]});
   * ```
   *
   * In this case, the `listeners` variable contains an array of 3 [`Listener`](Listener) objects.
   *
   * The code above will add a listener for the `"noteon"` event and call `someFunction` when the
   * event is triggered on MIDI channels `1`, `2` or `3`.
   *
   * Note that, when adding events to channels, it is the [`InputChannel`](InputChannel) instance
   * that actually gets a listener added and not the `Input` instance.
   *
   * Note: if you want to add a listener to a single MIDI channel you should probably do so directly
   * on the [`InputChannel`](InputChannel) object itself.
   *
   * There are 8 families of events you can listen to:
   *
   * 1. **MIDI System Common** Events (input-wide)
   *
   *    * [`songposition`]{@link Input#event:songposition}
   *    * [`songselect`]{@link Input#event:songselect}
   *    * [`sysex`]{@link Input#event:sysex}
   *    * [`timecode`]{@link Input#event:timecode}
   *    * [`tunerequest`]{@link Input#event:tunerequest}
   *
   * 2. **MIDI System Real-Time** Events (input-wide)
   *
   *    * [`clock`]{@link Input#event:clock}
   *    * [`start`]{@link Input#event:start}
   *    * [`continue`]{@link Input#event:continue}
   *    * [`stop`]{@link Input#event:stop}
   *    * [`activesensing`]{@link Input#event:activesensing}
   *    * [`reset`]{@link Input#event:reset}
   *
   * 3. **State Change** Events (input-wide)
   *
   *    * [`opened`]{@link Input#event:opened}
   *    * [`closed`]{@link Input#event:closed}
   *    * [`disconnected`]{@link Input#event:disconnected}
   *
   * 4. **Catch-All** Events (input-wide)
   *
   *    * [`midimessage`]{@link Input#event:midimessage}
   *    * [`unknownmidimessage`]{@link Input#event:unknownmidimessage}
   *
   * 5. **Channel Voice** Events (channel-specific)
   *
   *    * [`channelaftertouch`]{@link InputChannel#event:channelaftertouch}
   *    * [`controlchange`]{@link InputChannel#event:controlchange}
   *      * [`controlchange-controller0`]{@link InputChannel#event:controlchange-controller0}
   *      * [`controlchange-controller1`]{@link InputChannel#event:controlchange-controller1}
   *      * [`controlchange-controller2`]{@link InputChannel#event:controlchange-controller2}
   *      * (...)
   *      * [`controlchange-controller127`]{@link InputChannel#event:controlchange-controller127}
   *    * [`keyaftertouch`]{@link InputChannel#event:keyaftertouch}
   *    * [`noteoff`]{@link InputChannel#event:noteoff}
   *    * [`noteon`]{@link InputChannel#event:noteon}
   *    * [`pitchbend`]{@link InputChannel#event:pitchbend}
   *    * [`programchange`]{@link InputChannel#event:programchange}
   *
   *    Note: you can listen for a specific control change message by using an event name like this:
   *    `controlchange-controller23`, `controlchange-controller99`, `controlchange-controller122`,
   *    etc.
   *
   * 6. **Channel Mode** Events (channel-specific)
   *
   *    * [`allnotesoff`]{@link InputChannel#event:allnotesoff}
   *    * [`allsoundoff`]{@link InputChannel#event:allsoundoff}
   *    * [`localcontrol`]{@link InputChannel#event:localcontrol}
   *    * [`monomode`]{@link InputChannel#event:monomode}
   *    * [`omnimode`]{@link InputChannel#event:omnimode}
   *    * [`resetallcontrollers`]{@link InputChannel#event:resetallcontrollers}
   *
   * 7. **NRPN** Events (channel-specific)
   *
   *    * [`nrpn`]{@link InputChannel#event:nrpn}
   *    * [`nrpn-dataentrycoarse`]{@link InputChannel#event:nrpn-dataentrycoarse}
   *    * [`nrpn-dataentryfine`]{@link InputChannel#event:nrpn-dataentryfine}
   *    * [`nrpn-dataincrement`]{@link InputChannel#event:nrpn-dataincrement}
   *    * [`nrpn-datadecrement`]{@link InputChannel#event:nrpn-datadecrement}
   *
   * 8. **RPN** Events (channel-specific)
   *
   *    * [`rpn`]{@link InputChannel#event:rpn}
   *    * [`rpn-dataentrycoarse`]{@link InputChannel#event:rpn-dataentrycoarse}
   *    * [`rpn-dataentryfine`]{@link InputChannel#event:rpn-dataentryfine}
   *    * [`rpn-dataincrement`]{@link InputChannel#event:rpn-dataincrement}
   *    * [`rpn-datadecrement`]{@link InputChannel#event:rpn-datadecrement}
   *
   * @param event {string} The type of the event.
   *
   * @param listener {function} A callback function to execute when the specified event is detected.
   * This function will receive an event parameter object. For details on this object's properties,
   * check out the documentation for the various events (links above).
   *
   * @param {object} [options={}]
   *
   * @param {array} [options.arguments] An array of arguments which will be passed separately to the
   * callback function. This array is stored in the [`arguments`](Listener#arguments) property of
   * the [`Listener`](Listener) object and can be retrieved or modified as desired.
   *
   * @param {number|number[]} [options.channels]  An integer between 1 and 16 or an array of
   * such integers representing the MIDI channel(s) to listen on. This parameter is ignored for
   * input-wide events.
   *
   * @param {object} [options.context=this] The value of `this` in the callback function.
   *
   * @param {number} [options.duration=Infinity] The number of milliseconds before the listener
   * automatically expires.
   *
   * @param {boolean} [options.prepend=false] Whether the listener should be added at the beginning
   * of the listeners array and thus be triggered before others.
   *
   * @returns {Listener[]} An array of all [`Listener`](Listener) objects that were created.
   */
  addOneTimeListener(event, listener, options = {}) {
    options.remaining = 1;
    return this.addListener(event, listener, options);
  }

  /**
   * This is an alias to the [Input.addListener()]{@link Input#addListener} method.
   * @since 2.0.0
   * @deprecated since v3.0
   * @private
   */
  on(event, channel, listener, options) {
    return this.addListener(event, channel, listener, options);
  }

  /**
   * Checks if the specified event type is already defined to trigger the specified callback
   * function. For channel-specific events, the function will return `true` only if all channels
   * have the listener defined.
   *
   * @param event {string|Symbol} The type of the event.
   *
   * @param listener {function} The callback function to check for.
   *
   * @param {object} [options={}]
   *
   * @param {number|number[]} [options.channels]  An integer between 1 and 16 or an array of such
   * integers representing the MIDI channel(s) to check. This parameter is ignored for input-wide
   * events.
   *
   * @returns {boolean} Boolean value indicating whether or not the `Input` or
   * [`InputChannel`](InputChannel) already has this listener defined.
   */
  hasListener(event, listener, options = {}) {

    if (wm.validation) {

      // Legacy compatibility
      if (typeof options === "function") {
        let channels = [].concat(listener); // clone
        listener = options;
        options = {channels: channels};
      }

    }

    if (Enumerations.CHANNEL_EVENTS.includes(event)) {

      // If no channel defined, use all.
      if (options.channels === undefined) options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

      return Utilities.sanitizeChannels(options.channels).every(ch => {
        return this.channels[ch].hasListener(event, listener);
      });

    } else {
      return super.hasListener(event, listener);
    }

  }

  /**
   * Removes the specified event listener. If no listener is specified, all listeners matching the
   * specified event will be removed. If the event is channel-specific, the listener will be removed
   * from all [`InputChannel`]{@link InputChannel} objects belonging to that channel. If no event is
   * specified, all listeners for the `Input` as well as all listeners for all
   * [`InputChannel`]{@link InputChannel} objects belonging to the `Input` will be removed.
   *
   * By default, channel-specific listeners will be removed from all
   * [`InputChannel`]{@link InputChannel} objects unless the `options.channel` narrows it down.
   *
   * @param [type] {string} The type of the event.
   *
   * @param [listener] {function} The callback function to check for.
   *
   * @param {object} [options={}]
   *
   * @param {number|number[]} [options.channels]  An integer between 1 and 16 or an array of
   * such integers representing the MIDI channel(s) to match. This parameter is ignored for
   * input-wide events.
   *
   * @param {*} [options.context] Only remove the listeners that have this exact context.
   *
   * @param {number} [options.remaining] Only remove the listener if it has exactly that many
   * remaining times to be executed.
   */
  removeListener(event, listener, options = {}) {

    if (wm.validation) {

      // Legacy compatibility
      if (typeof options === "function") {
        let channels = [].concat(listener); // clone
        listener = options;
        options = {channels: channels};
      }

    }

    if (options.channels === undefined) options.channels = Enumerations.MIDI_CHANNEL_NUMBERS;

    // If the event is not specified, remove everything (channel-specific and input-wide)!
    if (event == undefined) {
      Utilities.sanitizeChannels(options.channels).forEach(ch => {
        if (this.channels[ch]) this.channels[ch].removeListener();
      });
      return super.removeListener();
    }

    // If the event is specified, check if it's channel-specific or input-wide.
    if (Enumerations.CHANNEL_EVENTS.includes(event)) {

      Utilities.sanitizeChannels(options.channels).forEach(ch => {
        this.channels[ch].removeListener(event, listener, options);
      });

    } else {

      super.removeListener(event, listener, options);

    }

  }

  /**
   * Adds a forwarder that will forward all incoming MIDI messages matching the criteria to the
   * specified [`Output`](Output) destination(s). This is akin to the hardware MIDI THRU port, with
   * the added benefit of being able to filter which data is forwarded.
   *
   * @param {Output|Output[]} output An [`Output`](Output) object, or an array of such
   * objects, to forward messages to.
   * @param {object} [options={}]
   * @param {string|string[]} [options.types=(all messages)] A message type, or an array of such
   * types (`noteon`, `controlchange`, etc.), that the message type must match in order to be
   * forwarded. If this option is not specified, all types of messages will be forwarded. Valid
   * messages are the ones found in either
   * [`SYSTEM_MESSAGES`](Enumerations#SYSTEM_MESSAGES) or
   * [`CHANNEL_MESSAGES`](Enumerations#CHANNEL_MESSAGES).
   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]
   * A MIDI channel number or an array of channel numbers that the message must match in order to be
   * forwarded. By default all MIDI channels are included (`1` to `16`).
   *
   * @returns {Forwarder} The [`Forwarder`](Forwarder) object created to handle the forwarding. This
   * is useful if you wish to manipulate or remove the [`Forwarder`](Forwarder) later on.
   */
  addForwarder(output, options = {}) {

    let forwarder;

    // Unless 'output' is a forwarder, create a new forwarder
    if (output instanceof Forwarder) {
      forwarder = output;
    } else {
      forwarder = new Forwarder(output, options);
    }

    this._forwarders.push(forwarder);
    return forwarder;

  }

  /**
   * Removes the specified [`Forwarder`](Forwarder) object from the input.
   *
   * @param {Forwarder} forwarder The [`Forwarder`](Forwarder) to remove (the
   * [`Forwarder`](Forwarder) object is returned when calling `addForwarder()`.
   */
  removeForwarder(forwarder) {
    this._forwarders = this._forwarders.filter(item => item !== forwarder);
  }

  /**
   * Checks whether the specified [`Forwarder`](Forwarder) object has already been attached to this
   * input.
   *
   * @param {Forwarder} forwarder The [`Forwarder`](Forwarder) to check for (the
   * [`Forwarder`](Forwarder) object is returned when calling [`addForwarder()`](#addForwarder).
   * @returns {boolean}
   */
  hasForwarder(forwarder) {
    return this._forwarders.includes(forwarder);
  }

  /**
   * Name of the MIDI input.
   *
   * @type {string}
   * @readonly
   */
  get name() {
    return this._midiInput.name;
  }

  /**
   * ID string of the MIDI port. The ID is host-specific. Do not expect the same ID on different
   * platforms. For example, Google Chrome and the Jazz-Plugin report completely different IDs for
   * the same port.
   *
   * @type {string}
   * @readonly
   */
  get id() {
    return this._midiInput.id;
  }

  /**
   * Input port's connection state: `pending`, `open` or `closed`.
   *
   * @type {string}
   * @readonly
   */
  get connection() {
    return this._midiInput.connection;
  }

  /**
   * Name of the manufacturer of the device that makes this input port available.
   *
   * @type {string}
   * @readonly
   */
  get manufacturer() {
    return this._midiInput.manufacturer;
  }

  /**
   * An integer to offset the reported octave of incoming notes. By default, middle C (MIDI note
   * number 60) is placed on the 4th octave (C4).
   *
   * If, for example, `octaveOffset` is set to 2, MIDI note number 60 will be reported as C6. If
   * `octaveOffset` is set to -1, MIDI note number 60 will be reported as C3.
   *
   * Note that this value is combined with the global offset value defined in the
   * [`WebMidi.octaveOffset`](WebMidi#octaveOffset) property (if any).
   *
   * @type {number}
   *
   * @since 3.0
   */
  get octaveOffset() {
    return this._octaveOffset;
  }
  set octaveOffset(value) {

    if (this.validation) {
      value = parseInt(value);
      if (isNaN(value)) throw new TypeError("The 'octaveOffset' property must be an integer.");
    }

    this._octaveOffset = value;

  }

  /**
   * State of the input port: `connected` or `disconnected`.
   *
   * @type {string}
   * @readonly
   */
  get state() {
    return this._midiInput.state;
  }

  /**
   * The port type. In the case of the `Input` object, this is always: `input`.
   *
   * @type {string}
   * @readonly
   */
  get type() {
    return this._midiInput.type;
  }

  /**
   * @type {boolean}
   * @private
   * @deprecated since v3.0.0 (moved to 'InputChannel' class)
   */
  get nrpnEventsEnabled() {
    if (wm.validation) {
      console.warn("The 'nrpnEventsEnabled' property has been moved to the 'InputChannel' class.");
    }
    return false;
  }

}

// Events that do not have code below them must be placed outside the class definition (?!)

/**
 * Input-wide (system) event emitted when a **system exclusive** message has been received.
 * You should note that, to receive `sysex` events, you must call the
 * [`WebMidi.enable()`](WebMidi#enable()) method with the `sysex` option set to `true`:
 *
 * ```js
 * WebMidi.enable({sysex: true})
 *  .then(() => console.log("WebMidi has been enabled with sysex support."))
 * ```
 *
 * @event Input#sysex
 *
 * @type {object}
 *
 * @property {Input} port The `Input` that triggered the event.
 * @property {Input} target The object that dispatched the event.
 * @property {Message} message A [`Message`](Message) object containing information about the
 * incoming MIDI message.
 * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
 * milliseconds since the navigation start of the document).
 * @property {string} type `sysex`
 *
 */

/**
 * Input-wide (system) event emitted when a **time code quarter frame** message has been
 * received.
 *
 * @event Input#timecode
 *
 * @type {object}
 *
 * @property {Input} port The `Input` that triggered the event.
 * @property {Input} target The object that dispatched the event.
 * @property {Message} message A [`Message`](Message) object containing information about the
 * incoming MIDI message.
 * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
 * milliseconds since the navigation start of the document).
 * @property {string} type `timecode`
 *
 * @since 2.1
 */

/**
 * Input-wide (system) event emitted when a **song position** message has been received.
 *
 * @event Input#songposition
 *
 * @type {object}
 *
 * @property {Input} port The `Input` that triggered the event.
 * @property {Input} target The object that dispatched the event.
 * @property {Message} message A [`Message`](Message) object containing information about the
 * incoming MIDI message.
 * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
 * milliseconds since the navigation start of the document).
 * @property {string} type `songposition`
 *
 * @since 2.1
 */

/**
 * Input-wide (system) event emitted when a **song select** message has been received.
 *
 * @event Input#songselect
 *
 * @type {object}
 *
 * @property {Input} port The `Input` that triggered the event.
 * @property {Input} target The object that dispatched the event.
 * @property {Message} message A [`Message`](Message) object containing information about the
 * incoming MIDI message.
 * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
 * milliseconds since the navigation start of the document).
 * @property {string} value Song (or sequence) number to select (0-127)
 * @property {string} rawValue Song (or sequence) number to select (0-127)
 *
 * @since 2.1
 */

/**
 * Input-wide (system) event emitted when a **tune request** message has been received.
 *
 * @event Input#tunerequest
 *
 * @type {object}
 *
 * @property {Input} port The `Input` that triggered the event.
 * @property {Input} target The object that dispatched the event.
 * @property {Message} message A [`Message`](Message) object containing information about the
 * incoming MIDI message.
 * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
 * milliseconds since the navigation start of the document).
 * @property {string} type `tunerequest`
 *
 * @since 2.1
 */

/**
 * Input-wide (system) event emitted when a **timing clock** message has been received.
 *
 * @event Input#clock
 *
 * @type {object}
 *
 * @property {Input} port The `Input` that triggered the event.
 * @property {Input} target The object that dispatched the event.
 * @property {Message} message A [`Message`](Message) object containing information about the
 * incoming MIDI message.
 * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
 * milliseconds since the navigation start of the document).
 * @property {string} type `clock`
 *
 * @since 2.1
 */

/**
 * Input-wide (system) event emitted when a **start** message has been received.
 *
 * @event Input#start
 *
 * @type {object}
 *
 * @property {Input} port The `Input` that triggered the event.
 * @property {Input} target The object that dispatched the event.
 * @property {Message} message A [`Message`](Message) object containing information about the
 * incoming MIDI message.
 * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
 * milliseconds since the navigation start of the document).
 * @property {string} type `start`
 *
 * @since 2.1
 */

/**
 * Input-wide (system) event emitted when a **continue** message has been received.
 *
 * @event Input#continue
 *
 * @type {object}
 *
 * @property {Input} port The `Input` that triggered the event.
 * @property {Input} target The object that dispatched the event.
 * @property {Message} message A [`Message`](Message) object containing information about the
 * incoming MIDI message.
 * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
 * milliseconds since the navigation start of the document).
 * @property {string} type `continue`
 *
 * @since 2.1
 */

/**
 * Input-wide (system) event emitted when a **stop** message has been received.
 *
 * @event Input#stop
 *
 * @type {object}
 *
 * @property {Input} port The `Input` that triggered the event.
 * @property {Input} target The object that dispatched the event.
 * @property {Message} message A [`Message`](Message) object containing information about the
 * incoming MIDI message.
 * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
 * milliseconds since the navigation start of the document).
 * @property {string} type `stop`
 *
 * @since 2.1
 */

/**
 * Input-wide (system) event emitted when an **active sensing** message has been received.
 *
 * @event Input#activesensing
 *
 * @type {object}
 *
 * @property {Input} port The `Input` that triggered the event.
 * @property {Input} target The object that dispatched the event.
 * @property {Message} message A [`Message`](Message) object containing information about the
 * incoming MIDI message.
 * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
 * milliseconds since the navigation start of the document).
 * @property {string} type `activesensing`
 *
 * @since 2.1
 */

/**
 * Input-wide (system) event emitted when a **reset** message has been received.
 *
 * @event Input#reset
 *
 * @type {object}
 *
 * @property {Input} port The `Input` that triggered the event.
 * @property {Input} target The object that dispatched the event.
 * @property {Message} message A [`Message`](Message) object containing information about the
 * incoming MIDI message.
 * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
 * milliseconds since the navigation start of the document).
 * @property {string} type `reset`
 *
 * @since 2.1
 */

/**
 * Input-wide (system) event emitted when an unknown MIDI message has been received. It could
 * be, for example, one of the undefined/reserved messages.
 *
 * @event Input#unknownmessage
 *
 * @type {Object}
 *
 * @property {Input} port The `Input` that triggered the event.
 * @property {Input} target The object that dispatched the event.
 * @property {Message} message A [`Message`](Message) object containing information about the
 * incoming MIDI message.
 * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred (in
 * milliseconds since the navigation start of the document).
 * @property {string} type `unknownmessage`
 *
 * @since 2.1
 */

/**
 * The `WebMidi` object makes it easier to work with the low-level Web MIDI API. Basically, it
 * simplifies sending outgoing MIDI messages and reacting to incoming MIDI messages.
 *
 * When using the WebMidi.js library, you should know that the `WebMidi` class has already been
 * instantiated. You cannot instantiate it yourself. If you use the **IIFE** version, you should
 * simply use the global object called `WebMidi`. If you use the **CJS** (CommonJS) or **ESM** (ES6
 * module) version, you get an already-instantiated object when you import the module.
 *
 * @fires WebMidi#connected
 * @fires WebMidi#disabled
 * @fires WebMidi#disconnected
 * @fires WebMidi#enabled
 * @fires WebMidi#error
 * @fires WebMidi#midiaccessgranted
 * @fires WebMidi#portschanged
 *
 * @extends EventEmitter
 * @license Apache-2.0
 */
class WebMidi extends EventEmitter {

  /**
   * The WebMidi class is a singleton and you cannot instantiate it directly. It has already been
   * instantiated for you.
   */
  constructor() {

    super();

    /**
     * Object containing system-wide default values that can be changed to customize how the library
     * works.
     *
     * @type {object}
     *
     * @property {object}  defaults.note - Default values relating to note
     * @property {number}  defaults.note.attack - A number between 0 and 127 representing the
     * default attack velocity of notes. Initial value is 64.
     * @property {number}  defaults.note.release - A number between 0 and 127 representing the
     * default release velocity of notes. Initial value is 64.
     * @property {number}  defaults.note.duration - A number representing the default duration of
     * notes (in seconds). Initial value is Infinity.
     */
    this.defaults = {
      note: {
        attack: Utilities.from7bitToFloat(64),
        release: Utilities.from7bitToFloat(64),
        duration: Infinity
      }
    };

    /**
     * The [`MIDIAccess`](https://developer.mozilla.org/en-US/docs/Web/API/MIDIAccess)
     * instance used to talk to the lower-level Web MIDI API. This should not be used directly
     * unless you know what you are doing.
     *
     * @type {MIDIAccess}
     * @readonly
     */
    this.interface = null;

    /**
     * Indicates whether argument validation and backwards-compatibility checks are performed
     * throughout the WebMidi.js library for object methods and property setters.
     *
     * This is an advanced setting that should be used carefully. Setting `validation` to `false`
     * improves performance but should only be done once the project has been thoroughly tested with
     * `validation` turned on.
     *
     * @type {boolean}
     */
    this.validation = true;

    /**
     * Array of all (Input) objects
     * @type {Input[]}
     * @private
     */
    this._inputs = [];

    /**
     * Array of disconnected [`Input`](Input) objects. This is used when inputs are plugged back in
     * to retain their previous state.
     * @type {Input[]}
     * @private
     */
    this._disconnectedInputs = [];

    /**
     * Array of all [`Output`](Output) objects
     * @type {Output[]}
     * @private
     */
    this._outputs = [];

    /**
     * Array of disconnected [`Output`](Output) objects. This is used when outputs are plugged back
     * in to retain their previous state.
     * @type {Output[]}
     * @private
     */
    this._disconnectedOutputs = [];

    /**
     * Array of statechange events to process. These events must be parsed synchronously so they do
     * not override each other.
     *
     * @type {string[]}
     * @private
     */
    this._stateChangeQueue = [];

    /**
     * @type {number}
     * @private
     */
    this._octaveOffset = 0;

  }

  /**
   * Checks if the Web MIDI API is available in the current environment and then tries to connect to
   * the host's MIDI subsystem. This is an asynchronous operation and it causes a security prompt to
   * be displayed to the user.
   *
   * To enable the use of MIDI system exclusive messages, the `sysex` option should be set to
   * `true`. However, under some environments (e.g. Jazz-Plugin), the `sysex` option is ignored
   * and system exclusive messages are always enabled. You can check the
   * [`sysexEnabled`](#sysexEnabled) property to confirm.
   *
   * To enable access to software synthesizers available on the host, you would set the `software`
   * option to `true`. However, this option is only there to future-proof the library as support for
   * software synths has not yet been implemented in any browser (as of September 2021).
   *
   * By the way, if you call the [`enable()`](#enable) method while WebMidi.js is already enabled,
   * the callback function will be executed (if any), the promise will resolve but the events
   * ([`"midiaccessgranted"`](#event:midiaccessgranted), [`"connected"`](#event:connected) and
   * [`"enabled"`](#event:enabled)) will not be fired.
   *
   * There are 3 ways to execute code after `WebMidi` has been enabled:
   *
   * - Pass a callback function in the `options`
   * - Listen to the [`"enabled"`](#event:enabled) event
   * - Wait for the promise to resolve
   *
   * In order, this is what happens towards the end of the enabling process:
   *
   * 1. [`"midiaccessgranted"`](#event:midiaccessgranted) event is triggered once the user has
   * granted access to use MIDI.
   * 2. [`"connected"`](#event:connected) events are triggered (for each available input and output)
   * 3. [`"enabled"`](#event:enabled) event is triggered when WebMidi.js is fully ready
   * 4. specified callback (if any) is executed
   * 5. promise is resolved and fulfilled with the `WebMidi` object.
   *
   * **Important note**: starting with Chrome v77, a page using Web MIDI API must be hosted on a
   * secure origin (`https://`, `localhost` or `file:///`) and the user will always be prompted to
   * authorize the operation (no matter if the `sysex` option is `true` or not).
   *
   * ##### Example
   * ```js
   * // Enabling WebMidi and using the promise
   * WebMidi.enable().then(() => {
   *   console.log("WebMidi.js has been enabled!");
   * })
   * ```
   *
   * @param [options] {object}
   *
   * @param [options.callback] {function} A function to execute once the operation completes. This
   * function will receive an `Error` object if enabling the Web MIDI API failed.
   *
   * @param [options.sysex=false] {boolean} Whether to enable MIDI system exclusive messages or not.
   *
   * @param [options.validation=true] {boolean} Whether to enable library-wide validation of method
   * arguments and setter values. This is an advanced setting that should be used carefully. Setting
   * [`validation`](#validation) to `false` improves performance but should only be done once the
   * project has been thoroughly tested with [`validation`](#validation)  turned on.
   *
   * @param [options.software=false] {boolean} Whether to request access to software synthesizers on
   * the host system. This is part of the spec but has not yet been implemented by most browsers as
   * of April 2020.
   *
   * @param [options.requestMIDIAccessFunction] {function} A custom function to use to return
   * the MIDIAccess object. This is useful if you want to use a polyfill for the Web MIDI API
   * or if you want to use a custom implementation of the Web MIDI API - probably for testing
   * purposes.
   *
   * @async
   *
   * @returns {Promise.<WebMidi>} The promise is fulfilled with the `WebMidi` object for
   * chainability
   *
   * @throws {Error} The Web MIDI API is not supported in your environment.
   * @throws {Error} Jazz-Plugin must be installed to use WebMIDIAPIShim.
   */
  async enable(options = {}, legacy = false) {

    /*START-ESM*/

    // This block is stripped out of the IIFE and CJS versions where it isn't needed.

    // If this code is executed by Node.js in "module" mode (when "type": "module" is used in the
    // package.json file), then we must import the `jzz` module. I import it in this convoluted way
    // to prevent Webpack from automatically bundling it in browser bundles where it isn't needed.
    if (Utilities.isNode) {

      // Some environments may have both Node.js and browser runtimes (Electron, NW.js, React
      // Native, etc.) so we also check for the presence of the window.navigator property.
      try {
        window.navigator;
      } catch (err) {
        let jzz = await Object.getPrototypeOf(async function() {}).constructor(`
        let jzz = await import("jzz");
        return jzz.default;
        `)();
        if (!global.navigator) global.navigator = {}; // for Node.js prior to v21
        Object.assign(global.navigator, jzz);
      }

      // The `performance` module appeared in Node.js v8.5.0 but has started to be automatically
      // imported only in v16+.
      try {
        performance;
      } catch (err) {
        global.performance = await Object.getPrototypeOf(async function() {}).constructor(`
        let perf_hooks = await import("perf_hooks");
        return perf_hooks.performance;
        `)();
      }

    }

    /*END-ESM*/

    this.validation = (options.validation !== false);

    if (this.validation) {
      // Backwards-compatibility. Previous syntax was: enable(callback, sysex)
      if (typeof options === "function") options = {callback: options, sysex: legacy};
      if (legacy) options.sysex = true;
    }

    // If already enabled, trigger callback and resolve promise but do not dispatch events.
    if (this.enabled) {
      if (typeof options.callback === "function") options.callback();
      return Promise.resolve();
    }

    /**
     * Event emitted when an error occurs trying to enable `WebMidi`
     *
     * @event WebMidi#error
     * @type {object}
     * @property {DOMHighResTimeStamp} timestamp The moment when the event occurred (in
     * milliseconds since the navigation start of the document).
     * @property {WebMidi} target The object that triggered the event
     * @property {string} type `error`
     * @property {*} error Actual error that occurred
     */
    const errorEvent = {
      timestamp: this.time,
      target: this,
      type: "error",
      error: undefined
    };

    /**
     * Event emitted once the MIDI interface has been successfully created (which implies user has
     * granted access to MIDI).
     *
     * @event WebMidi#midiaccessgranted
     * @type {object}
     * @property {DOMHighResTimeStamp} timestamp The moment when the event occurred (in milliseconds
     * since the navigation start of the document).
     * @property {WebMidi} target The object that triggered the event
     * @property {string} type `midiaccessgranted`
     */
    const midiAccessGrantedEvent = {
      timestamp: this.time,
      target: this,
      type: "midiaccessgranted"
    };

    /**
     * Event emitted once `WebMidi` has been fully enabled
     *
     * @event WebMidi#enabled
     * @type {object}
     * @property {DOMHighResTimeStamp} timestamp The moment when the event occurred (in milliseconds
     * since the navigation start of the document).
     * @property {WebMidi} target The object that triggered the event
     * @property {string} type `"enabled"`
     */
    const enabledEvent = {
      timestamp: this.time,
      target: this,
      type: "enabled"
    };

    // Request MIDI access (this is where the prompt will appear)
    try {
      if (typeof options.requestMIDIAccessFunction === "function") {
        this.interface = await options.requestMIDIAccessFunction(
          {sysex: options.sysex, software: options.software}
        );
      } else {
        this.interface = await navigator.requestMIDIAccess(
          {sysex: options.sysex, software: options.software}
        );
      }
    } catch(err) {
      errorEvent.error = err;
      this.emit("error", errorEvent);
      if (typeof options.callback === "function") options.callback(err);
      return Promise.reject(err);
    }

    // Now that the Web MIDI API interface has been created, we trigger the 'midiaccessgranted'
    // event. This allows the developer an occasion to assign listeners on 'connected' events.
    this.emit("midiaccessgranted", midiAccessGrantedEvent);

    // We setup the state change listener before creating the ports so that it properly catches the
    // the ports' `connected` events
    this.interface.onstatechange = this._onInterfaceStateChange.bind(this);

    // Update inputs and outputs (this is where `Input` and `Output` objects are created).
    try {
      await this._updateInputsAndOutputs();
    } catch (err) {
      errorEvent.error = err;
      this.emit("error", errorEvent);
      if (typeof options.callback === "function") options.callback(err);
      return Promise.reject(err);
    }

    // If we make it here, the ports have been successfully created, so we trigger the 'enabled'
    // event.
    this.emit("enabled", enabledEvent);

    // Execute the callback (if any) and resolve the promise with 'this' (for chainability)
    if (typeof options.callback === "function") options.callback();
    return Promise.resolve(this);

  }

  /**
   * Completely disables **WebMidi.js** by unlinking the MIDI subsystem's interface and closing all
   * [`Input`](Input) and [`Output`](Output) objects that may have been opened. This also means that
   * listeners added to [`Input`](Input) objects, [`Output`](Output) objects or to `WebMidi` itself
   * are also destroyed.
   *
   * @async
   * @returns {Promise<Array>}
   *
   * @throws {Error} The Web MIDI API is not supported by your environment.
   *
   * @since 2.0.0
   */
  async disable() {

    // This needs to be done right away to prevent racing conditions in listeners while the inputs
    // are being destroyed.
    if (this.interface) this.interface.onstatechange = undefined;

    return this._destroyInputsAndOutputs().then(() => {

      if (navigator && typeof navigator.close === "function") navigator.close(); // jzz

      this.interface = null; // also resets enabled, sysexEnabled

      /**
       * Event emitted once `WebMidi` has been successfully disabled.
       *
       * @event WebMidi#disabled
       * @type {object}
       * @property {DOMHighResTimeStamp} timestamp The moment when the event occurred (in
       * milliseconds since the navigation start of the document).
       * @property {WebMidi} target The object that triggered the event
       * @property {string} type `"disabled"`
       */
      let event = {
        timestamp: this.time,
        target: this,
        type: "disabled"
      };

      // Finally, trigger the 'disabled' event and then remove all listeners.
      this.emit("disabled", event);
      this.removeListener();

    });

  };

  /**
   * Returns the [`Input`](Input) object that matches the specified ID string or `false` if no
   * matching input is found. As per the Web MIDI API specification, IDs are strings (not integers).
   *
   * Please note that IDs change from one host to another. For example, Chrome does not use the same
   * kind of IDs as Jazz-Plugin.
   *
   * @param id {string} The ID string of the input. IDs can be viewed by looking at the
   * [`WebMidi.inputs`](WebMidi#inputs) array. Even though they sometimes look like integers, IDs
   * are strings.
   * @param [options] {object}
   * @param [options.disconnected] {boolean} Whether to retrieve a disconnected input
   *
   * @returns {Input} An [`Input`](Input) object matching the specified ID string or `undefined`
   * if no matching input can be found.
   *
   * @throws {Error} WebMidi is not enabled.
   *
   * @since 2.0.0
   */
  getInputById(id, options = {disconnected: false}) {

    if (this.validation) {
      if (!this.enabled) throw new Error("WebMidi is not enabled.");
      if (!id) return;
    }

    if (options.disconnected) {
      for (let i = 0; i < this._disconnectedInputs.length; i++) {
        if (this._disconnectedInputs[i].id === id.toString()) return this._disconnectedInputs[i];
      }
    } else {
      for (let i = 0; i < this.inputs.length; i++) {
        if (this.inputs[i].id === id.toString()) return this.inputs[i];
      }
    }

  };

  /**
   * Returns the first [`Input`](Input) object whose name **contains** the specified string. Note
   * that the port names change from one environment to another. For example, Chrome does not report
   * input names in the same way as the Jazz-Plugin does.
   *
   * @param name {string} The non-empty string to look for within the name of MIDI inputs (such as
   * those visible in the [inputs](WebMidi#inputs) array).
   *
   * @returns {Input} The [`Input`](Input) that was found or `undefined` if no input contained the
   * specified name.
   * @param [options] {object}
   * @param [options.disconnected] {boolean} Whether to retrieve a disconnected input
   *
   * @throws {Error} WebMidi is not enabled.
   *
   * @since 2.0.0
   */
  getInputByName(name, options = {disconnected: false}) {

    if (this.validation) {
      if (!this.enabled) throw new Error("WebMidi is not enabled.");
      if (!name) return;
      name = name.toString();
    }

    if (options.disconnected) {
      for (let i = 0; i < this._disconnectedInputs.length; i++) {
        if (~this._disconnectedInputs[i].name.indexOf(name)) return this._disconnectedInputs[i];
      }
    } else {
      for (let i = 0; i < this.inputs.length; i++) {
        if (~this.inputs[i].name.indexOf(name)) return this.inputs[i];
      }
    }

  };

  /**
   * Returns the first [`Output`](Output) object whose name **contains** the specified string. Note
   * that the port names change from one environment to another. For example, Chrome does not report
   * input names in the same way as the Jazz-Plugin does.
   *
   * @param name {string} The non-empty string to look for within the name of MIDI inputs (such as
   * those visible in the [`outputs`](#outputs) array).
   * @param [options] {object}
   * @param [options.disconnected] {boolean} Whether to retrieve a disconnected output
   *
   * @returns {Output} The [`Output`](Output) that was found or `undefined` if no output matched
   * the specified name.
   *
   * @throws {Error} WebMidi is not enabled.
   *
   * @since 2.0.0
   */
  getOutputByName(name, options = {disconnected: false}) {

    if (this.validation) {
      if (!this.enabled) throw new Error("WebMidi is not enabled.");
      if (!name) return;
      name = name.toString();
    }

    if (options.disconnected) {
      for (let i = 0; i < this._disconnectedOutputs.length; i++) {
        if (~this._disconnectedOutputs[i].name.indexOf(name)) return this._disconnectedOutputs[i];
      }
    } else {
      for (let i = 0; i < this.outputs.length; i++) {
        if (~this.outputs[i].name.indexOf(name)) return this.outputs[i];
      }
    }

  };

  /**
   * Returns the [`Output`](Output) object that matches the specified ID string or `false` if no
   * matching output is found. As per the Web MIDI API specification, IDs are strings (not
   * integers).
   *
   * Please note that IDs change from one host to another. For example, Chrome does not use the same
   * kind of IDs as Jazz-Plugin.
   *
   * @param id {string} The ID string of the port. IDs can be viewed by looking at the
   * [`WebMidi.outputs`](WebMidi#outputs) array.
   * @param [options] {object}
   * @param [options.disconnected] {boolean} Whether to retrieve a disconnected output
   *
   * @returns {Output} An [`Output`](Output) object matching the specified ID string. If no
   * matching output can be found, the method returns `undefined`.
   *
   * @throws {Error} WebMidi is not enabled.
   *
   * @since 2.0.0
   */
  getOutputById(id, options = {disconnected: false}) {

    if (this.validation) {
      if (!this.enabled) throw new Error("WebMidi is not enabled.");
      if (!id) return;
    }

    if (options.disconnected) {
      for (let i = 0; i < this._disconnectedOutputs.length; i++) {
        if (this._disconnectedOutputs[i].id === id.toString()) return this._disconnectedOutputs[i];
      }
    } else {
      for (let i = 0; i < this.outputs.length; i++) {
        if (this.outputs[i].id === id.toString()) return this.outputs[i];
      }
    }

  };

  /**
   * @private
   * @deprecated since version 3.0.0, use Utilities.toNoteNumber() instead.
   */
  noteNameToNumber(name) {
    if (this.validation) {
      console.warn(
        "The noteNameToNumber() method is deprecated. Use " +
        "Utilities.toNoteNumber() instead."
      );
    }
    return Utilities.toNoteNumber(name, this.octaveOffset);
  }

  /**
   * @private
   * @deprecated since 3.0.0, use Utilities.getNoteDetails() instead.
   */
  getOctave(number) {

    if (this.validation) {
      console.warn("The getOctave()is deprecated. Use Utilities.getNoteDetails() instead");
      number = parseInt(number);
    }

    if (!isNaN(number) && number >= 0 && number <= 127) {
      return Utilities.getNoteDetails(Utilities.offsetNumber(number, this.octaveOffset)).octave;
    } else {
      return false;
    }

  }

  /**
   * @private
   * @deprecated since 3.0.0, use Utilities.sanitizeChannels() instead.
   */
  sanitizeChannels(channel) {

    if (this.validation) {
      console.warn("The sanitizeChannels() method has been moved to the utilities class.");
    }

    return Utilities.sanitizeChannels(channel);

  }

  /**
   * @private
   * @deprecated since version 3.0.0, use Utilities.sanitizeChannels() instead.
   */
  toMIDIChannels(channel) {

    if (this.validation) {
      console.warn(
        "The toMIDIChannels() method has been deprecated. Use Utilities.sanitizeChannels() instead."
      );
    }

    return Utilities.sanitizeChannels(channel);

  }

  /**
   * @private
   * @deprecated since version 3.0.0, use Utilities.guessNoteNumber() instead.
   */
  guessNoteNumber(input) {

    if (this.validation) {
      console.warn(
        "The guessNoteNumber() method has been deprecated. Use Utilities.guessNoteNumber() instead."
      );
    }

    return Utilities.guessNoteNumber(input, this.octaveOffset);

  }

  /**
   * @private
   * @deprecated since version 3.0.0, use Utilities.buildNoteArray() instead.
   */
  getValidNoteArray(notes, options = {}) {
    if (this.validation) {
      console.warn(
        "The getValidNoteArray() method has been moved to the Utilities.buildNoteArray()"
      );
    }
    return Utilities.buildNoteArray(notes, options);
  }

  /**
   * @private
   * @deprecated since version 3.0.0, use Utilities.toTimestamp() instead.
   */
  convertToTimestamp(time) {

    if (this.validation) {
      console.warn(
        "The convertToTimestamp() method has been moved to Utilities.toTimestamp()."
      );
    }

    return Utilities.toTimestamp(time);

  }

  /**
   * @return {Promise<void>}
   * @private
   */
  async _destroyInputsAndOutputs() {

    let promises = [];

    this.inputs.forEach(input => promises.push(input.destroy()));
    this.outputs.forEach(output => promises.push(output.destroy()));

    return Promise.all(promises).then(() => {
      this._inputs = [];
      this._outputs = [];
    });

  }

  /**
   * @private
   */
  _onInterfaceStateChange(e) {

    this._updateInputsAndOutputs();

    /**
     * Event emitted when an [`Input`](Input) or [`Output`](Output) port is connected or
     * disconnected. This event is typically fired whenever a MIDI device is plugged in or
     * unplugged. Please note that it may fire several times if a device possesses multiple inputs
     * and/or outputs (which is often the case).
     *
     * @event WebMidi#portschanged
     * @type {object}
     * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred
     * (in milliseconds since the navigation start of the document).
     * @property {string} type `portschanged`
     * @property {WebMidi} target The object to which the listener was originally added (`WebMidi`)
     * @property {Input|Output} port The [`Input`](Input) or [`Output`](Output) object that
     * triggered the event.
     *
     * @since 3.0.2
     */

    /**
     * Event emitted when an [`Input`](Input) or [`Output`](Output) becomes available. This event is
     * typically fired whenever a MIDI device is plugged in. Please note that it may fire several
     * times if a device possesses multiple inputs and/or outputs (which is often the case).
     *
     * @event WebMidi#connected
     * @type {object}
     * @property {number} timestamp The moment (DOMHighResTimeStamp) when the event occurred
     * (in milliseconds since the navigation start of the document).
     * @property {string} type `connected`
     * @property {WebMidi} target The object to which the listener was originally added (`WebMidi`)
     * @property {Input|Output} port The [`Input`](Input) or [`Output`](Output) object that
     * triggered the event.
     */

    /**
     * Event emitted when an [`Input`](Input) or [`Output`](Output) becomes unavailable. This event
     * is typically fired whenever a MIDI device is unplugged. Please note that it may fire several
     * times if a device possesses multiple inputs and/or outputs (which is often the case).
     *
     * @event WebMidi#disconnected
     * @type {object}
     * @property {DOMHighResTimeStamp} timestamp The moment when the event occurred (in milliseconds
     * since the navigation start of the document).
     * @property {string} type `disconnected`
     * @property {WebMidi} target The object to which the listener was originally added (`WebMidi`)
     * @property {Input|Output} port The [`Input`](Input) or [`Output`](Output) object that
     * triggered the event.
     */
    let event = {
      timestamp: e.timeStamp,
      type: e.port.state,
      target: this
    };

    // We check if "connection" is "open" because connected events are also triggered with
    // "connection=closed"
    if (e.port.state === "connected" && e.port.connection === "open") {

      if (e.port.type === "output") {
        event.port = this.getOutputById(e.port.id);
      } else if (e.port.type === "input") {
        event.port = this.getInputById(e.port.id);
      }

      // Emit "connected" event
      this.emit(e.port.state, event);

      // Make a shallow copy of the event so we can use it for the "portschanged" event
      const portsChangedEvent = Object.assign({}, event);
      portsChangedEvent.type = "portschanged";
      this.emit(portsChangedEvent.type, portsChangedEvent);

    // We check if "connection" is "pending" because we do not always get the "closed" event
    } else if (e.port.state === "disconnected" && e.port.connection === "pending") {

      if (e.port.type === "input") {
        event.port = this.getInputById(e.port.id, {disconnected: true});
      } else if (e.port.type === "output") {
        event.port = this.getOutputById(e.port.id, {disconnected: true});
      }

      // Emit "disconnected" event
      this.emit(e.port.state, event);

      // Make a shallow copy of the event so we can use it for the "portschanged" event
      const portsChangedEvent = Object.assign({}, event);
      portsChangedEvent.type = "portschanged";
      this.emit(portsChangedEvent.type, portsChangedEvent);

    }

  };

  /**
   * @private
   */
  async _updateInputsAndOutputs() {

    return Promise.all([
      this._updateInputs(),
      this._updateOutputs()
    ]);

  };

  /**
   * @private
   */
  async _updateInputs() {

    // We must check for the existence of this.interface because it might have been closed via
    // WebMidi.disable().
    if (!this.interface) return;

    // Check for items to remove from the existing array (because they are no longer being reported
    // by the MIDI back-end).
    for (let i = this._inputs.length - 1; i >= 0; i--) {
      const current = this._inputs[i];
      const inputs = Array.from(this.interface.inputs.values());
      if (! inputs.find(input => input === current._midiInput)) {
        // Instead of destroying removed inputs, we stash them in case they come back (which is the
        // case when the computer goes to sleep and is later brought back online).
        this._disconnectedInputs.push(current);
        this._inputs.splice(i, 1);
      }
    }

    // Array to hold pending promises from trying to open all input ports
    let promises = [];

    // Add new inputs (if not already present)
    this.interface.inputs.forEach(nInput => {

      // Check if the input is currently absent from the 'inputs' array.
      if (! this._inputs.find(input => input._midiInput === nInput) ) {

        // If the input has previously been stashed away, reuse it. If not, create a new one.
        let input = this._disconnectedInputs.find(input => input._midiInput === nInput);
        if (!input) input = new Input(nInput);
        this._inputs.push(input);
        promises.push(input.open());

      }

    });

    // Return a promise that resolves when all promises have resolved
    return Promise.all(promises);

  };

  /**
   * @private
   */
  async _updateOutputs() {

    // We must check for the existence of this.interface because it might have been closed via
    // WebMidi.disable().
    if (!this.interface) return;

    // Check for items to remove from the existing array (because they are no longer being reported
    // by the MIDI back-end).
    for (let i = this._outputs.length - 1; i >= 0; i--) {
      const current = this._outputs[i];
      const outputs = Array.from(this.interface.outputs.values());
      if (! outputs.find(output => output === current._midiOutput)) {
        // Instead of destroying removed inputs, we stash them in case they come back (which is the
        // case when the computer goes to sleep and is later brought back online).
        this._disconnectedOutputs.push(current);
        this._outputs.splice(i, 1);
      }
    }

    // Array to hold pending promises from trying to open all output ports
    let promises = [];

    // Add new outputs (if not already present)
    this.interface.outputs.forEach(nOutput => {

      // Check if the output is currently absent from the 'outputs' array.
      if (! this._outputs.find(output => output._midiOutput === nOutput) ) {

        // If the output has previously been stashed away, reuse it. If not, create a new one.
        let output = this._disconnectedOutputs.find(output => output._midiOutput === nOutput);
        if (!output) output = new Output(nOutput);
        this._outputs.push(output);
        promises.push(output.open());

      }

    });

    // Return a promise that resolves when all sub-promises have resolved
    return Promise.all(promises);

  };

  // injectPluginMarkup(parent) {
  //
  //   // Silently ignore on Node.js
  //   if (Utilities.isNode) return;
  //
  //   // Default to <body> if no parent is specified
  //   if (!(parent instanceof Element) && !(parent instanceof HTMLDocument)) {
  //     parent = document.body;
  //   }
  //
  //   // IE10 needs this:
  //   // <meta http-equiv="X-UA-Compatible" content="requiresActiveX=true"/>
  //
  //   // Create markup and add to parent
  //   const obj = document.createElement("object");
  //   obj.classid = "CLSID:1ACE1618-1C7D-4561-AEE1-34842AA85E90"; // IE
  //   if (!obj.isJazz) obj.type = "audio/x-jazz";                 // Standards-compliant
  //   obj.style.visibility = "hidden";
  //   obj.style.width = obj.style.height = "0px";
  //   parent.appendChild(obj);
  //
  // }

  /**
   * Indicates whether access to the host's MIDI subsystem is active or not.
   *
   * @readonly
   * @type {boolean}
   */
  get enabled() {
    return this.interface !== null;
  }

  /**
   * An array of all currently available MIDI inputs.
   *
   * @readonly
   * @type {Input[]}
   */
  get inputs() {
    return this._inputs;
  }

  /**
   * @private
   * @deprecated
   */
  get isNode() {

    if (this.validation) {
      console.warn("WebMidi.isNode has been deprecated. Use Utilities.isNode instead.");
    }

    return Utilities.isNode;

  }

  /**
   * @private
   * @deprecated
   */
  get isBrowser() {

    if (this.validation) {
      console.warn("WebMidi.isBrowser has been deprecated. Use Utilities.isBrowser instead.");
    }

    return Utilities.isBrowser;

  }

  /**
   * An integer to offset the octave of notes received from external devices or sent to external
   * devices.
   *
   * When a MIDI message comes in on an input channel the reported note name will be offset. For
   * example, if the `octaveOffset` is set to `-1` and a [`"noteon"`](InputChannel#event:noteon)
   * message with MIDI number 60 comes in, the note will be reported as C3 (instead of C4).
   *
   * By the same token, when [`OutputChannel.playNote()`](OutputChannel#playNote) is called, the
   * MIDI note number being sent will be offset. If `octaveOffset` is set to `-1`, the MIDI note
   * number sent will be 72 (instead of 60).
   *
   * @type {number}
   *
   * @since 2.1
   */
  get octaveOffset() {
    return this._octaveOffset;
  }
  set octaveOffset(value) {

    if (this.validation) {
      value = parseInt(value);
      if (isNaN(value)) throw new TypeError("The 'octaveOffset' property must be an integer.");
    }

    this._octaveOffset = value;

  }

  /**
   * An array of all currently available MIDI outputs as [`Output`](Output) objects.
   *
   * @readonly
   * @type {Output[]}
   */
  get outputs() {
    return this._outputs;
  }

  /**
   * Indicates whether the environment provides support for the Web MIDI API or not.
   *
   * **Note**: in environments that do not offer built-in MIDI support, this will report `true` if
   * the
   * [`navigator.requestMIDIAccess`](https://developer.mozilla.org/en-US/docs/Web/API/MIDIAccess)
   * function is available. For example, if you have installed WebMIDIAPIShim.js but no plugin, this
   * property will be `true` even though actual support might not be there.
   *
   * @readonly
   * @type {boolean}
   */
  get supported() {
    return (typeof navigator !== "undefined" && !!navigator.requestMIDIAccess);
  }

  /**
   * Indicates whether MIDI system exclusive messages have been activated when WebMidi.js was
   * enabled via the [`enable()`](#enable) method.
   *
   * @readonly
   * @type boolean
   */
  get sysexEnabled() {
    return !!(this.interface && this.interface.sysexEnabled);
  }

  /**
   * The elapsed time, in milliseconds, since the time
   * [origin](https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp#The_time_origin).
   * Said simply, it is the number of milliseconds that passed since the page was loaded. Being a
   * floating-point number, it has sub-millisecond accuracy. According to the
   * [documentation](https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp), the
   * time should be accurate to 5 s (microseconds). However, due to various constraints, the
   * browser might only be accurate to one millisecond.
   *
   * Note: `WebMidi.time` is simply an alias to `performance.now()`.
   *
   * @type {DOMHighResTimeStamp}
   * @readonly
   */
  get time() {
    return performance.now();
  }

  /**
   * The version of the library as a [semver](https://semver.org/) string.
   *
   * @readonly
   * @type string
   */
  get version() {
    return "3.1.12";
  }

  /**
   * The flavour of the library. Can be one of:
   *
   * * `esm`: ECMAScript Module
   * * `cjs`: CommonJS Module
   * * `iife`: Immediately-Invoked Function Expression
   *
   * @readonly
   * @type string
   * @since 3.0.25
   */
  get flavour() {
    return "esm"; // will be replaced during bundling by the correct identifier
  }

  /**
   * @private
   * @deprecated since 3.0.0. Use Enumerations.CHANNEL_EVENTS instead.
   */
  get CHANNEL_EVENTS() {
    if (this.validation) {
      console.warn(
        "The CHANNEL_EVENTS enum has been moved to Enumerations.CHANNEL_EVENTS."
      );
    }
    return Enumerations.CHANNEL_EVENTS;
  }

  /**
   * @private
   * @deprecated since 3.0.0. Use Enumerations.SYSTEM_MESSAGES instead.
   */
  get MIDI_SYSTEM_MESSAGES() {

    if (this.validation) {
      console.warn(
        "The MIDI_SYSTEM_MESSAGES enum has been moved to " +
        "Enumerations.SYSTEM_MESSAGES."
      );
    }

    return Enumerations.SYSTEM_MESSAGES;

  }

  /**
   * @private
   * @deprecated since 3.0.0. Use Enumerations.CHANNEL_MODE_MESSAGES instead
   */
  get MIDI_CHANNEL_MODE_MESSAGES() {

    if (this.validation) {
      console.warn(
        "The MIDI_CHANNEL_MODE_MESSAGES enum has been moved to " +
        "Enumerations.CHANNEL_MODE_MESSAGES."
      );
    }

    return Enumerations.CHANNEL_MODE_MESSAGES;

  }

  /**
   * @private
   * @deprecated since 3.0.0. Use Enumerations.CONTROL_CHANGE_MESSAGES instead.
   */
  get MIDI_CONTROL_CHANGE_MESSAGES() {

    if (this.validation) {
      console.warn(
        "The MIDI_CONTROL_CHANGE_MESSAGES enum has been replaced by the " +
        "Enumerations.CONTROL_CHANGE_MESSAGES array."
      );
    }

    return Enumerations.MIDI_CONTROL_CHANGE_MESSAGES;

  }

  /**
   * @deprecated since 3.0.0. Use Enumerations.REGISTERED_PARAMETERS instead.
   * @private
   */
  get MIDI_REGISTERED_PARAMETER() {

    if (this.validation) {
      console.warn(
        "The MIDI_REGISTERED_PARAMETER enum has been moved to " +
        "Enumerations.REGISTERED_PARAMETERS."
      );
    }

    return Enumerations.REGISTERED_PARAMETERS;

  }

  /**
   * @deprecated since 3.0.0.
   * @private
   */
  get NOTES() {

    if (this.validation) {
      console.warn("The NOTES enum has been deprecated.");
    }

    return ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

  }

}

// Export singleton instance of WebMidi class. The 'constructor' is nulled so that it cannot be used
// to instantiate a new WebMidi object or extend it. However, it is not freezed so it remains
// extensible (properties can be added at will).
const wm = new WebMidi();
wm.constructor = null;

// cabbages.ts
function pojo(target) {
  return typeof target == "object" && typeof target != null && Object.getPrototypeOf(target) == Object.prototype;
}
function apply(path, target, range, val, reviver) {
  let originalObject = target;
  let p = [...path];
  while (true) {
    let key = p.shift();
    if (!p.length) {
      if (typeof reviver == "function") {
        val = reviver(val, key, target, path, originalObject, range);
      }
      const RANGE_ARRAY = Array.isArray(range);
      if (pojo(target) && RANGE_ARRAY && typeof key == "undefined" && typeof range[0] == "string") {
        delete target[range[0]];
        return;
      }
      if (RANGE_ARRAY || typeof range == "number") {
        if (typeof key == "undefined") {
          throw new Error("cant treat top level as a seq");
        }
        key = key;
        let [start, end] = Array.isArray(range) ? range : [range, range + 1];
        const ZERO_LENGTH = Array.isArray(range) && range.length == 0;
        if (!ZERO_LENGTH && (start == null || end == null)) {
          throw new RangeError("it's all or nothing, no half measures");
        }
        const DELETE = typeof val == "undefined";
        const INSERT = start === end && !DELETE;
        const APPEND = ZERO_LENGTH && !DELETE;
        let op = DELETE ? "del" : APPEND ? "add" : INSERT ? "ins" : "replace";
        if (typeof target[key] == "undefined") {
          if (typeof val == "string") {
            target[key] = "";
          } else {
            target[key] = [];
          }
        }
        let seq = target[key];
        if (Array.isArray(seq)) {
          switch (op) {
            case "add": {
              Array.isArray(val) ? seq.push(...val) : seq.push(val);
              return;
            }
            case "replace":
            case "ins": {
              Array.isArray(val) ? seq.splice(start, end - start, ...val) : seq.splice(start, end - start, val);
              return;
            }
            case "del": {
              seq.splice(start, end - start);
              return;
            }
            default: {
              throw new Error("i don't know what happened");
            }
          }
        }
        if (typeof seq == "string") {
          switch (op) {
            case "add": {
              target[key] = seq + val;
              return;
            }
            case "replace":
            case "ins": {
              target[key] = seq.slice(0, start) + (typeof val == "string" ? val : val.join("")) + seq.slice(end);
              return;
            }
            case "del": {
              target[key] = seq.slice(0, start) + seq.slice(end);
              return;
            }
            default: {
              throw new Error("i don't know what happened");
            }
          }
        }
        if (pojo(seq) && RANGE_ARRAY && typeof range[0] == "string") {
          delete seq[range[0]];
        }
        throw new Error("not implemented");
      }
      if (typeof key == "undefined") {
        if (typeof range != "string") {
          throw new Error(`can't index top-level map with ${range}`);
        }
        if (typeof val == "undefined") {
          delete target[range];
        } else {
          target[range] = val;
        }
        return;
      }
      if (typeof target[key] == "undefined") {
        target[key] = {};
      }
      if (RANGE_ARRAY) {
        let [a, b] = range;
        if (a != null && b != null) {
          if (typeof val == "undefined" && a != null && b != null) {
            delete target[key][a || b];
          } else {
            target[key][a || b] = val;
          }
        }
      } else {
        if (typeof val == "undefined") {
          delete target[key][range];
        } else {
          target[key][range] = val;
        }
      }
      return;
    }
    if (typeof key == "undefined") {
      throw new Error("cant treat top level as a seq");
    }
    key = key;
    let nextkey = p[0];
    if (typeof target[key] == "undefined") {
      if (typeof nextkey == "string") {
        target[key] = {};
      } else if (typeof nextkey == "number") {
        target[key] = [];
      } else {
        throw new Error(`can't go down this road ${target}.${key}.${nextkey}`);
      }
    }
    target = target[key];
  }
}
var OperationError = class extends Error {
};
function fromAutomerge(autopatch) {
  let path = autopatch.path.slice(0, -1);
  let key = autopatch.path[autopatch.path.length - 1];
  switch (autopatch.action) {
    case "conflict":
    case "inc":
    case "mark":
    case "unmark":
      throw new OperationError(`can't handle this: ${autopatch.action}`);
    case "del": {
      return typeof key == "string" ? [path, key] : [path, [key, key + (autopatch.length || 1)]];
    }
    case "insert": {
      return [path, [key, key], autopatch.values];
    }
    case "splice": {
      return [path, [key, key], [autopatch.value]];
    }
    case "put": {
      return [path, key, autopatch.value];
    }
  }
}

function autoproduce(patches) {
  return produce((doc) => {
    for (let patch of patches) {
      const [path, range, val] = fromAutomerge(patch);
      apply(path, doc, range, val);
    }
  });
}
function createDocumentStore({
  initialValue,
  url,
  repo
}) {
  let owner = getOwner();
  const [handle, setHandle] = createSignal(
    isValidAutomergeUrl(url) ? repo.find(url) : repo.create(initialValue)
  );
  let [document] = createResource(
    handle,
    async (handle2) => {
      await handle2.whenReady();
      let [document2, update] = createStore(handle2.docSync());
      function patch(payload) {
        update(autoproduce(payload.patches));
      }
      handle2.on("change", patch);
      runWithOwner(owner, () => onCleanup(() => handle2.off("change", patch)));
      return document2;
    },
    {
      initialValue: handle().docSync() ?? initialValue
    }
  );
  let queue = [];
  createEffect(async () => {
    await handle().whenReady();
    if (handle()) {
      let next;
      while (next = queue.shift()) {
        handle().change(next);
      }
    } else {
      queue = [];
    }
  });
  return {
    document,
    setDocument(fn) {
      if (handle().isReady()) {
        handle().change(fn);
      } else {
        queue.push(fn);
      }
    },
    async newDocument() {
      setHandle(repo.create(initialValue));
    },
    url() {
      return handle().url;
    },
    async openUrl(url2) {
      if (!isValidAutomergeUrl(url2)) {
        throw `Url is not a valid automerge url`;
      }
      setHandle(repo.find(url2));
    }
  };
}

const pointerHelper = (e, callback) => {
  return new Promise((resolve) => {
    const start = {
      x: e.clientX,
      y: e.clientY
    };
    const startTime = performance.now();
    let previousDelta = {
      x: 0,
      y: 0
    };
    function getDataFromPointerEvent(event) {
      const delta = {
        x: event.clientX - start.x,
        y: event.clientY - start.y
      };
      const movement = {
        x: delta.x - previousDelta.x,
        y: delta.y - previousDelta.y
      };
      previousDelta = delta;
      return {
        delta: {
          x: event.clientX - start.x,
          y: event.clientY - start.y
        },
        movement,
        event,
        time: performance.now() - startTime
      };
    }
    const onPointerMove = (event) => {
      callback?.(getDataFromPointerEvent(event));
    };
    const onPointerUp = (event) => {
      window.removeEventListener("pointermove", onPointerMove);
      window.removeEventListener("pointerup", onPointerUp);
      const data = getDataFromPointerEvent(event);
      callback?.(data);
      resolve(data);
    };
    window.addEventListener("pointermove", onPointerMove);
    window.addEventListener("pointerup", onPointerUp);
  });
};

const KEY_COLORS = [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1].reverse();
const HEIGHT = 20;
const WIDTH = 60;
const MARGIN = 2;
const VELOCITY = 4;
function serializeDate() {
  const now2 = /* @__PURE__ */ new Date();
  const year = now2.getFullYear();
  const month = now2.getMonth() + 1;
  const date = now2.getDate();
  const hours = now2.getHours();
  const minutes = now2.getMinutes();
  const seconds = now2.getSeconds();
  const milliSeconds = now2.getMilliseconds();
  const serialized = `${year}${month.toString().padStart(2, "0")}${date.toString().padStart(2, "0")}${hours.toString().padStart(2, "0")}${minutes.toString().padStart(2, "0")}${seconds.toString().padStart(2, "0")}${milliSeconds.toString().padStart(4, "0")}`;
  return Number(serialized);
}
function deserializeDate(serialized) {
  const str = serialized.toString();
  const year = str.slice(0, 4);
  const month = str.slice(4, 6);
  const date = str.slice(6, 8);
  const hours = str.slice(8, 10);
  const minutes = str.slice(10, 12);
  const seconds = str.slice(12, 14);
  const milliseconds = str.slice(14, 18);
  return `${year}-${month}-${date}-${hours}-${minutes}-${seconds}-${milliseconds}`;
}
const repo = new Repo({
  network: [new BrowserWebSocketClientAdapter("wss://sync.cyberspatialstudies.org")],
  storage: new IndexedDBStorageAdapter()
});
const {
  document: doc,
  setDocument: setDoc,
  newDocument: newDoc,
  url,
  openUrl
} = createRoot(
  () => createDocumentStore({
    repo,
    url: `${document.location.hash.substring(1)}`,
    initialValue: {
      notes: [],
      instrument: 24,
      bpm: 140,
      get date() {
        return serializeDate();
      }
    }
  })
);
const [urls, setUrls] = makePersisted(createSignal({}));
createRoot(() => {
  createEffect(() => {
    document.location.hash = url();
  });
  createEffect(() => {
    if (doc().date && doc().notes.length > 0) {
      setUrls((urls2) => ({
        ...urls2,
        [url()]: doc().date
      }));
    }
  });
});
const [midiOutputEnabled, setMidiOutputEnabled] = createSignal(false);
const [midiOutputs] = createResource(midiOutputEnabled, async () => {
  await wm.enable();
  return wm.outputs;
});
const [selectedMidiOutputs, setSelectedMidiOutputs] = createSignal([]);
let audioContext;
let player;
let playedNotes = /* @__PURE__ */ new Set();
const [mode, setMode] = createSignal("note");
const [dimensions, setDimensions] = createSignal();
const [timeScale, setTimeScale] = createSignal(1);
const [selectedNotes, setSelectedNotes] = createSignal([]);
const [selectionArea, setSelectionArea] = createSignal();
const [selectionPresence, setSelectionPresence] = createSignal();
const [clipboard, setClipboard] = createSignal();
const [playing, setPlaying] = createSignal(false);
const [internalTimeOffset, setInternalTimeOffset] = createSignal(0);
const [playingNotes, setPlayingNotes] = createStore([]);
const [now, setNow] = createSignal(0);
const [loop, setLoop] = createStore({ time: 0, duration: 4 });
const [volume, setVolume] = createSignal(10);
const [origin, setOrigin] = createSignal({ x: 0, y: 6 * HEIGHT * 12 });
const [zoom, setZoom] = createSignal({ x: 1, y: 1 });
const projectedWidth = () => WIDTH * zoom().x;
const projectedHeight = () => HEIGHT * zoom().y;
const projectedOrigin = createMemo(() => {
  return {
    x: WIDTH + origin().x * zoom().x,
    y: origin().y * zoom().y
  };
});
const [isNoteSelected, isNotePlaying, isPitchPlaying] = createRoot(() => [
  createSelector(
    selectedNotes,
    (note, selectedNotes2) => !!selectedNotes2.find(filterNote(note))
  ),
  createSelector(
    () => playingNotes,
    (note, playingNotes2) => !!playingNotes2.find(filterNote(note))
  ),
  createSelector(
    () => playingNotes,
    (pitch, playingNotes2) => !!playingNotes2.find((note) => note.pitch === pitch)
  )
]);
function normalizeVector(value) {
  return {
    x: Math.floor(value.x / projectedWidth() / timeScale()) * timeScale(),
    y: Math.floor(value.y / projectedHeight())
  };
}
function filterNote(...notes) {
  return ({ id }) => !!notes.find((note) => note.id === id);
}
function selectNotesFromSelectionArea(area) {
  setSelectedNotes(
    doc().notes.filter((note) => {
      const noteStartTime = note.time;
      const noteEndTime = note.time + note.duration;
      const isWithinXBounds = noteStartTime < area.end.x && noteEndTime > area.start.x;
      const isWithinYBounds = -note.pitch >= area.start.y && -note.pitch < area.end.y;
      return isWithinXBounds && isWithinYBounds;
    })
  );
}
function play() {
  if (!audioContext) {
    audioContext = new AudioContext();
  } else setInternalTimeOffset(audioContext.currentTime * VELOCITY - now());
  setPlaying(true);
}
function togglePlaying() {
  if (!playing()) {
    play();
  } else {
    setPlaying(false);
  }
}
function playNote(note, delay = 0) {
  if (!player) {
    player = new Instruments();
  }
  if (note.velocity === 0) {
    return;
  }
  player.play(
    doc().instrument,
    // instrument: 24 is "Acoustic Guitar (nylon)"
    note.pitch,
    // note: midi number or frequency in Hz (if > 127)
    // NOTE: later commit should use GainNode to change volume
    note.velocity * (volume() / 10),
    // velocity
    delay,
    // delay
    note.duration / (doc().bpm / 60),
    // duration
    0,
    // (optional - specify channel for tinysynth to use)
    0.05
    // (optional - override envelope "attack" parameter)
  );
  selectedMidiOutputs().forEach((output) => {
    output.playNote(note.pitch, {
      duration: note.duration / (doc().bpm / 60) * 1e3 - 100,
      time: `+${delay * 1e3}`
    });
  });
  setTimeout(() => {
    setPlayingNotes(produce((pitches) => pitches.push({ ...note })));
    setTimeout(
      () => {
        setPlayingNotes(
          produce((pitches) => {
            pitches.splice(pitches.findIndex(filterNote(note)), 1);
          })
        );
      },
      note.duration / VELOCITY * 1e3
    );
  }, delay * 1e3);
}
async function handleCreateNote(event) {
  const absolutePosition = {
    x: event.layerX - projectedOrigin().x,
    y: event.layerY - projectedOrigin().y
  };
  const note = {
    id: get(),
    active: true,
    duration: timeScale(),
    pitch: Math.floor(-absolutePosition.y / projectedHeight()) + 1,
    time: Math.floor(absolutePosition.x / projectedWidth() / timeScale()) * timeScale(),
    velocity: 1
  };
  setDoc((doc2) => {
    doc2.notes.push(note);
  });
  const initialTime = note.time;
  const initialDuration = note.duration;
  const offset = absolutePosition.x - initialTime * projectedWidth();
  setSelectedNotes([note]);
  await pointerHelper(event, ({ delta }) => {
    const deltaX = Math.floor((offset + delta.x) / projectedWidth() / timeScale()) * timeScale();
    if (deltaX < 0) {
      setDoc((doc2) => {
        const _note = doc2.notes.find(filterNote(note));
        if (!_note) return;
        _note.time = initialTime + deltaX;
        _note.duration = 1 - deltaX;
      });
    } else if (deltaX > 0) {
      setDoc((doc2) => {
        const _note = doc2.notes.find(filterNote(note));
        if (!_note) return;
        _note.duration = initialDuration + deltaX;
      });
    } else {
      setDoc((doc2) => {
        const _note = doc2.notes.find(filterNote(note));
        if (!_note) return;
        _note.time = initialTime;
        _note.duration = timeScale();
      });
    }
    markOverlappingNotes(note);
  });
  setSelectedNotes([]);
  clipOverlappingNotes(note);
}
async function handleSelectionBox(event) {
  const offset = event.currentTarget.getBoundingClientRect().left;
  const position = {
    x: event.clientX - projectedOrigin().x - offset,
    y: event.clientY - projectedOrigin().y
  };
  const normalizedPosition = normalizeVector(position);
  setSelectionArea({
    start: normalizedPosition,
    end: {
      x: normalizedPosition.x + timeScale() * zoom().x,
      y: normalizedPosition.y
    }
  });
  setSelectionPresence(normalizedPosition);
  await pointerHelper(event, ({ delta }) => {
    const newPosition = normalizeVector({
      x: position.x + delta.x,
      y: position.y + delta.y + 1
    });
    const area = {
      start: {
        x: delta.x < 0 ? newPosition.x : normalizedPosition.x,
        y: delta.y < 0 ? newPosition.y : normalizedPosition.y
      },
      end: {
        x: (delta.x > 0 ? newPosition.x : normalizedPosition.x) + timeScale(),
        y: (delta.y > 0 ? newPosition.y : normalizedPosition.y) + 1
      }
    };
    selectNotesFromSelectionArea(area);
    setSelectionArea(area);
    setSelectionPresence(newPosition);
  });
}
async function handlePan(event) {
  const initialOrigin = { ...origin() };
  await pointerHelper(event, ({ delta }) => {
    setOrigin({
      x: initialOrigin.x + delta.x / zoom().x,
      y: initialOrigin.y + delta.y / zoom().y
    });
  });
}
function copyNotes() {
  let offset = Infinity;
  selectedNotes().forEach((note) => {
    if (note.time < offset) {
      offset = note.time;
    }
  });
  setClipboard(
    selectedNotes().map((note) => ({
      ...note,
      id: get(),
      time: note.time - offset
    }))
  );
}
function pasteNotes(clipboard2, position) {
  const newNotes = clipboard2.map((note) => ({
    ...note,
    time: note.time + position.x,
    id: get()
  })).filter(
    (note) => !doc().notes.find(({ pitch, time }) => note.pitch === pitch && note.time === time)
  );
  setDoc((doc2) => doc2.notes.push(...newNotes));
  clipOverlappingNotes(...newNotes);
}
function findSourceIntersectingAndBeforeNote(sources, { id, time, pitch }) {
  if (sources.find((source) => source.id === id)) {
    return;
  }
  return sources.find(
    (source) => source.pitch === pitch && id !== source.id && source.time < time && source.time + source.duration > time
  );
}
function findSourceIntersectingAndAfterNote(sources, { id, time, duration, pitch }) {
  if (sources.find((source) => source.id === id)) {
    return;
  }
  return sources.find(
    (source) => source.pitch === pitch && id !== source.id && source.time >= time && source.time <= time + duration
  );
}
function clipOverlappingNotes(...sources) {
  sources.sort((a, b) => a.time < b.time ? -1 : 1);
  setDoc((doc2) => {
    for (let index = doc2.notes.length - 1; index >= 0; index--) {
      const note = doc2.notes[index];
      if (findSourceIntersectingAndBeforeNote(sources, note)) {
        doc2.notes.splice(index, 1);
      }
    }
  });
  setDoc(
    (doc2) => doc2.notes.forEach((note, index) => {
      const source = findSourceIntersectingAndAfterNote(sources, note);
      if (source) {
        doc2.notes[index].duration = source.time - note.time;
      }
    })
  );
  setDoc((doc2) => {
    for (let index = doc2.notes.length - 1; index >= 0; index--) {
      const note = doc2.notes[index];
      if (note.duration === 0) {
        doc2.notes.splice(index, 1);
      }
    }
  });
  sources.forEach((note, index) => {
    while (index + 1 < sources.length) {
      const source = sources[index + 1];
      if (source.pitch !== note.pitch) {
        index++;
        continue;
      }
      if (source.time < note.time + note.duration) {
        setDoc((doc2) => {
          doc2.notes.forEach((_note) => {
            if (_note.id === note.id) {
              _note.duration = source.time - note.time;
            }
          });
        });
      }
      break;
    }
  });
  setDoc((doc2) => {
    doc2.notes.forEach((note) => {
      delete note._duration;
      delete note._remove;
    });
  });
}
function markOverlappingNotes(...sources) {
  sources.sort((a, b) => a.time < b.time ? -1 : 1);
  batch(() => {
    setDoc(
      (doc2) => doc2.notes.forEach((note) => {
        if (findSourceIntersectingAndBeforeNote(sources, note)) {
          note._remove = true;
        } else {
          delete note._remove;
        }
      })
    );
    setDoc(
      (doc2) => doc2.notes.forEach((note, index) => {
        const source = findSourceIntersectingAndAfterNote(sources, note);
        if (source) {
          doc2.notes[index]._duration = source.time - note.time;
        } else {
          delete doc2.notes[index]._duration;
        }
      })
    );
    sources.forEach((source, index) => {
      const end = source.time + source.duration;
      while (index + 1 < sources.length) {
        if (sources[index + 1].pitch !== source.pitch) {
          index++;
          continue;
        }
        if (sources[index + 1].time <= end) {
          setDoc((doc2) => {
            doc2.notes.forEach((note) => {
              if (note.id === source.id) {
                note._duration = sources[index + 1].time - source.time;
              }
            });
          });
          break;
        }
        setDoc((doc2) => {
          doc2.notes.forEach((note) => {
            if (note.id === source.id) {
              delete note._duration;
            }
          });
        });
        break;
      }
    });
  });
}

function downloadDataUri(dataUri, filename) {
  const link = document.createElement("a");
  link.href = dataUri;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

function mod(n, m) {
  return (n % m + m) % m;
}

var _tmpl$$i = /* @__PURE__ */ template(`<svg viewBox="0 0 24 24"width=1.2em height=1.2em><path fill=none stroke=currentColor stroke-width=2 d="M18 12.4H6M11.4 7L6 12.4l5.4 5.4">`);
const IconGrommetIconsFormPreviousLink = (props = {}) => (() => {
  var _el$ = _tmpl$$i();
  spread(_el$, props, true, true);
  return _el$;
})();

var _tmpl$$h = /* @__PURE__ */ template(`<svg viewBox="0 0 24 24"width=1.2em height=1.2em><path fill=none stroke=currentColor stroke-width=2 d="M6 12.4h12M12.6 7l5.4 5.4l-5.4 5.4">`);
const IconGrommetIconsFormNextLink = (props = {}) => (() => {
  var _el$ = _tmpl$$h();
  spread(_el$, props, true, true);
  return _el$;
})();

var _tmpl$$g = /* @__PURE__ */ template(`<svg viewBox="0 0 24 24"width=1.2em height=1.2em><path fill=none stroke=currentColor stroke-width=2 d="M4.5 17H1V1h16v3.5M7 7h16v16H7zm8 4v8zm-4 4h8z">`);
const IconGrommetIconsDuplicate = (props = {}) => (() => {
  var _el$ = _tmpl$$g();
  spread(_el$, props, true, true);
  return _el$;
})();

var _tmpl$$f = /* @__PURE__ */ template(`<svg viewBox="0 0 24 24"width=1.2em height=1.2em><path fill=none stroke=currentColor stroke-width=2 d="M13 20c6-1 8-6 8-10m-7 6l-2 4l4 3M0 9l4-3l3 4m2 10c-6-3-7-8-5-14m16 1C16 1 10 1 6 4.006M20 2v5h-5">`);
const IconGrommetIconsCycle = (props = {}) => (() => {
  var _el$ = _tmpl$$f();
  spread(_el$, props, true, true);
  return _el$;
})();

var _tmpl$$e = /* @__PURE__ */ template(`<svg viewBox="0 0 24 24"width=1.2em height=1.2em><path fill=none stroke=currentColor stroke-width=2 d="M1 17.998C1 16.894 1.887 16 2.998 16H9v4.002A1.993 1.993 0 0 1 7.002 22H2.998A2 2 0 0 1 1 20.002zm14 0c0-1.104.887-1.998 1.998-1.998H23v4.002A1.993 1.993 0 0 1 21.002 22h-4.004A2 2 0 0 1 15 20.002zM9 16V2h14v13.5M9 6h14">`);
const IconGrommetIconsMusic = (props = {}) => (() => {
  var _el$ = _tmpl$$e();
  spread(_el$, props, true, true);
  return _el$;
})();

var _tmpl$$d = /* @__PURE__ */ template(`<svg viewBox="0 0 24 24"width=1.2em height=1.2em><path fill=none stroke=currentColor stroke-width=2 d="M8 1h6zm11.188 18.472L16 22l-3.5-4.5l-3 3.5L7 7l13 6.5l-4.5 1.5zM19 4V1h-3M6 1H3v3m0 10v3h3M19 6v4zM3 12V6z">`);
const IconGrommetIconsSelect = (props = {}) => (() => {
  var _el$ = _tmpl$$d();
  spread(_el$, props, true, true);
  return _el$;
})();

var _tmpl$$c = /* @__PURE__ */ template(`<svg viewBox="0 0 24 24"width=1.2em height=1.2em><path fill=none stroke=currentColor stroke-width=2 d="M12 0v24M2 12h10m10 0H12M6 8l-4 4l4 4m12-8l4 4l-4 4">`);
const IconGrommetIconsShift = (props = {}) => (() => {
  var _el$ = _tmpl$$c();
  spread(_el$, props, true, true);
  return _el$;
})();

var _tmpl$$b = /* @__PURE__ */ template(`<svg viewBox="0 0 24 24"width=1.2em height=1.2em><path fill=none stroke=currentColor stroke-width=2 d="M12 18a6 6 0 1 0 0-12a6 6 0 0 0 0 12ZM8 8l3 3m1 11a9.99 9.99 0 0 0 8.307-4.43A9.95 9.95 0 0 0 22 12c0-5.523-4.477-10-10-10S2 6.477 2 12">`);
const IconGrommetIconsVolumeControl = (props = {}) => (() => {
  var _el$ = _tmpl$$b();
  spread(_el$, props, true, true);
  return _el$;
})();

var _tmpl$$a = /* @__PURE__ */ template(`<svg viewBox="0 0 24 24"width=1.2em height=1.2em><path fill=none stroke=currentColor stroke-width=2 d="M8.5 5.5L12 2l3.5 3.5M22 12H2m3.5-3.5L2 12l3.5 3.5m13 0L22 12l-3.5-3.5M12 22V2M8.5 18.5L12 22l3.5-3.5">`);
const IconGrommetIconsPan = (props = {}) => (() => {
  var _el$ = _tmpl$$a();
  spread(_el$, props, true, true);
  return _el$;
})();

var _tmpl$$9 = /* @__PURE__ */ template(`<svg viewBox="0 0 24 24"width=1.2em height=1.2em><path fill=none stroke=currentColor stroke-width=2 d="M9 15h8zm0-4h10zm0-4h4zm7-6v6h6M6 5H2v18h16v-4m4 0H6V1h11l5 5z">`);
const IconGrommetIconsCopy = (props = {}) => (() => {
  var _el$ = _tmpl$$9();
  spread(_el$, props, true, true);
  return _el$;
})();

var _tmpl$$8 = /* @__PURE__ */ template(`<svg viewBox="0 0 24 24"width=1.2em height=1.2em><path fill=none stroke=currentColor stroke-width=2 d="M16 3h5v20H3V3h5m0-2h8v5H8z">`);
const IconGrommetIconsClipboard = (props = {}) => (() => {
  var _el$ = _tmpl$$8();
  spread(_el$, props, true, true);
  return _el$;
})();

var _tmpl$$7 = /* @__PURE__ */ template(`<svg viewBox="0 0 24 24"width=1.2em height=1.2em><path fill=none stroke=currentColor stroke-width=2 d="M23 4L8 16zm0 16L8 8zM5 9a3 3 0 1 0 0-6a3 3 0 0 0 0 6Zm0 12a3 3 0 1 0 0-6a3 3 0 0 0 0 6Z">`);
const IconGrommetIconsCut = (props = {}) => (() => {
  var _el$ = _tmpl$$7();
  spread(_el$, props, true, true);
  return _el$;
})();

var _tmpl$$6 = /* @__PURE__ */ template(`<svg viewBox="0 0 24 24"width=1.2em height=1.2em><path fill=none stroke=currentColor stroke-width=2 d="M7 21L22 6l-4-4L2 18l3 3h14M6 14l4 4">`);
const IconGrommetIconsErase = (props = {}) => (() => {
  var _el$ = _tmpl$$6();
  spread(_el$, props, true, true);
  return _el$;
})();

var _tmpl$$5 = /* @__PURE__ */ template(`<svg viewBox="0 0 24 24"width=1.2em height=1.2em><path fill=none stroke=currentColor stroke-width=2 d="M18 12H6M4 22h16a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2z">`);
const IconGrommetIconsDisabledOutline = (props = {}) => (() => {
  var _el$ = _tmpl$$5();
  spread(_el$, props, true, true);
  return _el$;
})();

var _tmpl$$4 = /* @__PURE__ */ template(`<svg viewBox="0 0 24 24"width=1.2em height=1.2em><path fill=none stroke=currentColor stroke-width=2 d="M2 19h20M2 5h20M2 12h20">`);
const IconGrommetIconsMenu = (props = {}) => (() => {
  var _el$ = _tmpl$$4();
  spread(_el$, props, true, true);
  return _el$;
})();

var _tmpl$$3 = /* @__PURE__ */ template(`<svg viewBox="0 0 24 24"width=1.2em height=1.2em><path fill=none stroke=currentColor stroke-width=2 d="M4 4h16v16H4z">`);
const IconGrommetIconsStop = (props = {}) => (() => {
  var _el$ = _tmpl$$3();
  spread(_el$, props, true, true);
  return _el$;
})();

var _tmpl$$2 = /* @__PURE__ */ template(`<svg viewBox="0 0 24 24"width=1.2em height=1.2em><path fill=none stroke=currentColor stroke-width=2 d="m3 22l18-10L3 2z">`);
const IconGrommetIconsPlay = (props = {}) => (() => {
  var _el$ = _tmpl$$2();
  spread(_el$, props, true, true);
  return _el$;
})();

var _tmpl$$1 = /* @__PURE__ */ template(`<svg viewBox="0 0 24 24"width=1.2em height=1.2em><path fill=none stroke=currentColor stroke-width=2 d="M3 21h6V3H3zm12 0h6V3h-6z">`);
const IconGrommetIconsPause = (props = {}) => (() => {
  var _el$ = _tmpl$$1();
  spread(_el$, props, true, true);
  return _el$;
})();

var _tmpl$ = /* @__PURE__ */ template(`<button>`), _tmpl$2 = /* @__PURE__ */ template(`<div><div><label></label><span></span></div><div><button><div></div><div></div></button><button><div></div><div>`), _tmpl$3 = /* @__PURE__ */ template(`<svg><rect></svg>`, false, true), _tmpl$4 = /* @__PURE__ */ template(`<svg>`), _tmpl$5 = /* @__PURE__ */ template(`<svg><g></svg>`, false, true), _tmpl$6 = /* @__PURE__ */ template(`<svg><rect x=0></svg>`, false, true), _tmpl$7 = /* @__PURE__ */ template(`<svg><rect x=0 opacity=0.8></svg>`, false, true), _tmpl$8 = /* @__PURE__ */ template(`<svg><rect x=0 y=0 fill=var(--color-piano-black)></svg>`, false, true), _tmpl$9 = /* @__PURE__ */ template(`<svg><line x1=0 stroke=var(--color-stroke)></svg>`, false, true), _tmpl$10 = /* @__PURE__ */ template(`<svg><rect y=0></svg>`, false, true), _tmpl$11 = /* @__PURE__ */ template(`<svg><line y1=0 stroke=var(--color-stroke) stroke-width=2px></svg>`, false, true), _tmpl$12 = /* @__PURE__ */ template(`<svg><line y1=0 stroke=var(--color-stroke) stroke-width=1px></svg>`, false, true), _tmpl$13 = /* @__PURE__ */ template(`<svg><line y1=0 stroke=var(--color-stroke-secondary)></svg>`, false, true), _tmpl$14 = /* @__PURE__ */ template(`<div><div></div><div>`), _tmpl$15 = /* @__PURE__ */ template(`<div><div>`), _tmpl$16 = /* @__PURE__ */ template(`<div><div></div><div></div><div></div><div></div><div></div><div></div><div>`), _tmpl$17 = /* @__PURE__ */ template(`<div><svg>`), _tmpl$18 = /* @__PURE__ */ template(`<svg><rect opacity=0.3 fill=var(--color-selection-area)></svg>`, false, true), _tmpl$19 = /* @__PURE__ */ template(`<svg><rect opacity=0.8 fill=var(--color-selection-area)></svg>`, false, true);
function Button(props) {
  return (() => {
    var _el$ = _tmpl$();
    spread(_el$, mergeProps(props, {
      get ["class"]() {
        return clsx(props.class, styles.button);
      }
    }), false, false);
    return _el$;
  })();
}
function createMidiDataUri(notes) {
  const track = new MidiWriter.Track();
  const division = 8;
  notes.forEach((note) => {
    track.addEvent(new MidiWriter.NoteEvent({
      pitch: [MidiWriter.Utils.getPitch(note.pitch)],
      duration: Array.from({
        length: note.duration
      }).fill(division),
      startTick: note.time * (512 / division),
      velocity: note.velocity / 100
    }));
  });
  const write = new MidiWriter.Writer(track);
  return write.dataUri();
}
function ActionButton(props) {
  const [trigger, setTrigger] = createSignal(false);
  return createComponent(Button, {
    get ["class"]() {
      return clsx(props.class, trigger() && styles.trigger);
    },
    get style() {
      return props.style;
    },
    get disabled() {
      return props.disabled;
    },
    onClick: (event) => {
      setTrigger(true);
      props.onClick(event);
      setTimeout(() => setTrigger(false), 250);
    },
    get children() {
      return props.children;
    }
  });
}
function NumberButton(props) {
  async function handleLongPress(event, callback) {
    function loop2() {
      timeout = setTimeout(loop2, 100);
      callback();
    }
    let timeout = setTimeout(loop2, 500);
    await pointerHelper(event);
    clearTimeout(timeout);
  }
  return (() => {
    var _el$2 = _tmpl$2(), _el$3 = _el$2.firstChild, _el$4 = _el$3.firstChild, _el$5 = _el$4.nextSibling, _el$6 = _el$3.nextSibling, _el$7 = _el$6.firstChild, _el$8 = _el$7.firstChild, _el$9 = _el$8.nextSibling, _el$10 = _el$7.nextSibling, _el$11 = _el$10.firstChild, _el$12 = _el$11.nextSibling;
    _el$2.style.setProperty("display", "flex");
    _el$2.style.setProperty("flex-direction", "column");
    _el$3.style.setProperty("flex-direction", "column");
    insert(_el$4, () => props.label);
    insert(_el$5, () => props.value);
    addEventListener(_el$7, "click", props.decrement, true);
    _el$7.$$pointerdown = (event) => handleLongPress(event, props.decrement);
    _el$7.style.setProperty("display", "flex");
    _el$7.style.setProperty("flex-direction", "column");
    insert(_el$9, createComponent(IconGrommetIconsFormPreviousLink, {}));
    addEventListener(_el$10, "click", props.increment, true);
    _el$10.$$pointerdown = (event) => handleLongPress(event, props.increment);
    _el$10.style.setProperty("display", "flex");
    _el$10.style.setProperty("flex-direction", "column");
    insert(_el$12, createComponent(IconGrommetIconsFormNextLink, {}));
    createRenderEffect((_p$) => {
      var _v$ = styles.numberButton, _v$2 = styles.textContainer, _v$3 = styles.numberButtonLabel, _v$4 = styles.numberButtonValue, _v$5 = styles.buttonContainer, _v$6 = props.canDecrement === false, _v$7 = props.canIncrement === false;
      _v$ !== _p$.e && className(_el$2, _p$.e = _v$);
      _v$2 !== _p$.t && className(_el$3, _p$.t = _v$2);
      _v$3 !== _p$.a && className(_el$4, _p$.a = _v$3);
      _v$4 !== _p$.o && className(_el$5, _p$.o = _v$4);
      _v$5 !== _p$.i && className(_el$6, _p$.i = _v$5);
      _v$6 !== _p$.n && (_el$7.disabled = _p$.n = _v$6);
      _v$7 !== _p$.s && (_el$10.disabled = _p$.s = _v$7);
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0,
      o: void 0,
      i: void 0,
      n: void 0,
      s: void 0
    });
    return _el$2;
  })();
}
function Note(props) {
  async function handleSelect(event) {
    if (isNoteSelected(props.note)) {
      event.stopPropagation();
      event.preventDefault();
      selectedNotes().sort((a, b) => a.time < b.time ? -1 : 1);
      if (selectedNotes().length > 0) {
        const offset = selectedNotes()[0].time % timeScale();
        const initialNotes = Object.fromEntries(selectedNotes().map((note) => [note.id, {
          time: note.time,
          pitch: note.pitch
        }]));
        let previous = 0;
        const {
          delta
        } = await pointerHelper(event, ({
          delta: delta2
        }) => {
          let time = Math.floor(delta2.x / projectedWidth() / timeScale()) * timeScale();
          if (time === timeScale() * -1) {
            time = 0;
          } else if (time < timeScale() * -1) {
            time = time + timeScale();
          }
          const hasChanged = previous !== time;
          previous = time;
          setDoc((doc2) => {
            doc2.notes.forEach((note) => {
              if (isNoteSelected(note)) {
                note.time = initialNotes[note.id].time + time - offset;
                note.pitch = initialNotes[note.id].pitch - Math.floor((delta2.y + projectedHeight() / 2) / projectedHeight());
                if (hasChanged) {
                  playNote(note);
                }
              }
            });
          });
          markOverlappingNotes(...selectedNotes());
        });
        if (Math.floor((delta.x + projectedWidth() / 2) / projectedWidth()) !== 0) ;
        clipOverlappingNotes(...selectedNotes());
      }
    }
  }
  async function handleStretch(event) {
    event.stopPropagation();
    event.preventDefault();
    if (!isNoteSelected(props.note)) {
      setSelectedNotes([props.note]);
    }
    const initialSelectedNotes = Object.fromEntries(selectedNotes().map((note) => [note.id, {
      ...note
    }]));
    console.log(initialSelectedNotes.length);
    await pointerHelper(event, ({
      delta
    }) => {
      batch(() => {
        const deltaX = Math.floor(delta.x / projectedWidth() / timeScale()) * timeScale();
        setDoc((doc2) => {
          doc2.notes.forEach((note) => {
            if (!isNoteSelected(note)) return;
            const duration = initialSelectedNotes[note.id].duration + deltaX;
            if (duration > timeScale()) {
              note.duration = duration;
            } else {
              note.time = initialSelectedNotes[note.id].time;
              note.duration = timeScale();
            }
          });
        });
        markOverlappingNotes(...selectedNotes());
      });
    });
    clipOverlappingNotes(...selectedNotes());
    if (selectedNotes().length === 1) {
      setSelectedNotes([]);
    }
  }
  async function handleNote(event) {
    event.stopPropagation();
    event.preventDefault();
    const initialTime = props.note.time;
    const initialPitch = props.note.pitch;
    let previousPitch = initialPitch;
    setSelectedNotes([props.note]);
    await pointerHelper(event, ({
      delta
    }) => {
      const time = Math.floor((initialTime + delta.x / projectedWidth()) / timeScale()) * timeScale();
      const pitch = initialPitch - Math.floor((delta.y + projectedHeight() / 2) / projectedHeight());
      setDoc((doc2) => {
        const note = doc2.notes.find((note2) => note2.id === props.note.id);
        if (!note) return;
        note.time = time;
        note.pitch = pitch;
        if (previousPitch !== pitch) {
          playNote(note);
          previousPitch = pitch;
        }
      });
      markOverlappingNotes(props.note);
    });
    setSelectedNotes([]);
    clipOverlappingNotes(props.note);
  }
  async function handleVelocity(event) {
    let initiallySelected = !!selectedNotes().find(filterNote(props.note));
    if (!initiallySelected) {
      setSelectedNotes([props.note]);
    }
    const initialNotes = Object.fromEntries(selectedNotes().map((note) => [note.id, {
      ...note
    }]));
    await pointerHelper(event, ({
      delta
    }) => {
      setDoc((doc2) => {
        doc2.notes.forEach((note) => {
          if (!note.active) {
            note.active = true;
          }
          if (note.id in initialNotes) {
            note.velocity = Math.min(1, Math.max(0, initialNotes[note.id].velocity - delta.y / 100));
          }
        });
      });
    });
    if (!initiallySelected) {
      setSelectedNotes([]);
    }
  }
  return (() => {
    var _el$13 = _tmpl$3();
    _el$13.$$pointerdown = async (event) => {
      switch (mode()) {
        case "select":
          return await handleSelect(event);
        case "stretch":
          return handleStretch(event);
        case "note":
          return handleNote(event);
        case "velocity":
          return handleVelocity(event);
      }
    };
    _el$13.$$dblclick = () => {
      if (mode() === "note") {
        setDoc((doc2) => {
          const index = doc2.notes.findIndex(filterNote(props.note));
          if (index !== -1) doc2.notes.splice(index, 1);
        });
      }
    };
    createRenderEffect((_p$) => {
      var _v$8 = clsx(styles.note, (isNoteSelected(props.note) || isNotePlaying(props.note)) && styles.selected), _v$9 = props.note.time * projectedWidth() + MARGIN, _v$10 = -props.note.pitch * projectedHeight() + MARGIN, _v$11 = (props.note._duration ?? props.note.duration) * projectedWidth() - MARGIN * 2, _v$12 = projectedHeight() - MARGIN * 2, _v$13 = !props.note._remove && props.note.active ? props.note.velocity * 0.75 + 0.25 : 0.25;
      _v$8 !== _p$.e && setAttribute(_el$13, "class", _p$.e = _v$8);
      _v$9 !== _p$.t && setAttribute(_el$13, "x", _p$.t = _v$9);
      _v$10 !== _p$.a && setAttribute(_el$13, "y", _p$.a = _v$10);
      _v$11 !== _p$.o && setAttribute(_el$13, "width", _p$.o = _v$11);
      _v$12 !== _p$.i && setAttribute(_el$13, "height", _p$.i = _v$12);
      _v$13 !== _p$.n && setAttribute(_el$13, "opacity", _p$.n = _v$13);
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0,
      o: void 0,
      i: void 0,
      n: void 0
    });
    return _el$13;
  })();
}
function Piano() {
  const [dimensions2, setDimensions2] = createSignal();
  return (() => {
    var _el$14 = _tmpl$4();
    use((element) => {
      onMount(() => {
        const observer = new ResizeObserver(() => {
          setDimensions2(element.getBoundingClientRect());
        });
        observer.observe(element);
        onCleanup(() => observer.disconnect());
      });
    }, _el$14);
    _el$14.style.setProperty("width", "var(--width-piano)");
    _el$14.style.setProperty("fill", "100%");
    _el$14.style.setProperty("background", "var(--color-piano-white)");
    insert(_el$14, createComponent(Show, {
      get when() {
        return dimensions2();
      },
      children: (dimensions3) => createComponent(dimensionsContext.Provider, {
        value: dimensions3,
        get children() {
          return [createComponent(PlayingNotes, {}), (() => {
            var _el$15 = _tmpl$5();
            insert(_el$15, createComponent(Index, {
              get each() {
                return new Array(Math.floor(dimensions3().height / projectedHeight()) + 2);
              },
              children: (_, index) => (() => {
                var _el$16 = _tmpl$6();
                createRenderEffect((_p$) => {
                  var _v$14 = index * projectedHeight(), _v$15 = `${projectedHeight()}px`, _v$16 = KEY_COLORS[mod(index + Math.floor(-projectedOrigin().y / projectedHeight()), KEY_COLORS.length)] ? "none" : "var(--color-piano-black)";
                  _v$14 !== _p$.e && setAttribute(_el$16, "y", _p$.e = _v$14);
                  _v$15 !== _p$.t && ((_p$.t = _v$15) != null ? _el$16.style.setProperty("height", _v$15) : _el$16.style.removeProperty("height"));
                  _v$16 !== _p$.a && ((_p$.a = _v$16) != null ? _el$16.style.setProperty("fill", _v$16) : _el$16.style.removeProperty("fill"));
                  return _p$;
                }, {
                  e: void 0,
                  t: void 0,
                  a: void 0
                });
                return _el$16;
              })()
            }));
            createRenderEffect((_$p) => (_$p = `translateY(${mod(-projectedOrigin().y, projectedHeight()) * -1}px)`) != null ? _el$15.style.setProperty("transform", _$p) : _el$15.style.removeProperty("transform"));
            return _el$15;
          })()];
        }
      })
    }));
    createRenderEffect(() => setAttribute(_el$14, "class", styles.piano));
    return _el$14;
  })();
}
function PlayingNotes() {
  const dimensions2 = useDimensions();
  return (() => {
    var _el$17 = _tmpl$5();
    insert(_el$17, createComponent(Index, {
      get each() {
        return new Array(Math.floor(dimensions2().height / projectedHeight()) + 2);
      },
      children: (_, index) => {
        return (() => {
          var _el$18 = _tmpl$7();
          createRenderEffect((_p$) => {
            var _v$17 = index * projectedHeight(), _v$18 = projectedWidth(), _v$19 = projectedHeight(), _v$20 = isPitchPlaying(-(index + Math.floor(-projectedOrigin().y / projectedHeight()))) ? "var(--color-note-selected)" : "none";
            _v$17 !== _p$.e && setAttribute(_el$18, "y", _p$.e = _v$17);
            _v$18 !== _p$.t && setAttribute(_el$18, "width", _p$.t = _v$18);
            _v$19 !== _p$.a && setAttribute(_el$18, "height", _p$.a = _v$19);
            _v$20 !== _p$.o && ((_p$.o = _v$20) != null ? _el$18.style.setProperty("fill", _v$20) : _el$18.style.removeProperty("fill"));
            return _p$;
          }, {
            e: void 0,
            t: void 0,
            a: void 0,
            o: void 0
          });
          return _el$18;
        })();
      }
    }));
    createRenderEffect((_$p) => (_$p = `translateY(${mod(-projectedOrigin().y, projectedHeight()) * -1}px)`) != null ? _el$17.style.setProperty("transform", _$p) : _el$17.style.removeProperty("transform"));
    return _el$17;
  })();
}
function Ruler(props) {
  const dimensions2 = useDimensions();
  const [selected, setSelected] = createSignal(false);
  const [trigger, setTrigger] = createSignal(false);
  function handleCreateLoop(event) {
    event.stopPropagation();
    const absolutePosition = {
      x: event.layerX - projectedOrigin().x,
      y: event.layerY - projectedOrigin().y
    };
    const loop2 = {
      time: Math.floor(absolutePosition.x / projectedWidth()),
      duration: 1
    };
    props.setLoop(loop2);
    const initialTime = loop2.time;
    const initialDuration = loop2.duration;
    const offset = absolutePosition.x - initialTime * projectedWidth();
    pointerHelper(event, ({
      delta
    }) => {
      const deltaX = Math.floor((offset + delta.x) / projectedWidth());
      if (deltaX < 0) {
        props.setLoop("time", initialTime + deltaX);
        props.setLoop("duration", 1 - deltaX);
      } else if (deltaX > 0) {
        props.setLoop("duration", initialDuration + deltaX);
      } else {
        props.setLoop("time", initialTime);
        props.setLoop("duration", 1);
      }
    });
  }
  async function handleAdjustLoop(event, loop2) {
    event.stopPropagation();
    event.preventDefault();
    setSelected(true);
    const {
      width,
      left
    } = event.target.getBoundingClientRect();
    const initialTime = loop2.time;
    const initialDuration = loop2.duration;
    if (event.clientX < left + projectedWidth() / 3) {
      const offset = event.clientX - initialTime * projectedWidth() - projectedOrigin().x;
      await pointerHelper(event, ({
        delta
      }) => {
        const deltaX = Math.floor((delta.x + offset) / projectedWidth());
        if (deltaX >= initialDuration) {
          props.setLoop("duration", deltaX - initialDuration + 2);
        } else {
          const time = initialTime + deltaX - 1;
          props.setLoop("time", time);
          props.setLoop("duration", initialDuration - deltaX + 1);
        }
      });
    } else if (event.clientX > left + width - projectedWidth() / 3) {
      await pointerHelper(event, ({
        delta
      }) => {
        const duration = Math.floor((event.clientX - projectedOrigin().x + delta.x) / projectedWidth()) - initialTime;
        if (duration > 0) {
          props.setLoop("duration", duration);
        } else if (duration < 0) {
          props.setLoop("duration", 1 - duration);
          props.setLoop("time", initialTime + duration);
        } else {
          props.setLoop("time", initialTime);
          props.setLoop("duration", 1);
        }
      });
    } else {
      await pointerHelper(event, ({
        delta
      }) => {
        const deltaX = Math.floor((delta.x + projectedWidth() / 2) / projectedWidth());
        const time = initialTime + deltaX;
        props.setLoop("time", time);
      });
    }
    setSelected(false);
  }
  let initial = true;
  createEffect(on(() => [props.loop.duration, props.loop.time], () => {
    if (initial) {
      initial = false;
      return;
    }
    setTrigger(true);
    setTimeout(() => {
      setTrigger(false);
    }, 250);
  }));
  return [(() => {
    var _el$19 = _tmpl$8();
    _el$19.$$pointerdown = handleCreateLoop;
    createRenderEffect((_p$) => {
      var _v$21 = dimensions2().width, _v$22 = projectedHeight();
      _v$21 !== _p$.e && setAttribute(_el$19, "width", _p$.e = _v$21);
      _v$22 !== _p$.t && setAttribute(_el$19, "height", _p$.t = _v$22);
      return _p$;
    }, {
      e: void 0,
      t: void 0
    });
    return _el$19;
  })(), createComponent(Show, {
    get when() {
      return props.loop;
    },
    children: (loop2) => (() => {
      var _el$24 = _tmpl$10();
      _el$24.$$pointerdown = (event) => handleAdjustLoop(event, loop2());
      _el$24.style.setProperty("transition", "fill 0.25s");
      createRenderEffect((_p$) => {
        var _v$30 = loop2().time * projectedWidth(), _v$31 = loop2().duration * projectedWidth(), _v$32 = projectedHeight(), _v$33 = selected() || trigger() ? "var(--color-loop-selected)" : "var(--color-loop)", _v$34 = `translateX(${projectedOrigin().x}px)`;
        _v$30 !== _p$.e && setAttribute(_el$24, "x", _p$.e = _v$30);
        _v$31 !== _p$.t && setAttribute(_el$24, "width", _p$.t = _v$31);
        _v$32 !== _p$.a && setAttribute(_el$24, "height", _p$.a = _v$32);
        _v$33 !== _p$.o && setAttribute(_el$24, "fill", _p$.o = _v$33);
        _v$34 !== _p$.i && ((_p$.i = _v$34) != null ? _el$24.style.setProperty("transform", _v$34) : _el$24.style.removeProperty("transform"));
        return _p$;
      }, {
        e: void 0,
        t: void 0,
        a: void 0,
        o: void 0,
        i: void 0
      });
      return _el$24;
    })()
  }), (() => {
    var _el$20 = _tmpl$3();
    _el$20.style.setProperty("opacity", "0.5");
    createRenderEffect((_p$) => {
      var _v$23 = styles.now, _v$24 = projectedWidth() * timeScale(), _v$25 = projectedHeight(), _v$26 = `translateX(${projectedOrigin().x + Math.floor(now() / timeScale()) * projectedWidth() * timeScale()}px)`;
      _v$23 !== _p$.e && setAttribute(_el$20, "class", _p$.e = _v$23);
      _v$24 !== _p$.t && setAttribute(_el$20, "width", _p$.t = _v$24);
      _v$25 !== _p$.a && setAttribute(_el$20, "height", _p$.a = _v$25);
      _v$26 !== _p$.o && ((_p$.o = _v$26) != null ? _el$20.style.setProperty("transform", _v$26) : _el$20.style.removeProperty("transform"));
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0,
      o: void 0
    });
    return _el$20;
  })(), (() => {
    var _el$21 = _tmpl$9();
    createRenderEffect((_p$) => {
      var _v$27 = dimensions2().width, _v$28 = projectedHeight(), _v$29 = projectedHeight();
      _v$27 !== _p$.e && setAttribute(_el$21, "x2", _p$.e = _v$27);
      _v$28 !== _p$.t && setAttribute(_el$21, "y1", _p$.t = _v$28);
      _v$29 !== _p$.a && setAttribute(_el$21, "y2", _p$.a = _v$29);
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0
    });
    return _el$21;
  })(), (() => {
    var _el$22 = _tmpl$5();
    insert(_el$22, createComponent(Index, {
      get each() {
        return new Array(Math.floor(dimensions2().width / projectedWidth() / 8) + 2);
      },
      children: (_, index) => (() => {
        var _el$25 = _tmpl$11();
        createRenderEffect((_p$) => {
          var _v$35 = projectedHeight(), _v$36 = index * projectedWidth() * 8, _v$37 = index * projectedWidth() * 8;
          _v$35 !== _p$.e && setAttribute(_el$25, "y2", _p$.e = _v$35);
          _v$36 !== _p$.t && setAttribute(_el$25, "x1", _p$.t = _v$36);
          _v$37 !== _p$.a && setAttribute(_el$25, "x2", _p$.a = _v$37);
          return _p$;
        }, {
          e: void 0,
          t: void 0,
          a: void 0
        });
        return _el$25;
      })()
    }));
    createRenderEffect((_$p) => (_$p = `translateX(${projectedOrigin().x % (projectedWidth() * 8)}px)`) != null ? _el$22.style.setProperty("transform", _$p) : _el$22.style.removeProperty("transform"));
    return _el$22;
  })(), (() => {
    var _el$23 = _tmpl$5();
    insert(_el$23, createComponent(Index, {
      get each() {
        return new Array(Math.floor(dimensions2().width / projectedWidth()) + 2);
      },
      children: (_, index) => (() => {
        var _el$26 = _tmpl$12();
        createRenderEffect((_p$) => {
          var _v$38 = projectedHeight(), _v$39 = index * projectedWidth(), _v$40 = index * projectedWidth();
          _v$38 !== _p$.e && setAttribute(_el$26, "y2", _p$.e = _v$38);
          _v$39 !== _p$.t && setAttribute(_el$26, "x1", _p$.t = _v$39);
          _v$40 !== _p$.a && setAttribute(_el$26, "x2", _p$.a = _v$40);
          return _p$;
        }, {
          e: void 0,
          t: void 0,
          a: void 0
        });
        return _el$26;
      })()
    }));
    createRenderEffect((_$p) => (_$p = `translateX(${projectedOrigin().x % projectedWidth()}px)`) != null ? _el$23.style.setProperty("transform", _$p) : _el$23.style.removeProperty("transform"));
    return _el$23;
  })()];
}
function Grid() {
  const dimensions2 = useDimensions();
  return [(() => {
    var _el$27 = _tmpl$5();
    insert(_el$27, createComponent(Index, {
      get each() {
        return new Array(Math.floor(dimensions2().width / projectedWidth() / timeScale()) + 2);
      },
      children: (_, index) => (() => {
        var _el$29 = _tmpl$13();
        createRenderEffect((_p$) => {
          var _v$41 = dimensions2().height, _v$42 = index * timeScale() * projectedWidth(), _v$43 = index * timeScale() * projectedWidth();
          _v$41 !== _p$.e && setAttribute(_el$29, "y2", _p$.e = _v$41);
          _v$42 !== _p$.t && setAttribute(_el$29, "x1", _p$.t = _v$42);
          _v$43 !== _p$.a && setAttribute(_el$29, "x2", _p$.a = _v$43);
          return _p$;
        }, {
          e: void 0,
          t: void 0,
          a: void 0
        });
        return _el$29;
      })()
    }));
    createRenderEffect((_$p) => (_$p = `translateX(${projectedOrigin().x % (projectedWidth() * timeScale())}px)`) != null ? _el$27.style.setProperty("transform", _$p) : _el$27.style.removeProperty("transform"));
    return _el$27;
  })(), (() => {
    var _el$28 = _tmpl$5();
    insert(_el$28, createComponent(Index, {
      get each() {
        return new Array(Math.floor(dimensions2().width / projectedWidth() / 8) + 2);
      },
      children: (_, index) => (() => {
        var _el$30 = _tmpl$11();
        createRenderEffect((_p$) => {
          var _v$44 = dimensions2().height, _v$45 = index * projectedWidth() * 8, _v$46 = index * projectedWidth() * 8;
          _v$44 !== _p$.e && setAttribute(_el$30, "y2", _p$.e = _v$44);
          _v$45 !== _p$.t && setAttribute(_el$30, "x1", _p$.t = _v$45);
          _v$46 !== _p$.a && setAttribute(_el$30, "x2", _p$.a = _v$46);
          return _p$;
        }, {
          e: void 0,
          t: void 0,
          a: void 0
        });
        return _el$30;
      })()
    }));
    createRenderEffect((_$p) => (_$p = `translateX(${projectedOrigin().x % (projectedWidth() * 8)}px)`) != null ? _el$28.style.setProperty("transform", _$p) : _el$28.style.removeProperty("transform"));
    return _el$28;
  })()];
}
function PianoUnderlay() {
  const dimensions2 = useDimensions();
  return (() => {
    var _el$31 = _tmpl$5();
    insert(_el$31, createComponent(Index, {
      get each() {
        return new Array(Math.floor(dimensions2().height / projectedHeight()) + 2);
      },
      children: (_, index) => (() => {
        var _el$32 = _tmpl$3();
        _el$32.style.setProperty("pointer-events", "none");
        createRenderEffect((_p$) => {
          var _v$47 = index * projectedHeight(), _v$48 = dimensions2().width, _v$49 = projectedHeight(), _v$50 = KEY_COLORS[mod(index + Math.floor(-projectedOrigin().y / projectedHeight()), KEY_COLORS.length)] ? "none" : "var(--color-piano-underlay)";
          _v$47 !== _p$.e && setAttribute(_el$32, "y", _p$.e = _v$47);
          _v$48 !== _p$.t && setAttribute(_el$32, "width", _p$.t = _v$48);
          _v$49 !== _p$.a && setAttribute(_el$32, "height", _p$.a = _v$49);
          _v$50 !== _p$.o && ((_p$.o = _v$50) != null ? _el$32.style.setProperty("fill", _v$50) : _el$32.style.removeProperty("fill"));
          return _p$;
        }, {
          e: void 0,
          t: void 0,
          a: void 0,
          o: void 0
        });
        return _el$32;
      })()
    }));
    createRenderEffect((_$p) => (_$p = `translateY(${-mod(-projectedOrigin().y, projectedHeight())}px)`) != null ? _el$31.style.setProperty("transform", _$p) : _el$31.style.removeProperty("transform"));
    return _el$31;
  })();
}
function Hud() {
  return (() => {
    var _el$33 = _tmpl$14(), _el$34 = _el$33.firstChild, _el$35 = _el$34.nextSibling;
    insert(_el$34, createComponent(TopLeftHud, {}), null);
    insert(_el$34, createComponent(TopRightHud, {}), null);
    insert(_el$35, createComponent(BottomLeftHud, {}), null);
    insert(_el$35, createComponent(BottomRightHud, {}), null);
    createRenderEffect((_p$) => {
      var _v$51 = styles.hud, _v$52 = styles.topHudContainer, _v$53 = styles.bottomHudContainer;
      _v$51 !== _p$.e && className(_el$33, _p$.e = _v$51);
      _v$52 !== _p$.t && className(_el$34, _p$.t = _v$52);
      _v$53 !== _p$.a && className(_el$35, _p$.a = _v$53);
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0
    });
    return _el$33;
  })();
}
function TopLeftHud() {
  return (() => {
    var _el$36 = _tmpl$15(), _el$37 = _el$36.firstChild;
    _el$36.style.setProperty("gap", "5px");
    insert(_el$37, createComponent(ActionButton, {
      onClick: () => {
        const selection = doc().notes?.filter((note) => note.time >= loop.time && note.time < loop.time + loop.duration);
        if (!selection) return;
        const newNotes = selection.map((note) => ({
          ...note,
          id: get(),
          time: note.time + loop.duration
        }));
        setDoc((doc2) => doc2.notes.push(...newNotes));
        setLoop("duration", (duration) => duration * 2);
        clipOverlappingNotes(...newNotes);
      },
      get children() {
        return createComponent(IconGrommetIconsDuplicate, {});
      }
    }), null);
    insert(_el$37, createComponent(Show, {
      get when() {
        return mode() === "select";
      },
      get children() {
        return createComponent(ActionButton, {
          get disabled() {
            return selectionArea() === void 0;
          },
          get ["class"]() {
            return clsx(mode() === "stretch" && styles.active);
          },
          onClick: () => {
            const area = selectionArea();
            if (!area) {
              console.error("Trying to ");
              return;
            }
            setLoop({
              time: area.start.x,
              duration: area.end.x - area.start.x
            });
          },
          get children() {
            return createComponent(IconGrommetIconsCycle, {
              style: {
                "margin-top": "3px"
              }
            });
          }
        });
      }
    }), null);
    createRenderEffect((_p$) => {
      var _v$54 = styles.topLeftHud, _v$55 = `${projectedHeight()}px`, _v$56 = styles.list;
      _v$54 !== _p$.e && className(_el$36, _p$.e = _v$54);
      _v$55 !== _p$.t && ((_p$.t = _v$55) != null ? _el$36.style.setProperty("top", _v$55) : _el$36.style.removeProperty("top"));
      _v$56 !== _p$.a && className(_el$37, _p$.a = _v$56);
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0
    });
    return _el$36;
  })();
}
function TopRightHud() {
  return (() => {
    var _el$38 = _tmpl$15(), _el$39 = _el$38.firstChild;
    insert(_el$39, createComponent(Button, {
      get ["class"]() {
        return mode() === "note" ? styles.active : void 0;
      },
      onClick: () => setMode("note"),
      get children() {
        return createComponent(IconGrommetIconsMusic, {});
      }
    }), null);
    insert(_el$39, createComponent(Button, {
      get ["class"]() {
        return mode() === "select" ? styles.active : void 0;
      },
      onClick: () => setMode("select"),
      get children() {
        return createComponent(IconGrommetIconsSelect, {});
      }
    }), null);
    insert(_el$39, createComponent(Button, {
      get ["class"]() {
        return mode() === "stretch" ? styles.active : void 0;
      },
      onClick: () => setMode("stretch"),
      get children() {
        return createComponent(IconGrommetIconsShift, {});
      }
    }), null);
    insert(_el$39, createComponent(Button, {
      get ["class"]() {
        return mode() === "velocity" ? styles.active : void 0;
      },
      onClick: () => setMode("velocity"),
      get children() {
        return createComponent(IconGrommetIconsVolumeControl, {});
      }
    }), null);
    insert(_el$39, createComponent(Button, {
      get ["class"]() {
        return mode() === "pan" ? styles.active : void 0;
      },
      onClick: () => setMode("pan"),
      get children() {
        return createComponent(IconGrommetIconsPan, {});
      }
    }), null);
    insert(_el$38, createComponent(Show, {
      get when() {
        return mode() === "select";
      },
      children: (_) => {
        const hasClipboardAndPresence = () => clipboard() && selectionPresence();
        const clipboardAndPresence = () => hasClipboardAndPresence() && [clipboard(), selectionPresence()];
        return (() => {
          var _el$40 = _tmpl$15(), _el$41 = _el$40.firstChild;
          insert(_el$41, createComponent(ActionButton, {
            get disabled() {
              return !hasClipboardAndPresence();
            },
            get ["class"]() {
              return clsx(mode() === "stretch" && styles.active);
            },
            onClick: () => {
              const _clipboardAndPresence = clipboardAndPresence();
              if (!_clipboardAndPresence) return;
              pasteNotes(..._clipboardAndPresence);
            },
            get children() {
              return createComponent(IconGrommetIconsCopy, {});
            }
          }), null);
          insert(_el$41, createComponent(ActionButton, {
            get disabled() {
              return selectedNotes().length === 0;
            },
            get ["class"]() {
              return clsx(mode() === "stretch" && styles.active);
            },
            onClick: copyNotes,
            get children() {
              return createComponent(IconGrommetIconsClipboard, {});
            }
          }), null);
          insert(_el$41, createComponent(ActionButton, {
            get disabled() {
              return selectedNotes().length === 0;
            },
            onClick: () => {
              const cutLine = selectionArea()?.start.x;
              if (!cutLine) {
                console.error("Attempting to slice without slice-line");
                return;
              }
              const newNotes = selectedNotes().filter((note) => note.time < selectionArea().start.x).map((note) => {
                return {
                  id: get(),
                  active: true,
                  duration: note.duration - (cutLine - note.time),
                  pitch: note.pitch,
                  time: cutLine,
                  velocity: note.velocity
                };
              });
              setDoc((doc2) => doc2.notes.push(...newNotes));
              setSelectedNotes((notes) => [...notes, ...newNotes]);
              setDoc((doc2) => {
                doc2.notes.forEach((note) => {
                  if (isNoteSelected(note) && note.time < cutLine) {
                    note.duration = cutLine - note.time;
                  }
                });
              });
            },
            get children() {
              return createComponent(IconGrommetIconsCut, {});
            }
          }), null);
          insert(_el$41, createComponent(ActionButton, {
            get disabled() {
              return selectedNotes().length === 0;
            },
            onClick: () => {
              setDoc((doc2) => {
                for (let index = doc2.notes.length - 1; index >= 0; index--) {
                  if (isNoteSelected(doc2.notes[index])) {
                    doc2.notes.splice(index, 1);
                  }
                }
              });
              setSelectedNotes([]);
            },
            get children() {
              return createComponent(IconGrommetIconsErase, {});
            }
          }), null);
          insert(_el$41, createComponent(ActionButton, {
            get disabled() {
              return selectedNotes().length === 0;
            },
            onClick: () => {
              let inactiveSelectedNotes = 0;
              selectedNotes().forEach((note) => {
                if (!note.active) {
                  inactiveSelectedNotes++;
                }
              });
              const shouldActivate = inactiveSelectedNotes > selectedNotes().length / 2;
              setDoc((doc2) => {
                doc2.notes.forEach((note) => {
                  if (isNoteSelected(note)) {
                    note.active = shouldActivate;
                  }
                });
              });
            },
            get children() {
              return createComponent(IconGrommetIconsDisabledOutline, {});
            }
          }), null);
          createRenderEffect((_p$) => {
            var _v$59 = styles.listContainer, _v$60 = styles.list;
            _v$59 !== _p$.e && className(_el$40, _p$.e = _v$59);
            _v$60 !== _p$.t && className(_el$41, _p$.t = _v$60);
            return _p$;
          }, {
            e: void 0,
            t: void 0
          });
          return _el$40;
        })();
      }
    }), null);
    createRenderEffect((_p$) => {
      var _v$57 = styles.topRightHud, _v$58 = styles.list;
      _v$57 !== _p$.e && className(_el$38, _p$.e = _v$57);
      _v$58 !== _p$.t && className(_el$39, _p$.t = _v$58);
      return _p$;
    }, {
      e: void 0,
      t: void 0
    });
    return _el$38;
  })();
}
function BottomLeftHud() {
  const [fullscreen, setFullscreen] = createSignal(false);
  const root = document.body;
  createEffect(() => {
    if (fullscreen()) {
      root.requestFullscreen();
    } else if (document.fullscreenElement) {
      document.exitFullscreen();
    }
  });
  return (() => {
    var _el$42 = _tmpl$15(), _el$43 = _el$42.firstChild;
    insert(_el$43, createComponent(DropdownMenu, {
      get children() {
        return [createComponent(DropdownMenu.Trigger, {
          as: Button,
          get children() {
            return createComponent(IconGrommetIconsMenu, {});
          }
        }), createComponent(DropdownMenu.Portal, {
          get children() {
            return createComponent(DropdownMenu.Content, {
              get ["class"]() {
                return styles["dropdown-menu__content"];
              },
              get children() {
                return [createComponent(DropdownMenu.Item, {
                  as: Button,
                  get ["class"]() {
                    return styles["dropdown-menu__item"];
                  },
                  onClick: newDoc,
                  children: "New File"
                }), createComponent(DropdownMenu.Sub, {
                  overlap: true,
                  gutter: 4,
                  shift: -8,
                  get children() {
                    return [createComponent(DropdownMenu.SubTrigger, {
                      as: Button,
                      get ["class"]() {
                        return styles["dropdown-menu__sub-trigger"];
                      },
                      children: "Open File"
                    }), createComponent(DropdownMenu.Portal, {
                      get children() {
                        return createComponent(DropdownMenu.SubContent, {
                          get ["class"]() {
                            return styles["dropdown-menu__sub-content"];
                          },
                          get children() {
                            return createComponent(For, {
                              get each() {
                                return Object.entries(urls()).sort(([, a], [, b]) => a - b > 0 ? -1 : 1);
                              },
                              children: ([_url, date]) => createComponent(DropdownMenu.Item, {
                                as: Button,
                                get ["class"]() {
                                  return clsx(styles["dropdown-menu__item"], url() === _url && styles.selected);
                                },
                                onClick: () => openUrl(_url),
                                get children() {
                                  return deserializeDate(date);
                                }
                              })
                            });
                          }
                        });
                      }
                    })];
                  }
                }), createComponent(DropdownMenu.Item, {
                  as: Button,
                  closeOnSelect: false,
                  get ["class"]() {
                    return styles["dropdown-menu__item"];
                  },
                  onClick: () => downloadDataUri(createMidiDataUri(doc().notes), "pianissimo.mid"),
                  children: "Export to Midi"
                }), createComponent(DropdownMenu.Item, {
                  as: Button,
                  closeOnSelect: false,
                  get ["class"]() {
                    return styles["dropdown-menu__item"];
                  },
                  onClick: () => setFullscreen((fullscreen2) => !fullscreen2),
                  get children() {
                    return [createMemo(() => fullscreen() ? "Close" : "Open"), " Fullscreen"];
                  }
                }), createComponent(DropdownMenu.Sub, {
                  overlap: true,
                  gutter: 4,
                  shift: -8,
                  get children() {
                    return [createComponent(DropdownMenu.SubTrigger, {
                      as: Button,
                      get ["class"]() {
                        return styles["dropdown-menu__sub-trigger"];
                      },
                      onClick: () => {
                        setMidiOutputEnabled(true);
                      },
                      children: "Midi Out"
                    }), createComponent(DropdownMenu.Portal, {
                      get children() {
                        return createComponent(Show, {
                          get when() {
                            return midiOutputEnabled();
                          },
                          get children() {
                            return createComponent(DropdownMenu.SubContent, {
                              get ["class"]() {
                                return styles["dropdown-menu__sub-content"];
                              },
                              get children() {
                                return createComponent(For, {
                                  get each() {
                                    return midiOutputs();
                                  },
                                  children: (output) => createComponent(DropdownMenu.Item, {
                                    as: Button,
                                    closeOnSelect: false,
                                    get ["class"]() {
                                      return clsx(styles["dropdown-menu__item"], selectedMidiOutputs().includes(output) && styles.selected);
                                    },
                                    onClick: () => setSelectedMidiOutputs((outputs) => outputs.includes(output) ? outputs.filter((_output) => _output !== output) : [...outputs, output]),
                                    get children() {
                                      return output.name;
                                    }
                                  })
                                });
                              }
                            });
                          }
                        });
                      }
                    })];
                  }
                })];
              }
            });
          }
        })];
      }
    }));
    createRenderEffect((_p$) => {
      var _v$61 = styles.bottomLeftHud, _v$62 = styles.list;
      _v$61 !== _p$.e && className(_el$42, _p$.e = _v$61);
      _v$62 !== _p$.t && className(_el$43, _p$.t = _v$62);
      return _p$;
    }, {
      e: void 0,
      t: void 0
    });
    return _el$42;
  })();
}
function BottomRightHud() {
  return (() => {
    var _el$44 = _tmpl$16(), _el$45 = _el$44.firstChild, _el$46 = _el$45.nextSibling, _el$47 = _el$46.nextSibling, _el$48 = _el$47.nextSibling, _el$49 = _el$48.nextSibling, _el$50 = _el$49.nextSibling, _el$51 = _el$50.nextSibling;
    insert(_el$45, createComponent(NumberButton, {
      label: "zoom time",
      get value() {
        return zoom().x;
      },
      decrement: () => setZoom((zoom2) => ({
        ...zoom2,
        x: zoom2.x + 0.1
      })),
      increment: () => setZoom((zoom2) => ({
        ...zoom2,
        x: zoom2.x - 0.1
      })),
      get canDecrement() {
        return zoom().x > 0;
      },
      get canIncrement() {
        return zoom().x < 10;
      }
    }));
    insert(_el$46, createComponent(NumberButton, {
      label: "zoom pitch",
      get value() {
        return zoom().y;
      },
      decrement: () => setZoom((zoom2) => ({
        ...zoom2,
        y: zoom2.y + 0.1
      })),
      increment: () => setZoom((zoom2) => ({
        ...zoom2,
        y: zoom2.y - 0.1
      })),
      get canDecrement() {
        return zoom().y > 0;
      },
      get canIncrement() {
        return zoom().y < 10;
      }
    }));
    insert(_el$47, createComponent(NumberButton, {
      label: "volume",
      get value() {
        return volume();
      },
      decrement: () => setVolume((bpm) => Math.max(0, bpm - 1)),
      increment: () => setVolume((bpm) => Math.min(10, bpm + 1)),
      get canDecrement() {
        return volume() > 0;
      },
      get canIncrement() {
        return volume() < 10;
      }
    }));
    insert(_el$48, createComponent(NumberButton, {
      label: "tempo",
      get value() {
        return doc().bpm;
      },
      decrement: () => setDoc((doc2) => doc2.bpm = Math.max(0, doc2.bpm - 1)),
      increment: () => setDoc((doc2) => doc2.bpm = Math.min(1e3, doc2.bpm + 1)),
      get canDecrement() {
        return doc().bpm > 0;
      },
      get canIncrement() {
        return doc().bpm < 1e3;
      }
    }));
    insert(_el$49, createComponent(NumberButton, {
      label: "grid",
      get value() {
        return createMemo(() => timeScale() / 8 < 1)() ? `1:${1 / (timeScale() / 8)}` : timeScale() / 8;
      },
      decrement: () => setTimeScale((duration) => Math.max(duration / 2, 8 / 128)),
      increment: () => setTimeScale((duration) => duration * 2),
      get canDecrement() {
        return timeScale() > 8 / 128;
      }
    }));
    insert(_el$50, createComponent(NumberButton, {
      label: "instrument",
      get value() {
        return doc().instrument.toString().padStart(3, "0");
      },
      decrement: () => {
        if (doc().instrument > 0) {
          setDoc((doc2) => {
            doc2.instrument = doc2.instrument - 1;
          });
        } else {
          setDoc((doc2) => {
            doc2.instrument = 174;
          });
        }
      },
      increment: () => {
        if (doc().instrument >= 174) {
          setDoc((doc2) => {
            doc2.instrument = 0;
          });
        } else {
          setDoc((doc2) => {
            doc2.instrument = doc2.instrument + 1;
          });
        }
      }
    }));
    insert(_el$51, createComponent(Button, {
      get ["class"]() {
        return styles.horizontal;
      },
      onClick: () => {
        setNow(loop.time);
        setPlaying(false);
        playedNotes.clear();
      },
      get children() {
        return createComponent(IconGrommetIconsStop, {});
      }
    }), null);
    insert(_el$51, createComponent(Button, {
      get ["class"]() {
        return styles.horizontal;
      },
      onClick: togglePlaying,
      get children() {
        return createMemo(() => !!!playing())() ? createComponent(IconGrommetIconsPlay, {}) : createComponent(IconGrommetIconsPause, {});
      }
    }), null);
    createRenderEffect(() => className(_el$44, styles.bottomRightHud));
    return _el$44;
  })();
}
const dimensionsContext = createContext();
function useDimensions() {
  const context = useContext(dimensionsContext);
  if (!context) {
    throw `PianoContext is undefined.`;
  }
  return context;
}
function App() {
  createEffect(() => {
    if (mode() !== "select") {
      setSelectionPresence();
      setSelectionArea();
    }
  });
  createEffect(mapArray(() => doc().notes, (note) => {
    createEffect(on(() => isNoteSelected(note), (selected) => selected && playNote({
      ...note,
      duration: Math.min(1, note.duration)
    })));
  }));
  let lastVelocity = doc().bpm / 60;
  createEffect(on(playing, (playing2) => {
    if (!playing2 || !audioContext) return;
    let shouldPlay = true;
    const newVelocity = doc().bpm / 60;
    const currentTime = audioContext.currentTime;
    const elapsedTime = currentTime * lastVelocity - internalTimeOffset();
    setInternalTimeOffset(currentTime * newVelocity - elapsedTime);
    lastVelocity = newVelocity;
    function clock() {
      if (!shouldPlay) return;
      const VELOCITY = doc().bpm / 60;
      let time = audioContext.currentTime * VELOCITY - internalTimeOffset();
      if (loop) {
        if (time < loop.time) {
          playedNotes.clear();
          time = loop.time;
          setInternalTimeOffset(audioContext.currentTime * VELOCITY - loop.time);
        } else if (time > loop.time + loop.duration) {
          playedNotes.clear();
          setInternalTimeOffset(audioContext.currentTime * VELOCITY - loop.time);
          clock();
          return;
        }
      }
      setNow(time);
      doc().notes.forEach((note) => {
        if (!note.active) return;
        if (playedNotes.has(note)) return;
        const loopEnd = loop.time + loop.duration;
        const overflow = time + 1 - loopEnd;
        if (overflow > 0) {
          if (note.time >= time && note.time < loopEnd) {
            playedNotes.add(note);
            playNote(note, (note.time - time) / VELOCITY);
          } else if (note.time >= loop.time && note.time < loop.time + overflow) {
            playedNotes.add(note);
            playNote(note, (note.time + loopEnd - time) / VELOCITY);
          }
        } else if (note.time >= time && note.time < time + 1) {
          playedNotes.add(note);
          playNote(note, (note.time - time) / VELOCITY);
        }
      });
      requestAnimationFrame(clock);
    }
    clock();
    onCleanup(() => shouldPlay = false);
  }));
  onMount(() => {
    window.addEventListener("keydown", (e) => {
      if (e.code === "Space") {
        togglePlaying();
      } else if (mode() === "select") {
        if (e.code === "KeyC" && (e.ctrlKey || e.metaKey)) {
          copyNotes();
        } else if (e.code === "KeyV" && (e.ctrlKey || e.metaKey)) {
          const presence = selectionPresence();
          const notes = clipboard();
          if (notes && presence) {
            pasteNotes(notes, presence);
          }
        }
      }
    });
  });
  return [createComponent(Piano, {}), (() => {
    var _el$52 = _tmpl$17(), _el$53 = _el$52.firstChild;
    insert(_el$52, createComponent(Hud, {}), _el$53);
    _el$53.$$pointerdown = async (event) => {
      switch (mode()) {
        case "note":
          handleCreateNote(event);
          break;
        case "select":
          handleSelectionBox(event);
          break;
        case "pan":
          handlePan(event);
      }
    };
    _el$53.addEventListener("wheel", (event) => setOrigin((origin) => ({
      x: origin.x - event.deltaX / zoom().x,
      y: origin.y - event.deltaY / zoom().y * (2 / 3)
    })));
    _el$53.$$dblclick = () => setSelectedNotes([]);
    use((element) => {
      onMount(() => {
        const observer = new ResizeObserver(() => {
          setDimensions(element.getBoundingClientRect());
        });
        observer.observe(element);
        onCleanup(() => observer.disconnect());
      });
    }, _el$53);
    _el$53.style.setProperty("width", "100%");
    _el$53.style.setProperty("height", "100%");
    _el$53.style.setProperty("overflow", "hidden");
    insert(_el$53, createComponent(Show, {
      get when() {
        return dimensions();
      },
      children: (dimensions2) => createComponent(dimensionsContext.Provider, {
        value: dimensions2,
        get children() {
          return [createComponent(PianoUnderlay, {}), createComponent(Grid, {}), createComponent(Show, {
            get when() {
              return createMemo(() => mode() === "select")() && selectionArea();
            },
            children: (area) => (() => {
              var _el$56 = _tmpl$18();
              createRenderEffect((_p$) => {
                var _v$67 = area().start.x * projectedWidth() + projectedOrigin().x, _v$68 = area().start.y * projectedHeight() + projectedOrigin().y, _v$69 = (area().end.x - area().start.x) * projectedWidth(), _v$70 = (area().end.y - area().start.y) * projectedHeight();
                _v$67 !== _p$.e && setAttribute(_el$56, "x", _p$.e = _v$67);
                _v$68 !== _p$.t && setAttribute(_el$56, "y", _p$.t = _v$68);
                _v$69 !== _p$.a && setAttribute(_el$56, "width", _p$.a = _v$69);
                _v$70 !== _p$.o && setAttribute(_el$56, "height", _p$.o = _v$70);
                return _p$;
              }, {
                e: void 0,
                t: void 0,
                a: void 0,
                o: void 0
              });
              return _el$56;
            })()
          }), createComponent(Show, {
            get when() {
              return createMemo(() => mode() === "select")() && selectionPresence();
            },
            children: (presence) => (() => {
              var _el$57 = _tmpl$19();
              createRenderEffect((_p$) => {
                var _v$71 = presence().x * projectedWidth() + projectedOrigin().x, _v$72 = presence().y * projectedHeight() + projectedOrigin().y, _v$73 = projectedWidth() * timeScale(), _v$74 = projectedHeight();
                _v$71 !== _p$.e && setAttribute(_el$57, "x", _p$.e = _v$71);
                _v$72 !== _p$.t && setAttribute(_el$57, "y", _p$.t = _v$72);
                _v$73 !== _p$.a && setAttribute(_el$57, "width", _p$.a = _v$73);
                _v$74 !== _p$.o && setAttribute(_el$57, "height", _p$.o = _v$74);
                return _p$;
              }, {
                e: void 0,
                t: void 0,
                a: void 0,
                o: void 0
              });
              return _el$57;
            })()
          }), createComponent(Show, {
            get when() {
              return doc().notes.length > 0;
            },
            get children() {
              var _el$54 = _tmpl$5();
              insert(_el$54, createComponent(For, {
                get each() {
                  return doc().notes;
                },
                children: (note) => createComponent(Note, {
                  note
                })
              }));
              createRenderEffect((_$p) => (_$p = `translate(${projectedOrigin().x}px, ${projectedOrigin().y}px)`) != null ? _el$54.style.setProperty("transform", _$p) : _el$54.style.removeProperty("transform"));
              return _el$54;
            }
          }), (() => {
            var _el$55 = _tmpl$3();
            _el$55.style.setProperty("opacity", "0.075");
            createRenderEffect((_p$) => {
              var _v$63 = styles.now, _v$64 = projectedWidth() * timeScale(), _v$65 = dimensions2().height, _v$66 = `translateX(${projectedOrigin().x + Math.floor(now() / timeScale()) * projectedWidth() * timeScale()}px)`;
              _v$63 !== _p$.e && setAttribute(_el$55, "class", _p$.e = _v$63);
              _v$64 !== _p$.t && setAttribute(_el$55, "width", _p$.t = _v$64);
              _v$65 !== _p$.a && setAttribute(_el$55, "height", _p$.a = _v$65);
              _v$66 !== _p$.o && ((_p$.o = _v$66) != null ? _el$55.style.setProperty("transform", _v$66) : _el$55.style.removeProperty("transform"));
              return _p$;
            }, {
              e: void 0,
              t: void 0,
              a: void 0,
              o: void 0
            });
            return _el$55;
          })(), createComponent(Ruler, {
            loop,
            setLoop
          })];
        }
      })
    }));
    createRenderEffect(() => className(_el$52, styles.main));
    return _el$52;
  })()];
}
delegateEvents(["pointerdown", "click", "dblclick"]);

render(() => createComponent(App, {}), document.getElementById("root"));
